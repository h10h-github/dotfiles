<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>dsl.rb.orig - guard-2.10.2 Documentation</title>

<link href="../../fonts.css" rel="stylesheet">
<link href="../../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/navigation.js"></script>
<script src="../../js/search_index.js"></script>
<script src="../../js/search.js"></script>
<script src="../../js/searcher.js"></script>
<script src="../../js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../lib/guard_rb_orig.html">guard.rb.orig</a>
  
    <li><a href="../../lib/guard/compat/test/helper_rb_orig.html">helper.rb.orig</a>
  
    <li><a href="../../lib/guard/dsl_rb_orig.html">dsl.rb.orig</a>
  
    <li><a href="../../lib/guard/internals/session_rb_orig.html">session.rb.orig</a>
  
    <li><a href="../../lib/guard/plugin_util_rb_orig.html">plugin_util.rb.orig</a>
  
    <li><a href="../../lib/guard/templates/Guardfile.html">Guardfile</a>
  
    <li><a href="../../lib/guard/ui_rb_orig.html">ui.rb.orig</a>
  
    <li><a href="../../lib/guard/version_rb_orig.html">version.rb.orig</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page lib/guard/dsl.rb.orig">

<p>require “guard/guardfile/evaluator” require “guard/interactor” require
“guard/notifier” require “guard/ui” require “guard/watcher”</p>

<p>require “guard/deprecated/dsl” unless Guard::Config.new.strict?</p>

<p># TODO: only for listener require “guard”</p>

<p>module Guard</p>

<pre class="ruby"><span class="ruby-comment"># The Dsl class provides the methods that are used in each `Guardfile` to</span>
<span class="ruby-comment"># describe the behaviour of Guard.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The main keywords of the DSL are {#guard} and {#watch}. These are necessary</span>
<span class="ruby-comment"># to define the used Guard plugins and the file changes they are watching.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># You can optionally group the Guard plugins with the {#group} keyword and</span>
<span class="ruby-comment"># ignore and filter certain paths with the {#ignore} and {#filter} keywords.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># You can set your preferred system notification library with {#notification}</span>
<span class="ruby-comment"># and pass some optional configuration options for the library. If you don&#39;t</span>
<span class="ruby-comment"># configure a library, Guard will automatically pick one with default options</span>
<span class="ruby-comment"># (if you don&#39;t want notifications, specify `:off` as library). Please see</span>
<span class="ruby-comment"># {Notifier} for more information about the supported libraries.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># A more advanced DSL use is the {#callback} keyword that allows you to</span>
<span class="ruby-comment"># execute arbitrary code before or after any of the {Plugin#start},</span>
<span class="ruby-comment"># {Plugin#stop}, {Plugin#reload}, {Plugin#run_all},</span>
<span class="ruby-comment"># {Plugin#run_on_changes}, {Plugin#run_on_additions},</span>
<span class="ruby-comment"># {Plugin#run_on_modifications} and {Plugin#run_on_removals}</span>
<span class="ruby-comment"># Guard plugins method.</span>
<span class="ruby-comment"># You can even insert more hooks inside these methods. Please [checkout the</span>
<span class="ruby-comment"># Wiki page](https://github.com/guard/guard/wiki/Hooks-and-callbacks) for</span>
<span class="ruby-comment"># more details.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The DSL will also evaluate normal Ruby code.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># There are two possible locations for the `Guardfile`:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * The `Guardfile` in the current directory where Guard has been started</span>
<span class="ruby-comment"># * The `.Guardfile` in your home directory.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># In addition, if a user configuration `.guard.rb` in your home directory is</span>
<span class="ruby-comment"># found, it will be appended to the current project `Guardfile`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @see https://github.com/guard/guard/wiki/Guardfile-examples</span>
<span class="ruby-comment">#</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">Dsl</span>
  <span class="ruby-constant">Deprecated</span><span class="ruby-operator">::</span><span class="ruby-constant">Dsl</span>.<span class="ruby-identifier">add_deprecated</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">unless</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">strict?</span>

  <span class="ruby-comment"># Wrap exceptions during parsing Guardfile</span>
  <span class="ruby-keyword">class</span> <span class="ruby-constant">Error</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">RuntimeError</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">WARN_INVALID_LOG_LEVEL</span> = <span class="ruby-string">&quot;Invalid log level `%s` ignored. &quot;</span>     <span class="ruby-string">&quot;Please use either :debug, :info, :warn or :error.&quot;</span>

  <span class="ruby-constant">WARN_INVALID_LOG_OPTIONS</span> = <span class="ruby-string">&quot;You cannot specify the logger options&quot;</span>     <span class="ruby-string">&quot; :only and :except at the same time.&quot;</span>

  <span class="ruby-comment"># Set notification options for the system notifications.</span>
  <span class="ruby-comment"># You can set multiple notifications, which allows you to show local</span>
  <span class="ruby-comment"># system notifications and remote notifications with separate libraries.</span>
  <span class="ruby-comment"># You can also pass `:off` as library to turn off notifications.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Define multiple notifications</span>
  <span class="ruby-comment">#   notification :ruby_gntp</span>
  <span class="ruby-comment">#   notification :ruby_gntp, host: &#39;192.168.1.5&#39;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Symbol, String] notifier the name of the notifier to use</span>
  <span class="ruby-comment"># @param [Hash] options the notification library options</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @see Guard::Notifier for available notifier and its options.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">notification</span>(<span class="ruby-identifier">notifier</span>, <span class="ruby-identifier">options</span> = {})
    <span class="ruby-constant">Notifier</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">notifier</span>.<span class="ruby-identifier">to_sym</span>, <span class="ruby-identifier">options</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">silent</span><span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>))
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the interactor options or disable the interactor.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Pass options to the interactor</span>
  <span class="ruby-comment">#   interactor option1: &#39;value1&#39;, option2: &#39;value2&#39;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Turn off interactions</span>
  <span class="ruby-comment">#   interactor :off</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Symbol, Hash] options either `:off` or a Hash with interactor</span>
  <span class="ruby-comment">#   options</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">interactor</span>(<span class="ruby-identifier">options</span>)
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">options</span>
    <span class="ruby-keyword">when</span> :<span class="ruby-identifier">off</span>
      <span class="ruby-constant">Interactor</span>.<span class="ruby-identifier">enabled</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>
      <span class="ruby-constant">Interactor</span>.<span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Declares a group of Guard plugins to be run with `guard start --group</span>
  <span class="ruby-comment">#   group_name`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Declare two groups of Guard plugins</span>
  <span class="ruby-comment">#   group :backend do</span>
  <span class="ruby-comment">#     guard :spork</span>
  <span class="ruby-comment">#     guard :rspec</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   group :frontend do</span>
  <span class="ruby-comment">#     guard :passenger</span>
  <span class="ruby-comment">#     guard :livereload</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Symbol, String, Array&lt;Symbol, String&gt;] name the group name called</span>
  <span class="ruby-comment">#   from the CLI</span>
  <span class="ruby-comment"># @param [Hash] options the options accepted by the group</span>
  <span class="ruby-comment"># @yield a block where you can declare several Guard plugins</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @see Group</span>
  <span class="ruby-comment"># @see Guard.add_group</span>
  <span class="ruby-comment"># @see #guard</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">group</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
    <span class="ruby-identifier">options</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> {}
    <span class="ruby-identifier">groups</span> = <span class="ruby-identifier">args</span>

    <span class="ruby-identifier">groups</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">group</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">group</span>.<span class="ruby-identifier">to_sym</span> <span class="ruby-operator">==</span> :<span class="ruby-identifier">all</span>
      <span class="ruby-identifier">fail</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;&#39;all&#39; is not an allowed group name!&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
      <span class="ruby-identifier">groups</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">group</span><span class="ruby-operator">|</span>
        <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">state</span>.<span class="ruby-identifier">session</span>.<span class="ruby-identifier">groups</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">group</span>, <span class="ruby-identifier">options</span>)
      <span class="ruby-keyword">end</span>

      <span class="ruby-ivar">@current_groups</span> <span class="ruby-operator">||=</span> []
      <span class="ruby-ivar">@current_groups</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">groups</span>)

      <span class="ruby-keyword">yield</span>

      <span class="ruby-ivar">@current_groups</span>.<span class="ruby-identifier">pop</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">UI</span>.<span class="ruby-identifier">error</span>          <span class="ruby-node">&quot;No Guard plugins found in the group &#39;#{ groups.join(&quot;, &quot;) }&#39;,&quot;</span>         <span class="ruby-string">&quot; please add at least one.&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Declares a Guard plugin to be used when running `guard start`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The name parameter is usually the name of the gem without</span>
  <span class="ruby-comment"># the &#39;guard-&#39; prefix.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The available options are different for each Guard implementation.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Declare a Guard without `watch` patterns</span>
  <span class="ruby-comment">#   guard :rspec</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Declare a Guard with a `watch` pattern</span>
  <span class="ruby-comment">#   guard :rspec do</span>
  <span class="ruby-comment">#     watch %r{.*_spec.rb}</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [String] name the Guard plugin name</span>
  <span class="ruby-comment"># @param [Hash] options the options accepted by the Guard plugin</span>
  <span class="ruby-comment"># @yield a block where you can declare several watch patterns and actions</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @see Plugin</span>
  <span class="ruby-comment"># @see Guard.add_plugin</span>
  <span class="ruby-comment"># @see #watch</span>
  <span class="ruby-comment"># @see #group</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">guard</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">options</span> = {})
    <span class="ruby-ivar">@plugin_options</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">watchers</span><span class="ruby-operator">:</span> [], <span class="ruby-identifier">callbacks</span><span class="ruby-operator">:</span> [])

    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>

    <span class="ruby-ivar">@current_groups</span> <span class="ruby-operator">||=</span> []
    <span class="ruby-identifier">groups</span> = <span class="ruby-ivar">@current_groups</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@current_groups</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">||</span> [:<span class="ruby-identifier">default</span>]
    <span class="ruby-identifier">groups</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">group</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">opts</span> = <span class="ruby-ivar">@plugin_options</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">group</span><span class="ruby-operator">:</span> <span class="ruby-identifier">group</span>)
      <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">state</span>.<span class="ruby-identifier">session</span>.<span class="ruby-identifier">plugins</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">opts</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-ivar">@plugin_options</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Defines a pattern to be watched in order to run actions on file</span>
  <span class="ruby-comment"># modification.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Declare watchers for a Guard</span>
  <span class="ruby-comment">#   guard :rspec do</span>
  <span class="ruby-comment">#     watch(&#39;spec/spec_helper.rb&#39;)</span>
  <span class="ruby-comment">#     watch(%r{^.+_spec.rb})</span>
  <span class="ruby-comment">#     watch(%r{^app/controllers/(.+).rb}) do |m|</span>
  <span class="ruby-comment">#       &#39;spec/acceptance/#{m[1]}s_spec.rb&#39;</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Declare global watchers outside of a Guard</span>
  <span class="ruby-comment">#   watch(%r{^(.+)$}) { |m| puts &quot;#{m[1]} changed.&quot; }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [String, Regexp] pattern the pattern that Guard must watch for</span>
  <span class="ruby-comment"># modification</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @yield a block to be run when the pattern is matched</span>
  <span class="ruby-comment"># @yieldparam [MatchData] m matches of the pattern</span>
  <span class="ruby-comment"># @yieldreturn a directory, a filename, an array of</span>
  <span class="ruby-comment">#   directories / filenames, or nothing (can be an arbitrary command)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @see Guard::Watcher</span>
  <span class="ruby-comment"># @see #guard</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">watch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>)
    <span class="ruby-comment"># Allow watches in the global scope (to execute arbitrary commands) by</span>
    <span class="ruby-comment"># building a generic Guard::Plugin.</span>
    <span class="ruby-ivar">@plugin_options</span> <span class="ruby-operator">||=</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">guard</span>(:<span class="ruby-identifier">plugin</span>) { <span class="ruby-identifier">watch</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>) } <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@plugin_options</span>

    <span class="ruby-ivar">@plugin_options</span>[:<span class="ruby-identifier">watchers</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Watcher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">action</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Defines a callback to execute arbitrary code before or after any of</span>
  <span class="ruby-comment"># the `start`, `stop`, `reload`, `run_all`, `run_on_changes`,</span>
  <span class="ruby-comment"># `run_on_additions`, `run_on_modifications` and `run_on_removals` plugin</span>
  <span class="ruby-comment"># method.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Add callback before the `reload` action.</span>
  <span class="ruby-comment">#   callback(:reload_begin) { puts &quot;Let&#39;s reload!&quot; }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Add callback before the `start` and `stop` actions.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   my_lambda = lambda do |plugin, event, *args|</span>
  <span class="ruby-comment">#     puts &quot;Let&#39;s #{event} #{plugin} with #{args}!&quot;</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   callback(my_lambda, [:start_begin, :start_end])</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Array] args the callback arguments</span>
  <span class="ruby-comment"># @yield a callback block</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">callback</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
    <span class="ruby-ivar">@plugin_options</span> <span class="ruby-operator">||=</span> <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">fail</span> <span class="ruby-string">&quot;callback must be called within a guard block&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@plugin_options</span>

    <span class="ruby-identifier">block</span>, <span class="ruby-identifier">events</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
                      <span class="ruby-comment"># block must be the first argument in that case, the</span>
                      <span class="ruby-comment"># yielded block is ignored</span>
                      <span class="ruby-identifier">args</span>
                    <span class="ruby-keyword">else</span>
                      [<span class="ruby-identifier">block</span>, <span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>]]
                    <span class="ruby-keyword">end</span>
    <span class="ruby-ivar">@plugin_options</span>[:<span class="ruby-identifier">callbacks</span>] <span class="ruby-operator">&lt;&lt;</span> { <span class="ruby-identifier">events</span><span class="ruby-operator">:</span> <span class="ruby-identifier">events</span>, <span class="ruby-identifier">listener</span><span class="ruby-operator">:</span> <span class="ruby-identifier">block</span> }
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Ignores certain paths globally.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Ignore some paths</span>
  <span class="ruby-comment">#   ignore %r{^ignored/path/}, /man/</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Regexp] regexps a pattern (or list of patterns) for ignoring paths</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">ignore</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">regexps</span>)
    <span class="ruby-comment"># TODO: instead, use Guard.reconfigure(ignore: regexps) or something</span>
    <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">listener</span>.<span class="ruby-identifier">ignore</span>(<span class="ruby-identifier">regexps</span>) <span class="ruby-keyword">if</span> <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">listener</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># TODO: deprecate</span>
  <span class="ruby-keyword">alias</span> <span class="ruby-identifier">filter</span> <span class="ruby-identifier">ignore</span>

  <span class="ruby-comment"># Replaces ignored paths globally</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Ignore only these paths</span>
  <span class="ruby-comment">#   ignore! %r{^ignored/path/}, /man/</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Regexp] regexps a pattern (or list of patterns) for ignoring paths</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">ignore!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">regexps</span>)
    <span class="ruby-ivar">@ignore_regexps</span> <span class="ruby-operator">||=</span> []
    <span class="ruby-ivar">@ignore_regexps</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">regexps</span>
    <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">listener</span>.<span class="ruby-identifier">ignore!</span>(<span class="ruby-ivar">@ignore_regexps</span>) <span class="ruby-keyword">if</span> <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">listener</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">alias</span> <span class="ruby-identifier">filter!</span> <span class="ruby-identifier">ignore!</span>

  <span class="ruby-comment"># Configures the Guard logger.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * Log level must be either `:debug`, `:info`, `:warn` or `:error`.</span>
  <span class="ruby-comment"># * Template supports the following placeholders: `:time`, `:severity`,</span>
  <span class="ruby-comment">#   `:progname`, `:pid`, `:unit_of_work_id` and `:message`.</span>
  <span class="ruby-comment"># * Time format directives are the same as `Time#strftime` or</span>
  <span class="ruby-comment">#   `:milliseconds`.</span>
  <span class="ruby-comment"># * The `:only` and `:except` options must be a `RegExp`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Set the log level</span>
  <span class="ruby-comment">#   logger level: :warn</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Set a custom log template</span>
  <span class="ruby-comment">#   logger template: &#39;[Guard - :severity - :progname - :time] :message&#39;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Set a custom time format</span>
  <span class="ruby-comment">#   logger time_format: &#39;%h&#39;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Limit logging to a Guard plugin</span>
  <span class="ruby-comment">#   logger only: :jasmine</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Log all but not the messages from a specific Guard plugin</span>
  <span class="ruby-comment">#   logger except: :jasmine</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Hash] options the log options</span>
  <span class="ruby-comment"># @option options [String, Symbol] level the log level</span>
  <span class="ruby-comment"># @option options [String] template the logger template</span>
  <span class="ruby-comment"># @option options [String, Symbol] time_format the time format</span>
  <span class="ruby-comment"># @option options [Regexp] only show only messages from the matching Guard</span>
  <span class="ruby-comment">#   plugin</span>
  <span class="ruby-comment"># @option options [Regexp] except does not show messages from the matching</span>
  <span class="ruby-comment">#   Guard plugin</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">logger</span>(<span class="ruby-identifier">options</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[:<span class="ruby-identifier">level</span>]
      <span class="ruby-identifier">options</span>[:<span class="ruby-identifier">level</span>] = <span class="ruby-identifier">options</span>[:<span class="ruby-identifier">level</span>].<span class="ruby-identifier">to_sym</span>

      <span class="ruby-keyword">unless</span> [:<span class="ruby-identifier">debug</span>, :<span class="ruby-identifier">info</span>, :<span class="ruby-identifier">warn</span>, :<span class="ruby-identifier">error</span>].<span class="ruby-identifier">include?</span> <span class="ruby-identifier">options</span>[:<span class="ruby-identifier">level</span>]
        <span class="ruby-constant">UI</span>.<span class="ruby-identifier">warning</span> <span class="ruby-constant">WARN_INVALID_LOG_LEVEL</span> <span class="ruby-operator">%</span> [<span class="ruby-identifier">options</span>[:<span class="ruby-identifier">level</span>]]
        <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span> :<span class="ruby-identifier">level</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[:<span class="ruby-identifier">only</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">options</span>[:<span class="ruby-identifier">except</span>]
      <span class="ruby-constant">UI</span>.<span class="ruby-identifier">warning</span> <span class="ruby-constant">WARN_INVALID_LOG_OPTIONS</span>

      <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span> :<span class="ruby-identifier">only</span>
      <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span> :<span class="ruby-identifier">except</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Convert the :only and :except options to a regular expression</span>
    [:<span class="ruby-identifier">only</span>, :<span class="ruby-identifier">except</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">name</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">name</span>]

      <span class="ruby-identifier">list</span> = [].<span class="ruby-identifier">push</span>(<span class="ruby-identifier">options</span>[<span class="ruby-identifier">name</span>]).<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">plugin</span><span class="ruby-operator">|</span>
        <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">escape</span>(<span class="ruby-identifier">plugin</span>.<span class="ruby-identifier">to_s</span>)
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">options</span>[<span class="ruby-identifier">name</span>] = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;|&quot;</span>), <span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">IGNORECASE</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-constant">UI</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the default scope on startup</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Scope Guard to a single group</span>
  <span class="ruby-comment">#   scope group: :frontend</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Scope Guard to multiple groups</span>
  <span class="ruby-comment">#   scope groups: [:specs, :docs]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Scope Guard to a single plugin</span>
  <span class="ruby-comment">#   scope plugin: :test</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example Scope Guard to multiple plugins</span>
  <span class="ruby-comment">#   scope plugins: [:jasmine, :rspec]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Hash] scopes the scope for the groups and plugins</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">scope</span>(<span class="ruby-identifier">scope</span> = {})
    <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">state</span>.<span class="ruby-identifier">session</span>.<span class="ruby-identifier">guardfile_scope</span>(<span class="ruby-identifier">scope</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">evaluate</span>(<span class="ruby-identifier">contents</span>, <span class="ruby-identifier">filename</span>, <span class="ruby-identifier">lineno</span>) <span class="ruby-comment"># :nodoc</span>
    <span class="ruby-identifier">instance_eval</span>(<span class="ruby-identifier">contents</span>, <span class="ruby-identifier">filename</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">lineno</span>)
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">StandardError</span>, <span class="ruby-constant">ScriptError</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
    <span class="ruby-identifier">prefix</span> = <span class="ruby-string">&quot;\n\t(dsl)&gt; &quot;</span>
    <span class="ruby-identifier">cleaned_backtrace</span> = <span class="ruby-identifier">_cleanup_backtrace</span>(<span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>)
    <span class="ruby-identifier">backtrace</span> = <span class="ruby-node">&quot;#{prefix}#{cleaned_backtrace.join(prefix)}&quot;</span>
    <span class="ruby-identifier">msg</span> = <span class="ruby-string">&quot;Invalid Guardfile, original error is: \n\n%s, \nbacktrace: %s&quot;</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-identifier">format</span>(<span class="ruby-identifier">msg</span>, <span class="ruby-identifier">e</span>, <span class="ruby-identifier">backtrace</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the directories to pass to Listen</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example watch only given directories</span>
  <span class="ruby-comment">#   directories %w(lib specs)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Array] directories directories for Listen to watch</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">directories</span>(<span class="ruby-identifier">directories</span>)
    <span class="ruby-identifier">directories</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dir</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">fail</span> <span class="ruby-node">&quot;Directory #{dir.inspect} does not exist!&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">exist?</span>(<span class="ruby-identifier">dir</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">state</span>.<span class="ruby-identifier">session</span>.<span class="ruby-identifier">watchdirs</span> = <span class="ruby-identifier">directories</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets Guard to clear the screen before every task is run</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example switching clearing the screen on</span>
  <span class="ruby-comment">#   clearing(:on)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param [Symbol] on &#39;:on&#39; to turn on, &#39;:off&#39; (default) to turn off</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">clearing</span>(<span class="ruby-identifier">on</span>)
    <span class="ruby-constant">Guard</span>.<span class="ruby-identifier">state</span>.<span class="ruby-identifier">session</span>.<span class="ruby-identifier">clearing</span>(<span class="ruby-identifier">on</span> <span class="ruby-operator">==</span> :<span class="ruby-identifier">on</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">_cleanup_backtrace</span>(<span class="ruby-identifier">backtrace</span>)
    <span class="ruby-identifier">dirs</span> = { <span class="ruby-constant">File</span>.<span class="ruby-identifier">realpath</span>(<span class="ruby-constant">Dir</span>.<span class="ruby-identifier">pwd</span>) =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;.&quot;</span>, }

    <span class="ruby-identifier">gem_env</span> = <span class="ruby-constant">ENV</span>[<span class="ruby-string">&quot;GEM_HOME&quot;</span>] <span class="ruby-operator">||</span> <span class="ruby-string">&quot;&quot;</span>
    <span class="ruby-identifier">dirs</span>[<span class="ruby-identifier">gem_env</span>] = <span class="ruby-string">&quot;$GEM_HOME&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">gem_env</span>.<span class="ruby-identifier">empty?</span>

    <span class="ruby-identifier">gem_paths</span> = (<span class="ruby-constant">ENV</span>[<span class="ruby-string">&quot;GEM_PATH&quot;</span>] <span class="ruby-operator">||</span> <span class="ruby-string">&quot;&quot;</span>).<span class="ruby-identifier">split</span>(<span class="ruby-constant">File</span><span class="ruby-operator">::</span><span class="ruby-constant">PATH_SEPARATOR</span>)
    <span class="ruby-identifier">gem_paths</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">path</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">dirs</span>[<span class="ruby-identifier">path</span>] = <span class="ruby-node">&quot;$GEM_PATH[#{index}]&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">dup</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">raw_line</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">path</span> = <span class="ruby-keyword">nil</span>
      <span class="ruby-identifier">symlinked_path</span> = <span class="ruby-identifier">raw_line</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&quot;:&quot;</span>).<span class="ruby-identifier">first</span>
      <span class="ruby-keyword">begin</span>
        <span class="ruby-identifier">path</span> = <span class="ruby-identifier">raw_line</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-identifier">symlinked_path</span>, <span class="ruby-constant">File</span>.<span class="ruby-identifier">realpath</span>(<span class="ruby-identifier">symlinked_path</span>))
        <span class="ruby-identifier">dirs</span>.<span class="ruby-identifier">detect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">dir</span>, <span class="ruby-identifier">name</span><span class="ruby-operator">|</span> <span class="ruby-identifier">path</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">realpath</span>(<span class="ruby-identifier">dir</span>), <span class="ruby-identifier">name</span>) }
        <span class="ruby-identifier">path</span>
      <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">ENOENT</span>
        <span class="ruby-identifier">path</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">symlinked_path</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

