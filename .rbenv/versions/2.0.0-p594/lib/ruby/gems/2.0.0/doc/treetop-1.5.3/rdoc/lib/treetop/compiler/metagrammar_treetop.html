<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>metagrammar.treetop - treetop-1.5.3 Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
</script>

<script src="../../../js/jquery.js"></script>
<script src="../../../js/darkfish.js"></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../../LICENSE.html">LICENSE</a>
  
    <li><a href="../../../README_md.html">README</a>
  
    <li><a href="../../../lib/treetop/compiler/metagrammar_treetop.html">metagrammar.treetop</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page lib/treetop/compiler/metagrammar.treetop">

<p>module <a href="../../../Treetop.html">Treetop</a></p>

<pre>module Compiler
  grammar Metagrammar
    rule treetop_file
      requires:(space? require_statement)* prefix:space? module_or_grammar suffix:space? {
        def compile
          requires.text_value + prefix.text_value + module_or_grammar.compile + suffix.text_value
        end
      }
    end

    rule require_statement
      prefix:space? &quot;require&quot; [ \t]+ [^\n\r]+ [\n\r]
    end

    rule module_or_grammar
      module_declaration / grammar
    end

    rule module_declaration
      prefix:(&#39;module&#39; space name:([A-Z] alphanumeric_char* (&#39;::&#39; [A-Z] alphanumeric_char*)*) space) module_contents:(module_declaration / grammar) suffix:(space &#39;end&#39;) {
        def compile
          prefix.text_value + module_contents.compile + suffix.text_value
        end

        def parser_name
          prefix.name.text_value+&#39;::&#39;+module_contents.parser_name
        end
      }
    end

    rule grammar
      &#39;grammar&#39; space grammar_name space (&#39;do&#39; space)? declaration_sequence space? &#39;end&#39; &lt;Grammar&gt;
    end

    rule grammar_name
      ([A-Z] alphanumeric_char*)
    end

    rule declaration_sequence
      head:declaration tail:(space declaration)* &lt;DeclarationSequence&gt; {
        def declarations
          [head] + tail
        end

        def tail
          super.elements.map { |elt| elt.declaration }
        end
      }
      /
      &#39;&#39; {
        def compile(builder)
        end
      }
    end

    rule declaration
      parsing_rule / include_declaration
    end

    rule include_declaration
      &#39;include&#39; space [A-Z] (alphanumeric_char / &#39;::&#39;)* {
        def compile(builder)
          builder &lt;&lt; text_value
        end
      }
    end

    rule parsing_rule
      &#39;rule&#39; space nonterminal space (&#39;do&#39; space)? parsing_expression space &#39;end&#39; &lt;ParsingRule&gt;
    end

    rule parsing_expression
      choice / sequence / primary
    end

    rule choice
      head:alternative tail:(space? &#39;/&#39; space? alternative)+ &lt;Choice&gt; {
        def alternatives
          [head] + tail
        end

        def tail
          super.elements.map {|elt| elt.alternative}
        end

        def inline_modules
          (alternatives.map {|alt| alt.inline_modules }).flatten
        end
      }
    end

    rule sequence
      sequence_body node_class_declarations &lt;Sequence&gt; {
        def sequence_elements
          [sequence_body.head] + tail
        end

        def tail
          sequence_body.tail
        end

        def inline_modules
          (sequence_elements.map {|elt| elt.inline_modules}).flatten +
          [sequence_element_accessor_module] +
          node_class_declarations.inline_modules
        end

        def inline_module_name
          node_class_declarations.inline_module_name
        end
      }
    end

    rule sequence_body
      variable_length_sequence_body / labeled_expression_sequence_body
    end

    rule variable_length_sequence_body
      head:optionally_labeled_sequence_primary tail:(space optionally_labeled_sequence_primary)+ {
        def tail
          super.elements.map {|elt| elt.optionally_labeled_sequence_primary }
        end
      }
    end

    rule labeled_expression_sequence_body
      labeled_sequence_primary {
        def head
          self
        end

        def tail
          []
        end
      }
    end

    rule alternative
      sequence / primary
    end

    rule primary
      prefix atomic {
        def compile(address, builder, parent_expression=nil)
          prefix.compile(address, builder, self)
        end

        def prefixed_expression
          atomic
        end

        def inline_modules
          atomic.inline_modules
        end

        def inline_module_name
          nil
        end
      }
      /
      prefix space? predicate_block {
        def compile(address, builder, parent_expression=nil)
          prefix.compile(address, builder, self)
        end
        def prefixed_expression
          predicate_block
        end
        def inline_modules
          []
        end
      }
      /
      atomic suffix node_class_declarations {
        def compile(address, builder, parent_expression=nil)
          suffix.compile(address, builder, self)
        end

        def optional_expression
          atomic
        end

        def node_class_name
          node_class_declarations.node_class_name
        end

        def inline_modules
          atomic.inline_modules + node_class_declarations.inline_modules
        end

        def inline_module_name
          node_class_declarations.inline_module_name
        end
      }
      /
      atomic node_class_declarations {
        def compile(address, builder, parent_expression=nil)
          atomic.compile(address, builder, self)
        end

        def node_class_name
          node_class_declarations.node_class_name
        end

        def inline_modules
          atomic.inline_modules + node_class_declarations.inline_modules
        end

        def inline_module_name
          node_class_declarations.inline_module_name
        end
      }
    end

    rule optionally_labeled_sequence_primary
      labeled_sequence_primary / unlabeled_sequence_primary
    end

    rule labeled_sequence_primary
      named_label sequence_primary {
        def compile(lexical_address, builder)
          sequence_primary.compile(lexical_address, builder)
        end

        def inline_modules
          sequence_primary.inline_modules
        end

        def label_name
          named_label.name
        end
      }
    end

    rule unlabeled_sequence_primary
      null_label sequence_primary {
        def compile(lexical_address, builder)
          sequence_primary.compile(lexical_address, builder)
        end

        def inline_modules
          sequence_primary.inline_modules
        end

        def label_name
          if sequence_primary.instance_of?(Nonterminal)
            sequence_primary.text_value
          else
            nil
          end
        end
      }
    end

    rule label
      named_label / null_label
    end

    rule named_label
      (alpha_char alphanumeric_char*) &#39;:&#39; {
        def name
          elements[0].text_value
        end
      }
    end

    rule null_label
      &#39;&#39; {
        def name
          nil
        end
      }
    end

    rule sequence_primary
      prefix atomic {
        def compile(lexical_address, builder)
          prefix.compile(lexical_address, builder, self)
        end

        def prefixed_expression
          elements[1]
        end

        def inline_modules
          atomic.inline_modules
        end

        def inline_module_name
          nil
        end
      }
      /
      prefix space? predicate_block {
        def compile(address, builder, parent_expression=nil)
          prefix.compile(address, builder, self)
        end
        def prefixed_expression
          predicate_block
        end
        def inline_modules
          []
        end
      }
      /
      atomic suffix {
        def compile(lexical_address, builder)
          suffix.compile(lexical_address, builder, self)
        end

        def node_class_name
          nil
        end

        def inline_modules
          atomic.inline_modules
        end

        def inline_module_name
          nil
        end
      }
      /
      atomic
    end

    rule suffix
      repetition_suffix / optional_suffix
    end

    rule optional_suffix
      &#39;?&#39; &lt;Optional&gt;
    end

    rule node_class_declarations
      node_class_expression trailing_inline_module {
        def node_class_name
          node_class_expression.node_class_name
        end

        def inline_modules
          trailing_inline_module.inline_modules
        end

        def inline_module
          trailing_inline_module.inline_module
        end

        def inline_module_name
          inline_module.module_name if inline_module
        end
      }
    end

    rule repetition_suffix
      &#39;+&#39; &lt;OneOrMore&gt; / &#39;*&#39; &lt;ZeroOrMore&gt; / occurrence_range
    end

    rule occurrence_range
      space? min:([0-9])* &#39;..&#39; max:([0-9])* &lt;OccurrenceRange&gt;
    end

    rule prefix
      &#39;&amp;&#39; &lt;AndPredicate&gt; / &#39;!&#39; &lt;NotPredicate&gt; / &#39;~&#39; &lt;TransientPrefix&gt;
    end

    rule atomic
      terminal
      /
      nonterminal
      /
      parenthesized_expression
    end

    rule parenthesized_expression
      &#39;(&#39; space? parsing_expression space? &#39;)&#39; &lt;ParenthesizedExpression&gt; {
        def inline_modules
          parsing_expression.inline_modules
        end
      }
    end

    rule nonterminal
      !keyword_inside_grammar (alpha_char alphanumeric_char*) &lt;Nonterminal&gt;
    end

    rule terminal
      quoted_string / character_class / anything_symbol
    end

    rule quoted_string
      qs:(single_quoted_string / double_quoted_string) modifiers:([ir]*) &lt;Terminal&gt; {
        def string
          qs.text_value
        end
      }
    end

    rule double_quoted_string
      &#39;&quot;&#39; string:(!&#39;&quot;&#39; (&quot;\\\\&quot; / &#39;\&quot;&#39; / .))* &#39;&quot;&#39;
    end

    rule single_quoted_string
      &quot;&#39;&quot; string:(!&quot;&#39;&quot; (&quot;\\\\&quot; / &quot;\\&#39;&quot; / .))* &quot;&#39;&quot;
    end

    rule character_class
      &#39;[&#39; characters:(!&#39;]&#39; (&#39;\\&#39; . / bracket_expression / !&#39;\\&#39; .))+ &#39;]&#39; &lt;CharacterClass&gt; {
        def characters
          super.text_value
        end
      }
    end

    rule bracket_expression
       &#39;[:&#39; &#39;^&#39;? (
         &#39;alnum&#39; / &#39;alpha&#39; / &#39;blank&#39; / &#39;cntrl&#39; / &#39;digit&#39; / &#39;graph&#39; / &#39;lower&#39; /
         &#39;print&#39; / &#39;punct&#39; / &#39;space&#39; / &#39;upper&#39; / &#39;xdigit&#39; / &#39;word&#39;
       ) &#39;:]&#39;
    end

    rule anything_symbol
      &#39;.&#39; &lt;AnythingSymbol&gt;
    end

    rule node_class_expression
      space &#39;&lt;&#39; (!&#39;&gt;&#39; .)+ &#39;&gt;&#39; {
        def node_class_name
          elements[2].text_value
        end
      }
      /
      &#39;&#39; {
        def node_class_name
          nil
        end
      }
    end

    rule trailing_inline_module
      space inline_module {
        def inline_modules
          [inline_module]
        end

        def inline_module_name
          inline_module.module_name
        end
      }
      /
      &#39;&#39; {
        def inline_modules
          []
        end

        def inline_module
          nil
        end

        def inline_module_name
          nil
        end
      }
    end

    rule predicate_block
      &#39;&#39; inline_module &lt;PredicateBlock&gt;
    end

    rule inline_module
      &#39;{&#39; (inline_module / ![{}] .)* &#39;}&#39; &lt;InlineModule&gt;
    end

    rule keyword_inside_grammar
      (&#39;rule&#39; / &#39;end&#39;) !non_space_char
    end

    rule non_space_char
      !space .
    end

    rule alpha_char
      [A-Za-z_]
    end

    rule alphanumeric_char
      alpha_char / [0-9]
    end

    rule space
      (white / comment_to_eol)+
    end

    rule comment_to_eol
      &#39;#&#39; (!&quot;\n&quot; .)*
    end

    rule white
      [ \t\n\r]
    end
  end
end</pre>

<p>end</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

