<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>GUIDE - byebug-4.0.4 Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-First+Steps">First Steps</a>
    <li><a href="#label-Second+Sample+Session-3A+Delving+Deeper">Second Sample Session: Delving Deeper</a>
    <li><a href="#label-Attaching+to+a+running+program+with+byebug">Attaching to a running program with <code>byebug</code></a>
    <li><a href="#label-Debugging+Oddities-3A+How+debugging+Ruby+may+be+different+from+other+languages">Debugging Oddities: How debugging Ruby may be different from other languages</a>
    <li><a href="#label-Bouncing+Around+in+Blocks+-28iterators-29">Bouncing Around in Blocks (iterators)</a>
    <li><a href="#label-No+Parameter+Values+in+a+Call+Stack">No Parameter Values in a Call Stack</a>
    <li><a href="#label-Lines+You+Can+Stop+At">Lines You Can Stop At</a>
    <li><a href="#label-Threading+support">Threading support</a>
    <li><a href="#label-Getting+in+-26+out">Getting in &amp; out</a>
    <li><a href="#label-Starting+byebug">Starting byebug</a>
    <li><a href="#label-h+-7C+--help">-h | –help</a>
    <li><a href="#label-v+-7C+--version">-v | –version</a>
    <li><a href="#label-d+-7C+--debug">-d | –debug</a>
    <li><a href="#label-I+-7C+--include+-3Cpath-3E">-I | –include &lt;path&gt;</a>
    <li><a href="#label-m+-7C+--post-mortem">-m | –post-mortem</a>
    <li><a href="#label--no-quit">–no-quit</a>
    <li><a href="#label--no-stop">–no-stop</a>
    <li><a href="#label-r+-7C+--require+-3Clib-3E">-r | –require &lt;lib&gt;</a>
    <li><a href="#label-t+-7C+--trace">-t | –trace</a>
    <li><a href="#label-Byebug+default+options">Byebug default options</a>
    <li><a href="#label-Command+Files">Command Files</a>
    <li><a href="#label-Quitting+byebug">Quitting byebug</a>
    <li><a href="#label-Calling+byebug+from+inside+your+program">Calling byebug from inside your program</a>
    <li><a href="#label-Restarting+Byebug">Restarting Byebug</a>
    <li><a href="#label-Debugging+remote+programs">Debugging remote programs</a>
    <li><a href="#label-Byebug+Command+Reference">Byebug Command Reference</a>
    <li><a href="#label-Command+Syntax">Command Syntax</a>
    <li><a href="#label-Command+Output">Command Output</a>
    <li><a href="#label-Command+Help">Command Help</a>
    <li><a href="#label-Control+Commands-3A+quit-2C+restart-2C+source">Control Commands: quit, restart, source</a>
    <li><a href="#label-Quit">Quit</a>
    <li><a href="#label-Restart">Restart</a>
    <li><a href="#label-Source">Source</a>
    <li><a href="#label-Display+Commands-3A+display-2C+undisplay">Display Commands: display, undisplay</a>
    <li><a href="#label-Display">Display</a>
    <li><a href="#label-Undisplay">Undisplay</a>
    <li><a href="#label-Print+Commands">Print Commands</a>
    <li><a href="#label-Printing+variables">Printing variables</a>
    <li><a href="#label-Examining+Program+Source+Files-3A+list">Examining Program Source Files: list</a>
    <li><a href="#label-Editing+Source+files-3A+edit">Editing Source files: edit</a>
    <li><a href="#label-The+stack+trace">The stack trace</a>
    <li><a href="#label-Printing+the+Stack-3A+where+command">Printing the Stack: <code>where</code> command</a>
    <li><a href="#label-Selecting+a+frame-3A+up-2C+down+and+frame+commands">Selecting a frame: <code>up</code>, <code>down</code> and <code>frame</code> commands</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./CHANGELOG_md.html">CHANGELOG</a>
  
    <li><a href="./CONTRIBUTING_md.html">CONTRIBUTING</a>
  
    <li><a href="./GUIDE_md.html">GUIDE</a>
  
    <li><a href="./README_md.html">README</a>
  
    <li><a href="./ext/byebug/Makefile.html">Makefile</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page GUIDE.md">

<h3 id="label-First+Steps">First Steps<span><a href="#label-First+Steps">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>A handful of commands are enough to get started using <code>byebug</code>.
The following session illustrates these commands. Take the following sample
file:</p>

<pre class="ruby"><span class="ruby-comment">#</span>
<span class="ruby-comment"># The n&#39;th triangle number: triangle(n) = n*(n+1)/2 = 1 + 2 + ... + n</span>
<span class="ruby-comment">#</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">triangle</span>(<span class="ruby-identifier">n</span>)
  <span class="ruby-identifier">tri</span> = <span class="ruby-value">0</span>

  <span class="ruby-value">0</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">n</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">tri</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">i</span> }

  <span class="ruby-identifier">tri</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">t</span> = <span class="ruby-identifier">triangle</span>(<span class="ruby-value">3</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">t</span>
</pre>

<p>Let&#39;s debug it.</p>

<pre>$ byebug /path/to/triangle.rb

[1, 10] in /path/to/triangle.rb
    1: #
    2: # The n&#39;th triangle number: triangle(n) = n*(n+1)/2 = 1 + 2 + ... + n
    3: #
=&gt;  4: def triangle(n)
    5:   tri = 0
    6:
    7:   0.upto(n) { |i| tri += i }
    8:
    9:   tri
   10: end
(byebug)</pre>

<p>We are currently stopped before the first executable line of the program:
line 4 of <code>triangle.rb</code>. If you are used to less dynamic
languages and have used debuggers for more statically compiled languages
like C, C++, or Java, it may seem odd to be stopped before a function
definition but in Ruby line 4 is executed.</p>

<p>Byebug&#39;s prompt is <code>(byebug)</code>. If the program has died and
you are in post-mortem debugging, <code>(byebug:post-mortem)</code> is used
instead. If the program has terminated normally and the
<code>--no-quit</code> option has been specified in the command line, the
prompt will be <code>(byebug:ctrl)</code> instead. The commands available
change depending on the program&#39;s state.</p>

<p><a href="Byebug.html">Byebug</a> automatically lists 10 lines of code
centered around the current line every time it is stopped. The current line
is marked with <code>=&gt;</code>. If the range would overflow the
beggining or the end of the file, byebug will move it accordingly so that
only actual real lines of code are displayed.</p>

<p>Now let us step through the program.</p>

<pre>(byebug) step

[5, 14] in /path/to/triangle.rb
    5:   tri = 0
    6:
    7:   0.upto(n) { |i| tri += i }
    9:   end
   10:
   11:   tri
   12: end
   13:
=&gt; 14: triangle(3)
(byebug) &lt;RET&gt; # hit enter

[1, 10] in /path/to/triangle.rb
    1: #
    2: # The n&#39;th triangle number: triangle(n) = n*(n+1)/2 = 1 + 2 + ... + n
    3: #
    4: def triangle(n)
=&gt;  5:   tri = 0
    6:
    7:   0.upto(n) { |i| tri += i }
    8:
    9:   tri
   10: end
(byebug) p tri
nil
(byebug) step

[2, 11] in /path/to/triangle.rb
    2: # The n&#39;th triangle number: triangle(n) = n*(n+1)/2 = 1 + 2 + ... + n
    3: #
    4: def triangle(n)
    5:   tri = 0
    6:
=&gt;  7:   0.upto(n) { |i| tri += i }
    8:
    9:   tri
   10: end
   11:
(byebug) p tri
0</pre>

<p>The first <code>step</code> command runs the script one executable unit.
The second command we entered was just hitting the return key:
<code>byebug</code> remembers the last command you entered was
<code>step</code> and runs it again.</p>

<p>One way to print the values of variables is <code>p</code> (there are other
ways). When we look at the value of <code>tri</code> the first time, we see
it is <code>nil</code>. Again we are stopped <em>before</em> the assignment
on line 5, and this variable hadn&#39;t been set previously. However after
issuing another <code>step</code> command we see that the value is 0 as
expected. If every time we stop we want to see the value of
<code>tri</code> to see how things are going, there is a better way by
setting a display expression:</p>

<pre>(byebug) display tri
1: tri = 0</pre>

<p>Now let us run the program until right before we return from the function.
We&#39;ll want to see which lines get run, so we turn on <em>line
tracing</em>. If we don&#39;t want whole paths to be displayed when
tracing, we can turn on <em>basename</em>.</p>

<pre>(byebug) set linetrace
linetrace is on
(byebug) set basename
basename is on
(byebug) finish 0
Tracing: triangle.rb:7   0.upto(n) { |i| tri += i }
1: tri = 0
Tracing: triangle.rb:7   0.upto(n) { |i| tri += i }
1: tri = 0
Tracing: triangle.rb:7   0.upto(n) { |i| tri += i }
1: tri = 1
Tracing: triangle.rb:7   0.upto(n) { |i| tri += i }
1: tri = 3
Tracing: triangle.rb:9   tri
1: tri = 6
1: tri = 6

[4, 13] in /home/davidr/Proyectos/byebug/triangle.rb
    4: def triangle(n)
    5:   tri = 0
    6:
    7:   0.upto(n) { |i| tri += i }
    8:
    9:   tri
=&gt; 10: end
   11:
   12: t = triangle(3)
   13: puts t
(byebug) quit
Really quit? (y/n)
y</pre>

<p>So far, so good. As you can see from the above to get out of
<code>byebug</code>, one can issue a <code>quit</code> command
(<code>q</code> and <code>exit</code> are just as good). If you want to
quit without being prompted, suffix the command with an exclamation mark,
e.g., <code>q!</code>.</p>

<h3 id="label-Second+Sample+Session-3A+Delving+Deeper">Second Sample Session: Delving Deeper<span><a href="#label-Second+Sample+Session-3A+Delving+Deeper">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In this section we&#39;ll introduce breakpoints, the call stack and
restarting. Below we will debug a simple Ruby program to solve the classic
Towers of Hanoi puzzle. It is augmented by the bane of programming: some
command-parameter processing with error checking.</p>

<pre class="ruby"><span class="ruby-comment">#</span>
<span class="ruby-comment"># Solves the classic Towers of Hanoi puzzle.</span>
<span class="ruby-comment">#</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">hanoi</span>(<span class="ruby-identifier">n</span>, <span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span>)
  <span class="ruby-identifier">hanoi</span>(<span class="ruby-identifier">n</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">a</span>, <span class="ruby-identifier">c</span>, <span class="ruby-identifier">b</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>

  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Move disk #{a} to #{b}&quot;</span>

  <span class="ruby-identifier">hanoi</span>(<span class="ruby-identifier">n</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">c</span>, <span class="ruby-identifier">b</span>, <span class="ruby-identifier">a</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">n_args</span> = <span class="ruby-identifier">$ARGV</span>.<span class="ruby-identifier">length</span>

<span class="ruby-identifier">fail</span>(<span class="ruby-string">&#39;*** Need number of disks or no parameter&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">n_args</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
</pre>

<p>Recall in the first section it was stated that before the <code>def</code>
is run, the method it names is undefined. Let&#39;s check that out. First
let&#39;s see what private methods we can call before running <code>def
hanoi</code>.</p>

<pre>$ byebug path/to/hanoi.rb

    1: #
    2: # Solves the classic Towers of Hanoi puzzle.
    3: #
    4: def hanoi(n, a, b, c)
    5:   hanoi(n - 1, a, c, b) if n - 1 &gt; 0
    6:
    7:   puts &quot;Move disk #{a} to #{b}&quot;
    8:
    9:   hanoi(n - 1, c, b, a) if n - 1 &gt; 0
   10: end
(byebug) private_methods
[:public, :private, :include, :using, :define_method, :default_src_encoding, ...</pre>

<p><code>private_methods</code> is not a byebug command but a Ruby feature. By
default, when <code>byebug</code> doesn&#39;t understand a command, it will
evaluate it as if it was a Ruby command. If you don&#39;t want this
behaviour, you can use <code>set noautoeval</code> or even drop it in your
<code>.byebugrc</code> file if you want that behaviour permanently. The
output of <code>private_methods</code>, thought, is unwieldy for our
purpose: check whether <code>hanoi</code> method is in the list.
Fortunately, byebug has nice formatting features: we can sort the output
and put it into columns list using the print command <code>ps</code>. It
also has a <code>width</code> setting that let&#39;s us adapt the width of
the output so that it nicely fits our screen.</p>

<pre>(byebug) set width 80
Maximum width of byebug&#39;s output is 80
(byebug) ps private_methods
Array             default_src_encoding  open                        sleep      
Complex           define_method         p                           spawn      
Digest            eval                  pp                          sprintf    
Float             exec                  print                       srand      
Hash              exit                  printf                      syscall    
Integer           exit!                 private                     system     
Pathname          fail                  proc                        test       
Rational          fork                  public                      throw      
String            format                putc                        timeout    
URI               gem_original_require  puts                        trace_var  
__callee__        gets                  raise                       trap       
__dir__           global_variables      rand                        untrace_var
__method__        include               readline                    using      
`                 initialize            readlines                   warn       
abort             initialize_clone      require                     y          
at_exit           initialize_copy       require_relative          
autoload          initialize_dup        respond_to_missing?       
autoload?         iterator?             rubygems_require          
binding           lambda                select                    
block_given?      load                  set_trace_func            
caller            local_variables       singleton_method_added    
caller_locations  loop                  singleton_method_removed  
catch             method_missing        singleton_method_undefined
(byebug)</pre>

<p>Now let&#39;s see what happens after stepping:</p>

<pre>(byebug) private_methods.member?(:hanoi)
false
(byebug) step

[5, 14] in /path/to/hanoi.rb
    5:   hanoi(n - 1, a, c, b) if n - 1 &gt; 0
    6:
    7:   puts &quot;Move disk #{a} to #{b}&quot;
    8:
    9:   hanoi(n - 1, c, b, a) if n - 1 &gt; 0
   10: end
   11:
=&gt; 12: n_args = $ARGV.length
   13:
   14: fail(&#39;*** Need number of disks or no parameter&#39;) if n_args &gt; 1
(byebug) private_methods.member?(:hanoi)
true
(byebug)</pre>

<p>Okay, lets go on and talk about program arguments.</p>

<pre>(byebug) $ARGV
[]</pre>

<p>Oops. We forgot to specify any parameters to this program. Let&#39;s try
again. We can use the <code>restart</code> command here.</p>

<pre>(byebug) restart 3
Re exec&#39;ing:
  /path/to/bin/byebug /path/to/hanoi.rb 3

[1, 10] in /path/to/hanoi.rb
    1: #
    2: # Solves the classic Towers of Hanoi puzzle.
    3: #
=&gt;  4: def hanoi(n, a, b, c)
    5:   hanoi(n - 1, a, c, b) if n - 1 &gt; 0
    6:
    7:   puts &quot;Move disk #{a} to #{b}&quot;
    8:
    9:   hanoi(n - 1, c, b, a) if n - 1 &gt; 0
   10: end
(byebug) break 5
Created breakpoint 1 at /path/to/hanoi.rb:5
(byebug) continue
Stopped by breakpoint 1 at /path/to/hanoi.rb:5

[1, 10] in /path/to/hanoi.rb
    1: #
    2: # Solves the classic Towers of Hanoi puzzle.
    3: #
    4: def hanoi(n, a, b, c)
=&gt;  5:   hanoi(n - 1, a, c, b) if n - 1 &gt; 0
    6:
    7:   puts &quot;Move disk #{a} to #{b}&quot;
    8:
    9:   hanoi(n - 1, c, b, a) if n - 1 &gt; 0
   10: end
(byebug) display n
1: n = 3
(byebug) display a
2: a = :a
(byebug) display b
3: b = :b
(byebug) undisplay 3
(byebug) continue
Stopped by breakpoint 1 at /path/to/hanoi.rb:5
1: n = 2
2: a = :a
[1, 10] in /path/to/hanoi.rb
    1: #
    2: # Solves the classic Towers of Hanoi puzzle.
    3: #
    4: def hanoi(n, a, b, c)
=&gt;  5:   hanoi(n - 1, a, c, b) if n - 1 &gt; 0
    6:
    7:   puts &quot;Move disk #{a} to #{b}&quot;
    8:
    9:   hanoi(n - 1, c, b, a) if n - 1 &gt; 0
   10: end

(byebug) c
Stopped by breakpoint 1 at /path/to/hanoi.rb:5
1: n = 1
2: a = :a

[1, 10] in /path/to/hanoi.rb
    1: #
    2: # Solves the classic Towers of Hanoi puzzle.
    3: #
    4: def hanoi(n, a, b, c)
=&gt;  5:   hanoi(n - 1, a, c, b) if n - 1 &gt; 0
    6:
    7:   puts &quot;Move disk #{a} to #{b}&quot;
    8:
    9:   hanoi(n - 1, c, b, a) if n - 1 &gt; 0
   10: end
(byebug) set nofullpath
fullpath is off
(byebug) where
--&gt; #0  Object.hanoi(n#Fixnum, a#Symbol, b#Symbol, c#Symbol) at .../shortpath/to/hanoi.rb:5
    #1  Object.hanoi(n#Fixnum, a#Symbol, b#Symbol, c#Symbol) at .../shortpath/to/hanoi.rb:5
    #2  &lt;top (required)&gt; at .../Proyectos/byebug/hanoi.rb:28
(byebug)</pre>

<p>In the above we added new commands: <code>break</code> (see
{breakpoints}[]), which indicates to stop just before that line of code is
run, and <code>continue</code>, which resumes execution. To remove a
display expression <code>undisplay</code> is used. If we give a display
number, just that display expression is removed.</p>

<p>We also used a new command <code>where</code>(see {backtrace}[]) to show
the callstack. In the above situation, starting from the bottom line we see
we called the <code>hanoi</code> method from line 28 of the file
<code>hanoi.rb</code> and the <code>hanoi</code> method called itself two
more times at line 5.</p>

<p>In the callstack we show a <em>current frame</em> mark, the frame number,
the method being called, the names of the parameters, the types those
parameters <em>currently</em> have and the file-line position. Remember
it&#39;s possible that when the program was called the parameters had
different types, since the types of variables can change dynamically. You
can alter the style of what to show in the trace (see {callstyle}[]).</p>

<p>Now let&#39;s move around the callstack.</p>

<pre>(byebug) undisplay
Clear all expressions? (y/n) y
(byebug) n_args
NameError Exception: undefined local variable or method `n_args&#39; for main:Object
(byebug) frame 2

[19, 28] in /path/to/hanoi.rb
   19:   begin
   20:     n = $ARGV[0].to_i
   21:   rescue ValueError
   22:     raise(&quot;** Expecting an integer, got: #{$ARGV[0]}&quot;)
   23:   end
   24: end
   25:
   26: fail(&#39;*** Number of disks should be between 1 and 100&#39;) if n &lt; 1 || n &gt; 100
   27:
=&gt; 28: hanoi(n, :a, :b, :c)
(byebug) n_args
0
(byebug) p n
3
(byebug) down 2

[1, 10] in /path/to/hanoi.rb
    1: #
    2: # Solves the classic Towers of Hanoi puzzle.
    3: #
    4: def hanoi(n, a, b, c)
=&gt;  5:   hanoi(n - 1, a, c, b) if n - 1 &gt; 0
    6:
    7:   puts &quot;Move disk #{a} to #{b}&quot;
    8:
    9:   hanoi(n - 1, c, b, a) if n - 1 &gt; 0
   10: end
(byebug) p n
2</pre>

<p>Notice in the above to get the value of variable <code>n</code> we had to
use a print command like <code>p n</code>. If we entered just
<code>n</code>, that would be taken to mean byebug command
<code>next</code>. In the current scope, variable <code>n_args</code> is
not defined. However I can change to the top-most frame by using the
<code>frame 2</code> command. Notice that inside frame #2, the value of
<code>n_args</code> can be shown. Also note that the value of variable
<code>n</code> is different.</p>

<h3 id="label-Attaching+to+a+running+program+with+byebug">Attaching to a running program with <code>byebug</code><span><a href="#label-Attaching+to+a+running+program+with+byebug">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In the previous sessions we&#39;ve been calling byebug right at the outset,
but there is another mode of operation you might use. If there&#39;s a lot
of code that needs to be run before the part you want to inspect, it might
not be efficient or convenient to run byebug from the outset.</p>

<p>In this section we&#39;ll show how to enter the code in the middle of your
program, while delving more into byebug&#39;s operation. We will also use
unit testing. Using unit tests will greatly reduce the amount of debugging
needed, while at the same time, will increase the quality of your program.</p>

<p>What we&#39;ll do is take the <code>triangle</code> code from the first
session and write a unit test for that. In a sense we did write a tiny test
for the program which was basically the last line where we printed the
value of <code>triangle(3)</code>. This test however wasn&#39;t automated:
the expectation is that someone would look at the output and verify that
what was printed is what was expected.</p>

<p>Before we can turn that into something that can be <code>required</code>,
we probably want to remove that output. However I like to keep in that line
so that when I look at the file, I have an example of how to run it.
Therefore we will conditionally run this line if that file is invoked
directly, but skip it if it is not. <em>NOTE: <code>byebug</code> resets
<code>$0</code> to try to make things like this work.</em></p>

<pre class="ruby"><span class="ruby-keyword">if</span> <span class="ruby-keyword">__FILE__</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">$PROGRAM_NAME</span>
  <span class="ruby-identifier">t</span> = <span class="ruby-identifier">triangle</span>(<span class="ruby-value">3</span>)
  <span class="ruby-identifier">puts</span> <span class="ruby-identifier">t</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Okay, we&#39;re now ready to write our unit test and we&#39;ll use the
<code>minitest</code> framework for that. Here&#39;s the test code, it
should be placed in the same directory as <code>triangle.rb</code>.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;minitest/autorun&#39;</span>
<span class="ruby-identifier">require_relative</span> <span class="ruby-string">&#39;triangle.rb&#39;</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">TestTriangle</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Minitest</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">test_basic</span>
    <span class="ruby-identifier">solutions</span> = []

    <span class="ruby-value">0</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-value">5</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">solutions</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">triangle</span>(<span class="ruby-identifier">i</span>) }

    <span class="ruby-identifier">assert_equal</span>([<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">6</span>, <span class="ruby-value">10</span>, <span class="ruby-value">15</span>], <span class="ruby-identifier">solutions</span>, <span class="ruby-string">&#39;First 5 triangle numbers&#39;</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Let&#39;s say we want to stop before the first statement in our test
method, we&#39;ll add the following:</p>

<pre class="ruby"><span class="ruby-operator">...</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">test_basic</span>
  <span class="ruby-identifier">byebug</span>
  <span class="ruby-identifier">solutions</span> = []
<span class="ruby-operator">...</span>
</pre>

<p>Now we run the program, requiring <code>byebug</code></p>

<pre>$ ruby -rbyebug test_triangle.rb
Run options: --seed 31679

# Running:


[2, 11] in test_triangle.rb
    2: require_relative &#39;triangle.rb&#39;
    3: 
    4: class TestTriangle &lt; Minitest::Test
    5:   def test_basic
    6:     byebug
=&gt;  7:     solutions = []
    8:
    9:     0.upto(5) { |i| solutions &lt;&lt; triangle(i) }
   10:
   11:     assert_equal([0, 1, 3, 6, 10, 15], solutions, &#39;First 5 triangle numbers&#39;)
(byebug)</pre>

<p>and we see that we are stopped at line 7 just before the initialization of
the list <code>solutions</code>.</p>

<p>Now let&#39;s see where we are…</p>

<pre>(byebug) set nofullpath
Displaying frame&#39;s full file names is off.
(byebug) bt
--&gt; #0  TestTriangle.test_basic at .../Proyectos/byebug/test_triangle.rb:7
    #1  block (3 levels) in Minitest::Test.run at .../lib/minitest/test.rb:108
    #2  Minitest::Test.capture_exceptions at .../lib/minitest/test.rb:206
    #3  block (2 levels) in Minitest::Test.run at .../lib/minitest/test.rb:105
    #4  Minitest::Test.time_it at .../lib/minitest/test.rb:258
    #5  block in Minitest::Test.run at .../lib/minitest/test.rb:104
    #6  #&lt;Class:Minitest::Runnable&gt;.on_signal(name#String, action#Proc) at .../minitest-5.5.0/lib/minitest.rb:321
    #7  Minitest::Test.with_info_handler(&amp;block#Proc) at .../lib/minitest/test.rb:278
    #8  Minitest::Test.run at .../lib/minitest/test.rb:103
    #9  #&lt;Class:Minitest&gt;.run_one_method(klass#Class, method_name#String) at .../minitest-5.5.0/lib/minitest.rb:768
    #10 #&lt;Class:Minitest::Runnable&gt;.run_one_method(klass#Class, method_name#String, reporter#Minitest::CompositeReporter) at .../minitest-5.5.0/lib/minitest.rb:295
    #11 block (2 levels) in #&lt;Class:Minitest::Runnable&gt;.run(reporter#Minitest::CompositeReporter, options#Hash) at .../minitest-5.5.0/lib/minitest.rb:289
    ͱ-- #12 Array.each at .../minitest-5.5.0/lib/minitest.rb:288
    #13 block in #&lt;Class:Minitest::Runnable&gt;.run(reporter#Minitest::CompositeReporter, options#Hash) at .../minitest-5.5.0/lib/minitest.rb:288
    #14 #&lt;Class:Minitest::Runnable&gt;.on_signal(name#String, action#Proc) at .../minitest-5.5.0/lib/minitest.rb:321
    #15 #&lt;Class:Minitest::Runnable&gt;.with_info_handler(reporter#Minitest::CompositeReporter, &amp;block#Proc) at .../minitest-5.5.0/lib/minitest.rb:308
    #16 #&lt;Class:Minitest::Runnable&gt;.run(reporter#Minitest::CompositeReporter, options#Hash) at .../minitest-5.5.0/lib/minitest.rb:287
    #17 block in #&lt;Class:Minitest&gt;.__run(reporter#Minitest::CompositeReporter, options#Hash) at .../minitest-5.5.0/lib/minitest.rb:150
    ͱ-- #18 Array.map at .../minitest-5.5.0/lib/minitest.rb:150
    #19 #&lt;Class:Minitest&gt;.__run(reporter#Minitest::CompositeReporter, options#Hash) at .../minitest-5.5.0/lib/minitest.rb:150
    #20 #&lt;Class:Minitest&gt;.run(args#Array) at .../minitest-5.5.0/lib/minitest.rb:127
    #21 block in #&lt;Class:Minitest&gt;.autorun at .../minitest-5.5.0/lib/minitest.rb:56
(byebug)</pre>

<p>We get the same result as if we had run byebug from the outset.</p>

<h3 id="label-Debugging+Oddities-3A+How+debugging+Ruby+may+be+different+from+other+languages">Debugging Oddities: How debugging Ruby may be different from other languages<span><a href="#label-Debugging+Oddities-3A+How+debugging+Ruby+may+be+different+from+other+languages">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you are used to debugging in other languages like C, C++, Perl, Java or
even Bash (see <a href="http://bashdb.sf.net">bashdb</a>), there may be a
number of things that seem or feel a little bit different and may confuse
you. A number of these things aren&#39;t oddities of the debugger per se
but differences in how Ruby works compared to those other languages.
Because Ruby works a little differently from those other languages, writing
a debugger has to also be a little different as well if it is to be useful.
In this respect, using <a href="Byebug.html">Byebug</a> may help you
understand Ruby better.</p>

<p>We&#39;ve already seen one such difference: the fact that we stop on method
definitions or <code>def</code>&#39;s and that is because these are in fact
executable statements. In other compiled languages this would not happen
because that&#39;s already been done when you compile the program (or in
Perl when it scans in the program). In this section we&#39;ll consider some
other things that might throw off new users to Ruby who are familiar with
other languages and debugging in them.</p>
<ul><li>
<p>Bouncing Around in Blocks (iterators)</p>
</li><li>
<p>No Parameter Values in a Call Stack</p>
</li><li>
<p>Lines You Can Stop At</p>
</li></ul>

<h4 id="label-Bouncing+Around+in+Blocks+-28iterators-29">Bouncing Around in Blocks (iterators)<span><a href="#label-Bouncing+Around+in+Blocks+-28iterators-29">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>When debugging languages with coroutines like Python and Ruby, a method
call may not necessarily go to the first statement after the method header.
It&#39;s possible that the call will continue after a <code>yield</code>
statement from a prior call.</p>

<pre class="ruby"><span class="ruby-comment">#</span>
<span class="ruby-comment"># Enumerator for primes</span>
<span class="ruby-comment">#</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">SievePrime</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>
    <span class="ruby-ivar">@odd_primes</span> = []
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">next_prime</span>
    <span class="ruby-identifier">candidate</span> = <span class="ruby-value">2</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-identifier">candidate</span>
    <span class="ruby-identifier">not_prime</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">candidate</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

    <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
      <span class="ruby-ivar">@odd_primes</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">not_prime</span> = (<span class="ruby-value">0</span> <span class="ruby-operator">==</span> (<span class="ruby-identifier">candidate</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">p</span>))
        <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">not_prime</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">unless</span> <span class="ruby-identifier">not_prime</span>
        <span class="ruby-ivar">@odd_primes</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">candidate</span>
        <span class="ruby-keyword">yield</span> <span class="ruby-identifier">candidate</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">candidate</span> <span class="ruby-operator">+=</span> <span class="ruby-value">2</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">SievePrime</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">next_prime</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">prime</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-identifier">prime</span>
  <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">prime</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">10</span>
<span class="ruby-keyword">end</span>
</pre>

<pre>$ byebug primes.rb
[1, 10] in /path/to/primes.rb
    1: #
    2: # Enumerator for primes
    3: #
=&gt;  4: class SievePrime
    5:   def initialize
    6:     @odd_primes = []
    7:   end
    8:
    9:   def self.next_prime(&amp;block)
   10:    candidate = 2
(byebug) set tracing
line tracing is on.
(byebug) set basename
basename in on.
(byebug) step 9
Tracing: primes.rb:5   def initialize
Tracing: primes.rb:9   def next_prime
Tracing: primes.rb:31 SievePrime.new.next_prime do |prime|
Tracing: primes.rb:6     @odd_primes = []
Tracing: primes.rb:10     candidate = 2
Tracing: primes.rb:11     yield candidate
Tracing: primes.rb:32   puts prime
2
Tracing: primes.rb:33   break if prime &gt; 10
Tracing: primes.rb:12     not_prime = false

[7, 16] in /path/to/primes.rb
    7:   end
    8:
    9:   def next_prime
   10:     candidate = 2
   11:     yield candidate
=&gt; 12:     not_prime = false
   13:     candidate += 1
   14:
   15:     loop do
   16:       @odd_primes.each do |p|
   17:         not_prime = (0 == (candidate % p))
(byebug)</pre>

<p>The loop between lines 31-34 gets interleaved between those of
<code>SievePrime#next_prime</code>, lines 9-28 above.</p>

<h4 id="label-No+Parameter+Values+in+a+Call+Stack">No Parameter Values in a Call Stack<span><a href="#label-No+Parameter+Values+in+a+Call+Stack">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>In traditional debuggers, in a call stack you can generally see the names
of the parameters and the values that were passed in.</p>

<p>Ruby is a very dynamic language and it tries to be efficient within the
confines of the language definition. Values generally aren&#39;t taken out
of a variable or expression and pushed onto a stack. Instead a new scope is
created and the parameters are given initial values. Parameter passing is
by <em>reference</em> not by <em>value</em> as it is say Algol, C, or Perl.
During the execution of a method, parameter values can change (and often
do). In fact even the <em>class</em> of the object can change.</p>

<p>So at present, the name of the parameter is shown. The call-style setting
({callstyle}[]) can be used to set whether the name is shown or the name
and the <em>current</em> class of the object.</p>

<h4 id="label-Lines+You+Can+Stop+At">Lines You Can Stop At<span><a href="#label-Lines+You+Can+Stop+At">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Consider the following little Ruby program.</p>

<pre class="ruby"><span class="ruby-string">&#39;Yes it does&#39;</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/
(Yes) \s+
it  \s+
does
/ix</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">$1</span>
</pre>

<p>The stopping points that Ruby records are the last two lines, lines 5 and
6.</p>

<p>Inside <code>byebug</code> you can get a list of stoppable lines for a file
using the <code>info file</code> command.</p>

<h3 id="label-Threading+support">Threading support<span><a href="#label-Threading+support">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Byebug.html">Byebug</a> supports debugging Ruby programs making
use of multiple threads.</p>

<p>Let&#39;s consider the following sample program:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Company</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">task</span>)
    <span class="ruby-ivar">@tasks</span>, <span class="ruby-ivar">@results</span> = <span class="ruby-constant">Queue</span>.<span class="ruby-identifier">new</span>, <span class="ruby-constant">Queue</span>.<span class="ruby-identifier">new</span>

    <span class="ruby-ivar">@tasks</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">task</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">run</span>
    <span class="ruby-identifier">manager</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">manager_routine</span> }
    <span class="ruby-identifier">employee</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">employee_routine</span> }

    <span class="ruby-identifier">sleep</span> <span class="ruby-value">6</span>

    <span class="ruby-identifier">go_home</span>(<span class="ruby-identifier">manager</span>)
    <span class="ruby-identifier">go_home</span>(<span class="ruby-identifier">employee</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># An employee doing his thing</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">employee_routine</span>
    <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
      <span class="ruby-keyword">if</span> <span class="ruby-ivar">@tasks</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-identifier">have_a_break</span>(<span class="ruby-value">0.1</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">work_hard</span>(<span class="ruby-ivar">@tasks</span>.<span class="ruby-identifier">pop</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># A manager doing his thing</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">manager_routine</span>
    <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
      <span class="ruby-keyword">if</span> <span class="ruby-ivar">@results</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-identifier">have_a_break</span>(<span class="ruby-value">1</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">show_off</span>(<span class="ruby-ivar">@results</span>.<span class="ruby-identifier">pop</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">show_off</span>(<span class="ruby-identifier">result</span>)
    <span class="ruby-identifier">puts</span> <span class="ruby-identifier">result</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">work_hard</span>(<span class="ruby-identifier">task</span>)
    <span class="ruby-identifier">task</span> <span class="ruby-operator">**</span> <span class="ruby-identifier">task</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">have_a_break</span>(<span class="ruby-identifier">amount</span>)
    <span class="ruby-identifier">sleep</span> <span class="ruby-identifier">amount</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">go_home</span>(<span class="ruby-identifier">person</span>)
    <span class="ruby-identifier">person</span>.<span class="ruby-identifier">kill</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">Company</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">10</span>).<span class="ruby-identifier">run</span>
</pre>

<p>The <code>Company</code> class simulates a real company. The company has a
manager and an employee represented by 2 threads: they work concurrently to
achieve the company&#39;s targets.</p>
<ul><li>
<p>The employee looks for tasks to complete. If there are tasks, it works hard
to complete them. Otherwise he has a quick break.</p>
</li></ul>

<pre class="ruby"><span class="ruby-comment">#</span>
<span class="ruby-comment"># An employee doing his thing</span>
<span class="ruby-comment">#</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">employee_routine</span>
  <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@tasks</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">have_a_break</span>(<span class="ruby-value">0.1</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">work_hard</span>(<span class="ruby-ivar">@tasks</span>.<span class="ruby-identifier">pop</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
<ul><li>
<p>The manager, on the other hand, sits there all day and sporadically checks
whether there are any results to show off.</p>
</li></ul>

<pre class="ruby"><span class="ruby-comment">#</span>
<span class="ruby-comment"># A manager doing his thing</span>
<span class="ruby-comment">#</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">manager_routine</span>
  <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@results</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">have_a_break</span>(<span class="ruby-value">1</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">show_off</span>(<span class="ruby-ivar">@results</span>.<span class="ruby-identifier">pop</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>We do some abstractions easily readable in the code. Our tasks are just a
<code>Queue</code> of numbers, so are our results. What our employer does
when he works is some calculation with those numbers and what the manager
does with the results is printing them to the screen.</p>

<p>We instantiate a new company with an initial task and after running that
company we expect the result to be printed in the screen, but it is not.
Lets debug our sample program:</p>

<pre>[1, 10] in /path/to/company.rb
=&gt;  1: class Company
    2:   def initialize(task)
    3:     @tasks, @results = Queue.new, Queue.new
    4:
    5:     @tasks.push(task)
    6:   end
    7:
    8:   def run
    9:     manager = Thread.new { manager_routine }
   10:     employee = Thread.new { employee_routine }
(byebug) l

[11, 20] in /path/to/company.rb
   11:
   12:     sleep 6
   13:
   14:     go_home(manager)
   15:     go_home(employee)
   16:   end
   17:
   18:   #
   19:   # An employee doing his thing
   20:   #

(byebug) c 12
Stopped by breakpoint 1 at /path/to/company.rb:12

[7, 16] in /path/to/company.rb
    7:
    8:   def run
    9:     manager = Thread.new { manager_routine }
   10:     employee = Thread.new { employee_routine }
   11:
=&gt; 12:     sleep 6
   13:
   14:     go_home(manager)
   15:     go_home(employee)
   16:   end
(byebug) th l
+ 1 #&lt;Thread:0x0000000192f328 run&gt; /path/to/company.rb:12
  2 #&lt;Thread:0x00000001ff9870@/path/to/company.rb:9 sleep&gt;
  3 #&lt;Thread:0x00000001ff80d8@/path/to/company.rb:10 sleep&gt;</pre>

<p>What we have done here is just start our program and advance to the point
inmediately after our <code>employee</code> and <code>manager</code>
threads have been created. We can then check that the threads are there
using the <code>thread list</code> command. Now we want to debug both of
this threads to check what&#39;s happening and look for the bug.</p>

<pre>(byebug) th switch 3

[5, 14] in /path/to/company.rb
    5:     @tasks.push(task)
    6:   end
    7:
    8:   def run
    9:     manager = Thread.new { manager_routine }
=&gt; 10:     employee = Thread.new { employee_routine }
   11:
   12:     sleep 6
   13:
   14:     go_home(manager)
(byebug) th stop 1; th stop 2
$ 1 #&lt;Thread:0x00000001307310 sleep&gt; /path/to/company.rb:12
$ 2 #&lt;Thread:0x000000018bf438 sleep&gt; /path/to/company.rb:9
(byebug) th l
$ 1 #&lt;Thread:0x00000001307310 sleep&gt; /path/to/company.rb:12
$ 2 #&lt;Thread:0x000000018bf438@/path/to/company.rb:9 sleep&gt; /path/to/company.rb:55
+ 3 #&lt;Thread:0x00000001ff80d8@/path/to/company.rb:10 sleep&gt; /path/to/company.rb:10</pre>

<p>We have started by debugging the <code>employee</code> thread. To do that,
we switch to that thread using the <code>thread switch 3</code> command.
The thread number is the one specified by <code>thread list</code>, we know
this is our worker thread because <code>thread list</code> specifies where
the thread is defined in the file (and its current position if the thread
is currently running, although this is only available since Ruby 2.2.1).</p>

<p>After that we stopped the main thread and the worker thread, using the
command <code>thread stop</code>. We do this because we want to focus on
the employee thread first and don&#39;t want the program to finish while we
are debugging. Notice that stopped threads are marked with the “$” symbol
whereas the current thread is marked with the “+” symbol.</p>

<pre>(byebug) s

[17, 26] in /path/to/company.rb
   17:
   18:   #
   19:   # An employee doing his thing
   20:   #
   21:   def employee_routine
=&gt; 22:     loop do
   23:       if @tasks.empty?
   24:         have_a_break(0.1)
   25:       else
   26:         work_hard(@tasks.pop)
(byebug) s

[18, 27] in /path/to/company.rb
   18:   #
   19:   # An employee doing his thing
   20:   #
   21:   def employee_routine
   22:     loop do
=&gt; 23:       if @tasks.empty?
   24:         have_a_break(0.1)
   25:       else
   26:         work_hard(@tasks.pop)
   27:       end
(byebug) n

[21, 30] in /path/to/company.rb
   21:   def employee_routine
   22:     loop do
   23:       if @tasks.empty?
   24:         have_a_break(0.1)
   25:       else
=&gt; 26:         work_hard(@tasks.pop)
   27:       end
   28:     end
   29:   end
   30:
(byebug) s

[49, 58] in /path/to/company.rb
   49:   def show_off(result)
   50:     puts result
   51:   end
   52:
   53:   def work_hard(task)
=&gt; 54:     task ** task
   55:   end
   56:
   57:   def have_a_break(amount)
   58:     sleep amount
(byebug) s

[21, 30] in /path/to/company.rb
   21:   #
   22:   # An employee doing his thing
   23:   #
   24:   def employee_routine
   25:     loop do
=&gt; 26:       if @tasks.empty?
   27:         have_a_break(0.1)
   28:       else
   29:         work_hard(@tasks.pop)
   30:       end
(byebug) n

[22, 31] in /path/to/company.rb
   22:   # An employee doing his thing
   23:   #
   24:   def employee_routine
   25:     loop do
   26:       if @tasks.empty?
=&gt; 27:         have_a_break(0.1)
   28:       else
   29:         work_hard(@tasks.pop)
   30:       end
   31:     end
(byebug) n

[21, 30] in /path/to/company.rb
   21:   #
   22:   # An employee doing his thing
   23:   #
   24:   def employee_routine
   25:     loop do
=&gt; 26:       if @tasks.empty?
   27:         have_a_break(0.1)
   28:       else
   29:         work_hard(@tasks.pop)
   30:       end
   31:     end
(byebug)</pre>

<p>Everything seems fine in this thread. The first iteration the employee will
do his job, and after that it will just check for new tasks and sleep.
Let&#39;s debug the manager task now:</p>

<pre>(byebug) th resume 2
  2 #&lt;Thread:0x000000019892d8@/path/to/company.rb:12 run&gt; /path/to/company.rb:12
(byebug) th switch 2
  2 #&lt;Thread:0x000000019892d8@/path/to/company.rb:12 sleep&gt; /path/to/company.rb:12

[7, 16] in /path/to/company.rb
    7:
    8:   #
    9:   # A CEO running his company
   10:   #
   11:   def run
=&gt; 12:     manager = Thread.new { manager_routine }
   13:     employee = Thread.new { employee_routine }
   14:
   15:     sleep 6
   16:
(byebug)</pre>

<p>We used the command <code>thread resume</code> to restart the manager&#39;s
thread and then switch to it using <code>thread switch</code>. It&#39;s
important to resume the thread&#39;s execution before switching to it,
otherwise we&#39;ll get a hang because we cannot run a sleeping thread.</p>

<p>Now we can investigate the problem in the employer&#39;s side:</p>

<p>“bash (byebug) s [30, 39] in /path/to/company.rb  30:  31: #  32: # A
manager doing his thing  33: #  34: def manager_routine =&gt; 35: loop do 
36: if @results.empty?  37: have_a_break(1)  38: else  39:
show_off(@results.pop) (byebug) s</p>

<p>[31, 40] in /path/to/company.rb  31: #  32: # A manager doing his thing 
33: #  34: def manager_routine  35: loop do =&gt; 36: if @results.empty? 
37: have_a_break(1)  38: else  39: show_off(@results.pop)  40: end (byebug)
n</p>

<p>[32, 41] in /path/to/company.rb  32: # A manager doing his thing  33: # 
34: def manager_routine  35: loop do  36: if @results.empty? =&gt; 37:
have_a_break(1)  38: else  39: show_off(@results.pop)  40: end  41: end
(byebug) n</p>

<p>[31, 40] in /path/to/company.rb  31: #  32: # A manager doing his thing 
33: #  34: def manager_routine  35: loop do =&gt; 36: if @results.empty? 
37: have_a_break(1)  38: else  39: show_off(@results.pop)  40: end (byebug)
“</p>

<p>Now we can see the problem, the <code>@results</code> variable is always
empty! The employee forgot to leave the results in his manager&#39;s deck.
We fix it by changing the line</p>

<pre class="ruby"><span class="ruby-identifier">work_hard</span>(<span class="ruby-ivar">@tasks</span>.<span class="ruby-identifier">pop</span>)
</pre>

<p>in the <code>employee_routine</code> method with the line</p>

<pre class="ruby"><span class="ruby-ivar">@results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">work_hard</span>(<span class="ruby-ivar">@tasks</span>.<span class="ruby-identifier">pop</span>)
</pre>

<p>To be continued… * More complex examples with objects, pretty printing and
irb. * Line tracing and non-interactive tracing. * Post-mortem debugging.</p>

<h2 id="label-Getting+in+-26+out">Getting in &amp; out<span><a href="#label-Getting+in+-26+out">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-Starting+byebug">Starting byebug<span><a href="#label-Starting+byebug">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>There is a wrapper script called <code>byebug</code> which basically
<code>require</code>&#39;s the gem then loads <code>byebug</code> before
its argument (the program to be debugged) is started. If you don&#39;t need
to pass dash options to your program, which might be confused with byebug
options, then you don&#39;t need to add the <code>--</code>. To get a brief
list of options and descriptions, use the <code>--help</code> option.</p>

<pre>$ byebug --help

  byebug 3.5.1

  Usage: byebug [options] &lt;script.rb&gt; -- &lt;script.rb parameters&gt;

    -d, --debug               Set $DEBUG=true
    -I, --include list        Add to paths to $LOAD_PATH
    -m, --[no-]post-mortem    Use post-mortem mode
    -q, --[no-]quit           Quit when script finishes
    -x, --[no-]rc             Run byebug initialization file
    -s, --[no-]stop           Stop when script is loaded
    -r, --require file        Require library before script
    -R, --remote [host:]port  Remote debug [host:]port
    -t, --[no-]trace          Turn on line tracing
    -v, --version             Print program version
    -h, --help                Display this message</pre>

<p>Many options appear as a long option name, such as <code>--help</code> and
a short one letter option name, such as <code>-h</code>. The list of
options is detailed below:</p>

<h4 id="label-h+-7C+--help">-h | –help<span><a href="#label-h+-7C+--help">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>It causes <code>byebug</code> to print some basic help and exit</p>

<h4 id="label-v+-7C+--version">-v | –version<span><a href="#label-v+-7C+--version">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>It causes <code>byebug</code> to print its version number and exit.</p>

<h4 id="label-d+-7C+--debug">-d | –debug<span><a href="#label-d+-7C+--debug">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Sets <code>$DEBUG</code> to <code>true</code>. Compatible with Ruby&#39;s
flag.</p>

<h4 id="label-I+-7C+--include+-3Cpath-3E">-I | –include &lt;path&gt;<span><a href="#label-I+-7C+--include+-3Cpath-3E">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Adds <code>path</code> to load path. <code>path</code> can be a single path
or a colon separated path list.</p>

<h4 id="label-m+-7C+--post-mortem">-m | –post-mortem<span><a href="#label-m+-7C+--post-mortem">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>If your program raises an exception that isn&#39;t caught you can enter
byebug for inspection of what went wrong. You may also want to use this
option in conjunction with <code>--no-stop</code>. See also {Post-Mortem
Debugging}[].</p>

<h4 id="label--no-quit">–no-quit<span><a href="#label--no-quit">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Keep inside <code>byebug</code> after your program terminates normally.</p>

<h4 id="label--no-stop">–no-stop<span><a href="#label--no-stop">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Normally <code>byebug</code> stops before executing the first statement. If
instead you want it to start running initially and perhaps break it later
in the execution, use this option.</p>

<h4 id="label-r+-7C+--require+-3Clib-3E">-r | –require &lt;lib&gt;<span><a href="#label-r+-7C+--require+-3Clib-3E">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Requires the library before executing the script. This option is compatible
with Ruby&#39;s.</p>

<h4 id="label-t+-7C+--trace">-t | –trace<span><a href="#label-t+-7C+--trace">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Turns on line tracing. Running <code>byebug --trace
&lt;rubyscript&gt;.rb</code> is pretty much like running <code>ruby
-rtracer &lt;rubyscript&gt;.rb</code>. If all you want to do however is get
a line trace, <code>tracer</code> is most likely faster than
<code>byebug</code>.</p>

<pre>$ time byebug --trace --no-stop hanoi.rb &gt; /dev/null

real    0m0.743s
user    0m0.668s
sys     0m0.068s
$ time ruby -rtracer hanoi.rb &gt; /dev/null

real    0m0.077s
user    0m0.072s
sys     0m0.004s</pre>

<h3 id="label-Byebug+default+options"><a href="Byebug.html">Byebug</a> default options<span><a href="#label-Byebug+default+options">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Byebug.html">Byebug</a> has many command-line options,; it seems
that some people want to set them differently from the defaults. For
example, some people may want <code>--no-quit</code> to be the default
behavior. One could write a wrapper script or set a shell alias to handle
this.</p>

<h3 id="label-Command+Files">Command Files<span><a href="#label-Command+Files">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>A command file is a file of lines that are <code>byebug</code> commands.
Comments (lines starting with <code>#</code>) may also be included. An
empty line in a command file does nothing; it does not mean to repeat the
last command, as it would from the terminal.</p>

<p>When you start <code>byebug</code>, it automatically executes commands from
its <em>init file</em>, called <code>.byebugrc</code>. During startup,
<code>byebug</code> does the following:</p>
<ul><li>
<p><strong>Processes command line options and operands.</strong> Reads the
init file in your current directory, if any, and then checks your home
directory. The home directory is the directory named in the
<code>$HOME</code> or <code>$HOMEPATH</code> environment variable. Thus,
you can have more than one init file, one generic in your home directory,
and another, specific to the program you are debugging, in the directory
where you invoke <code>byebug</code>.</p>
</li></ul>

<p>You can also request the execution of a command file with the
<code>source</code> command (see {Source}[]).</p>

<h3 id="label-Quitting+byebug">Quitting byebug<span><a href="#label-Quitting+byebug">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>To exit <code>byebug</code>, use the <code>quit</code> command (abbreviated
<code>q</code> and aliased <code>exit</code>). Normally if you are in an
interactive session, this command will prompt to ask if you really want to
quit. If you don&#39;t want any questions asked, enter <code>quit
unconditionally</code> (abbreviated <code>q!</code>). Another way to
terminate byebug is to use the <code>kill</code> command. This does the
more forceful <code>kill -9</code>. It can be used in cases where
<code>quit</code> doesn&#39;t work (I haven&#39;t seen those yet).</p>

<h3 id="label-Calling+byebug+from+inside+your+program">Calling byebug from inside your program<span><a href="#label-Calling+byebug+from+inside+your+program">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Running a program from byebug adds a bit of overhead and slows it down a
little. Furthermore, by necessity, debuggers change the operation of the
program they are debugging. And this can lead to unexpected and unwanted
differences. It has happened so often that the term <a
href="http://en.wikipedia.org/wiki/Heisenbug">Heisenbugs</a> was coined to
describe the situation where using a debugger (among other possibilities)
changes the behavior of the program so that the bug doesn&#39;t manifest
itself anymore.</p>

<p>There is another way to get into byebug which adds no overhead or slowdown
until you reach the point at which you want to start debugging. However
here you must change the script and make an explicit call to byebug.
Because byebug isn&#39;t involved before the first call, there is no
overhead and the script will run at the same speed as if there were no
byebug.</p>

<p>To enter byebug this way, just drop <code>byebug</code> in whichever line
you want to start debugging at. You also have to require byebug somehow. If
using bundler, it will take care of that for you, otherwise you can use the
ruby <code>-r</code> flag or add <code>require &#39;byebug&#39;</code> in
the line previous to the <code>byebug</code> call.</p>

<p>If speed is crucial, you may want to start and stop this around certain
sections of code, using <code>Byebug.start</code> and
<code>Byebug.stop</code>. Alternatively, instead of issuing an explicit
<code>Byebug.stop</code> you can add a block to the
<code>Byebug.start</code> and debugging is turned on for that block. If the
block of code raises an uncaught exception that would cause the block to
terminate, the <code>stop</code> will occur. See {Byebug.start with a
block}[].</p>

<p>When <code>byebug</code>is run, <code>.byebugrc</code> is read.</p>

<p>You may want to enter byebug at several points in the program where there
is a problem you want to investigate. And since <code>byebug</code> is just
a method call it&#39;s possible to enclose it in a conditional expression,
for example</p>

<pre class="ruby"><span class="ruby-identifier">byebug</span> <span class="ruby-keyword">if</span> <span class="ruby-string">&#39;bar&#39;</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">foo</span> <span class="ruby-keyword">and</span> <span class="ruby-value">20</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">iter_count</span>
</pre>

<h3 id="label-Restarting+Byebug">Restarting <a href="Byebug.html">Byebug</a><span><a href="#label-Restarting+Byebug">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can restart the program using <code>restart [program args]</code>. This
is a re-exec - all byebug state is lost. If command arguments are passed,
those are used. Otherwise program arguments from the last invocation are
used.</p>

<p>You won&#39;t be able to restart your program in all cases. First, the
program should have been invoked at the outset rather than having been
called from inside your program or invoked as a result of post-mortem
handling.</p>

<p>Also, since this relies on the OS <code>exec</code> call, this command is
available only if your OS supports <code>exec</code>.</p>

<h2 id="label-Debugging+remote+programs">Debugging remote programs<span><a href="#label-Debugging+remote+programs">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>It is possible to set up debugging so that you can issue byebug commands
from outside the process running the Ruby code. In fact, you might even be
on a different computer than the one running the Ruby program.</p>

<p>To setup remote debugging, drop the following somewhere before the point in
the program that you want to debug (In Rails, the
<code>config/environments/development.rb</code> could be a good candidate).</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;byebug&#39;</span>
  <span class="ruby-constant">Byebug</span>.<span class="ruby-identifier">wait_connection</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-constant">Byebug</span>.<span class="ruby-identifier">start_server</span>(<span class="ruby-string">&#39;localhost&#39;</span>, <span class="ruby-operator">&lt;</span><span class="ruby-identifier">port</span><span class="ruby-operator">&gt;</span>)
</pre>

<p>Once this piece gets executed, you can connect to the remote debugger from
your local machine, by running: <code>byebug -R
localhost:&lt;port&gt;</code>.</p>

<p>Next, at a place of program execution which gets run just before the code
you want to debug, add a call to <code>byebug</code> as was done without
remote execution:</p>

<pre class="ruby"><span class="ruby-comment"># work, work, work...</span>
   <span class="ruby-identifier">byebug</span>
   <span class="ruby-identifier">some</span> <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">code</span>  <span class="ruby-comment"># byebug will stop before this line is run</span>
</pre>

<h2 id="label-Byebug+Command+Reference"><a href="Byebug.html">Byebug</a> Command Reference<span><a href="#label-Byebug+Command+Reference">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-Command+Syntax">Command Syntax<span><a href="#label-Command+Syntax">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Usually a command is put on a single line. There is no limit on how long it
can be. It starts with a command name, which is followed by arguments whose
meaning depends on the command name. For example, the command
<code>step</code> accepts an argument which is the number of times to step,
as in <code>step 5</code>. You can also use the <code>step</code> command
with no arguments. Some commands do not allow any arguments.</p>

<p>Multiple commands can be put on a line by separating each with a semicolon
<code>;</code>. You can disable the meaning of a semicolon to separate
commands by escaping it with a backslash.</p>

<p>For example, if you have {autoeval}[] set, which is the default, you might
want to enter the following code to compute the 5th Fibonacci number.</p>

<pre>(byebug) fib1=0; fib2=1; 5.times {|temp| temp=fib1; fib1=fib2; fib2 += temp }
0
1
SyntaxError Exception: /home/davidr/Proyectos/sample_app/trace.rb:1: syntax
error, unexpected end-of-input, expecting &#39;}&#39;
 5.times { |temp| temp=fib1
                           ^
nil
1
SyntaxError Exception: /home/davidr/Proyectos/sample_app/trace.rb:1: syntax
error, unexpected tSTRING_DEND, expecting end-of-input
 fib2 += temp }
               ^
nil
(byebug) fib1=0\; fib2=1\; 5.times {|temp| temp=fib1\; fib1=fib2\; fib2 += temp }
5
(byebug) fib2
8</pre>

<p>You might also consider using the {irb}[] or {pry}[] commands and then you
won&#39;t have to escape semicolons.</p>

<p>A blank line as input (typing just <code>&lt;RET&gt;</code>) means to
repeat the previous command.</p>

<p><a href="Byebug.html">Byebug</a> uses readline, which handles line editing
and retrieval of previous commands. Up arrow, for example, moves to the
previous byebug command; down arrow moves to the next more recent command
(provided you are not already at the last command). Command history is
saved in file <code>.byebug_hist</code>. A limit is put on the history
size. You can see this with the <code>show history size</code> command. See
{history}[] for history parameters.</p>

<h3 id="label-Command+Output">Command Output<span><a href="#label-Command+Output">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In the command-line interface, when <code>byebug</code> is waiting for
input it presents a prompt of the form <code>(byebug)</code>. If the
program has terminated normally the prompt will be
<code>(byebug:ctrl)</code> and in post-mortem debugging it will be
<code>(byebug:post-mortem)</code>.</p>

<p>Whenever <code>byebug</code> gives an error message such as for an invalid
command or an invalid location position, it will generally preface the
message with <code>***</code>.</p>

<h3 id="label-Command+Help">Command Help<span><a href="#label-Command+Help">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Once inside <code>byebug</code> you can always ask it for information on
its commands using the <code>help</code> command. You can use
<code>help</code> (abbreviated <code>h</code>) with no arguments to display
a short list of named classes of commands</p>

<pre>(byebug) help
Type &quot;help &lt;command-name&gt;&quot; for help on a specific command

Available commands:
backtrace  delete   enable  help  method  ps        save       step       where
break      disable  eval    info  next    putl      set        trace      catch
display    exit     irb     p     quit    show      undisplay  condition  down
finish     kill     pp      skip  up      continue  edit       frame      list
pry        restart  source  var</pre>

<p>With a command name as <code>help</code> argument, <code>byebug</code>
displays short information on how to use that command.</p>

<pre>(byebug) help list
l[ist]    list forward
l[ist] -  list backward
l[ist] =  list current line
l[ist] nn-mm  list given lines
* NOTE - to turn on autolist, use &#39;set autolist&#39;
(byebug)</pre>

<p>A number of commands, namely <code>info</code>, <code>set</code>,
<code>show</code>, <code>enable</code> and <code>disable</code>, have many
sub-parameters or <em>subcommands</em>. When you ask for help for one of
these commands, you will get help for all of the subcommands that command
offers. Sometimes you may want help only on a subcommand and to do this
just follow the command with its subcommand name. For example, <code>help
info breakpoints</code>will just give help about the <code>info
breakpoints</code> command. Furthermore it will give longer help than the
summary information that appears when you ask for help. You don&#39;t need
to list the full subcommand name, just enough of the letters to make that
subcommand distinct from others will do. For example, <code>help info
b</code> is the same as <code>help info breakpoints</code>.</p>

<p>Some examples follow.</p>

<pre>(byebug) help info
info[ subcommand]

Generic command for showing things about the program being debugged.

--
List of &quot;info&quot; subcommands:
--
info args        -- Argument variables of current stack frame
info breakpoints -- Status of user-settable breakpoints
info catch       -- Exceptions that can be caught in the current stack frame
info display     -- Expressions to display when program stops
info file        -- Info about a particular file read in
info files       -- File names and timestamps of files read in
info line        -- Line number and filename of current position in source file
info program     -- Execution status of the program</pre>

<pre>(byebug) help info breakpoints
Status of user-settable breakpoints.
Without argument, list info about all breakpoints.
With an integer argument, list info on that breakpoint.</pre>

<pre>(byebug) help info b
Status of user-settable breakpoints.
Without argument, list info about all breakpoints.
With an integer argument, list info on that breakpoint.</pre>

<h3 id="label-Control+Commands-3A+quit-2C+restart-2C+source">Control Commands: quit, restart, source<span><a href="#label-Control+Commands-3A+quit-2C+restart-2C+source">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-Quit">Quit<span><a href="#label-Quit">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>To exit <code>byebug</code>, type <code>quit</code> (abbreviated
<code>q</code> and aliased <code>exit</code>). Normally if you are in an
interactive session, this command will prompt you to confirm you really
want to quit. If you don&#39;t want any questions asked, enter <code>quit
unconditionally</code> (abbreviated <code>q!</code>).</p>

<h4 id="label-Restart">Restart<span><a href="#label-Restart">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>To restart the program, use the <code>restart|r</code> command. This is a
re-exec - all <code>byebug</code> state is lost. If command arguments are
passed, those are used. Otherwise program arguments from the last
invocation are used.</p>

<p>You won&#39;t be able to restart your program in all cases. First, the
program should have been invoked at the outset rather than having been
called from inside your program or invoked as a result of post-mortem
handling.</p>

<h4 id="label-Source">Source<span><a href="#label-Source">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>You can run <code>byebug</code> commands inside a file, using the command
<code>source &lt;file&gt;</code>. The lines in a command file are executed
sequentially. They are not printed as they are executed. If there is an
error, execution proceeds to the next command in the file. For information
about command files that get run automatically on startup see {Command
Files}[].</p>

<h3 id="label-Display+Commands-3A+display-2C+undisplay">Display Commands: display, undisplay<span><a href="#label-Display+Commands-3A+display-2C+undisplay">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-Display">Display<span><a href="#label-Display">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>If you find that you want to print the value of an expression frequently
(to see how it changes), you might want to add it to the <em>automatic
display list</em>* so that <code>byebug</code> evaluates it each time your
program stops or after a line is printed if line tracing is enabled. Each
expression added to the list is given a number to identify it; to remove an
expression from the list, you specify that number. The automatic display
looks like this:</p>

<pre>(byebug) display n
1: n = 3</pre>

<p>This display shows item numbers, expressions and their current values. If
the expression is undefined or illegal the expression will be printed but
no value will appear.</p>

<pre>(byebug) display undefined_variable
2: undefined_variable =
(byebug) display 1/0
3: 1/0 =</pre>

<p>If you use <code>display</code> with no argument, <code>byebug</code> will
display the current values of the expressions in the list, just as it is
done when your program stops. Using <code>info display</code> has the same
effect.</p>

<h4 id="label-Undisplay">Undisplay<span><a href="#label-Undisplay">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>To remove an item from the list, use <code>undisplay</code> followed by the
number identifying the expression you want to remove.
<code>undisplay</code> does not repeat if you press
<code>&lt;RET&gt;</code>after using it (otherwise you would just get the
error <em>No display number n</em>)</p>

<p>You can also temporarily disable or enable display expressions, so that the
will not be printed but they won&#39;t be forgotten either, so you can
toggle them again later. To do that, use <code>disable display</code> or
<code>enable display</code> followed by the expression number.</p>

<h3 id="label-Print+Commands">Print Commands<span><a href="#label-Print+Commands">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>One way to examine and change data in your script is with the
<code>eval</code> command (abbreviated <code>p</code>). <code>byebug</code>
by default evaluates any input that is not recognized as a command, so in
most situations <code>eval</code> is not necessary and <code>byebug</code>
will work like a REPL. One case where it&#39;s necessary could be when
trying to print a variable called <code>n</code>. In this case, you have no
choice because typing just <code>n</code> will execute
<code>byebug</code>&#39;s command <code>next</code>.</p>

<p>A similar command to <code>eval|p</code> is <code>pp</code> which tries to
pretty print the result.</p>

<p>If the value you want to print is an array, sometimes a columnized list
looks nicer. Use <code>putl</code> for that. Notice however that entries
are sorted to run down first rather than across. If the value is not an
array <code>putl</code> will just call pretty-print.</p>

<p>Sometimes you may want to print the array not only columnized, but sorted
as well. The list of byebug help commands appears this way, and so does the
output of the <code>method</code> commands. Use <code>ps</code> for that.
If the value is not an array <code>ps</code> will just call pretty-print.</p>

<pre>(byebug) Kernel.instance_methods
[:nil?, :===, :=~, :!~, :eql?, :hash, :&lt;=&gt;, :class, :singleton_class, :clone,
:dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze,
:frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods,
:private_methods, :public_methods, :instance_variables, :instance_variable_get,
:instance_variable_set, :instance_variable_defined?, :remove_instance_variable,
:instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?,
:extend, :display, :method, :public_method, :define_singleton_method,
:object_id, :to_enum, :enum_for, :gem, :pretty_inspect, :byebug]
(byebug) p Kernel.instance_methods
[:nil?, :===, :=~, :!~, :eql?, :hash, :&lt;=&gt;, :class, :singleton_class, :clone,
:dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze,
:frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods,
:private_methods, :public_methods, :instance_variables, :instance_variable_get,
:instance_variable_set, :instance_variable_defined?, :remove_instance_variable,
:instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?,
:extend, :display, :method, :public_method, :define_singleton_method,
:object_id, :to_enum, :enum_for, :gem, :pretty_inspect, :byebug]
(byebug) pp Kernel.instance_methods
[:nil?,
 :===,
 :=~,
 :!~,
 :eql?,
 :hash,
 :&lt;=&gt;,
 :class,
 :singleton_class,
 :clone,
 :dup,
 :taint,
 :tainted?,
 :untaint,
 :untrust,
 :untrusted?,
 :trust,
 :freeze,
 :frozen?,
 :to_s,
 :inspect,
 :methods,
 :singleton_methods,
 :protected_methods,
 :private_methods,
 :public_methods,
 :instance_variables,
 :instance_variable_get,
 :instance_variable_set,
 :instance_variable_defined?,
 :remove_instance_variable,
 :instance_of?,
 :kind_of?,
 :is_a?,
 :tap,
 :send,
 :public_send,
 :respond_to?,
 :extend,
 :display,
 :method,
 :public_method,
 :define_singleton_method,
 :object_id,
 :to_enum,
 :enum_for,
 :gem,
 :pretty_inspect,
 :byebug]
(byebug) putl Kernel.instance_methods
nil?  &lt;=&gt;              tainted?    frozen?            private_methods             remove_instance_variable  public_send    define_singleton_method  byebug
===   class            untaint     to_s               public_methods              instance_of?              respond_to?    object_id
=~    singleton_class  untrust     inspect            instance_variables          kind_of?                  extend         to_enum
!~    clone            untrusted?  methods            instance_variable_get       is_a?                     display        enum_for
eql?  dup              trust       singleton_methods  instance_variable_set       tap                       method         gem
hash  taint            freeze      protected_methods  instance_variable_defined?  send                      public_method  pretty_inspect
(byebug) ps Kernel.instance_methods
!~      clone                    extend   instance_of?                kind_of?        private_methods           respond_to?        tap      untrusted?
&lt;=&gt;     define_singleton_method  freeze   instance_variable_defined?  method          protected_methods         send               to_enum
===     display                  frozen?  instance_variable_get       methods         public_method             singleton_class    to_s   
=~      dup                      gem      instance_variable_set       nil?            public_methods            singleton_methods  trust  
byebug  enum_for                 hash     instance_variables          object_id       public_send               taint              untaint
class   eql?                     inspect  is_a?                       pretty_inspect  remove_instance_variable  tainted?           untrust</pre>

<p>Finally, if you need more advanced functionality from REPL&#39;s, you can
enter <code>irb</code> or <code>pry</code> using <code>irb</code> or
<code>pry</code> commands. The bindings environment will be set to the
current state in the program. When you leave the repl and go back to
<code>byebug</code>&#39;s command prompt we show the file, line and text
position of the program. If you issue a <code>list</code> without location
information, the default location used is the current line rather than the
current position that may have got updated via a prior <code>list</code>
command.</p>

<pre>$ byebug triangle.rb
[1, 10] in /path/to/triangle.rb
    1: # Compute the n&#39;th triangle number, the hard way: triangle(n) == (n*(n+1))/2
=&gt;  2: def triangle(n)
    3:   tri = 0
    4:   0.upto(n) do |i|
    5:     tri += i
    6:   end
    7:   tri
    8: end
    9:
   10: if __FILE__ == $0
(byebug) irb
2.0.0-p247 :001 &gt; (0..6).inject{|sum, i| sum +=i}
 =&gt; 21
2.0.0-p247 :002 &gt; exit
/home/davidr/Proyectos/byebug/old_doc/triangle.rb @ 2
def triangle(n)
(byebug) list # same line range as before going into irb
[1, 10] in /path/to/triangle.rb
    1: # Compute the n&#39;th triangle number, the hard way: triangle(n) == (n*(n+1))/2
=&gt;  2: def triangle(n)
    3:   tri = 0
    4:   0.upto(n) do |i|
    5:     tri += i
    6:   end
    7:   tri
    8: end
    9:
   10: if __FILE__ == $0
(byebug)</pre>

<h3 id="label-Printing+variables">Printing variables<span><a href="#label-Printing+variables">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Byebug.html">Byebug</a> can print many different information about
variables. Such as * <code>var const &lt;object&gt;</code>. Show the
constants of <code>&lt;object&gt;</code>. This is basically listing
variables and their values in <code>&lt;object&gt;.constant</code>. *
<code>var instance &lt;object&gt;</code>. Show the instance variables of
<code>&lt;object&gt;</code>. This is basically listing
<code>&lt;object&gt;.instance_variables</code>. * <code>var
instance</code>. Show instance_variables of <code>self</code>. * <code>var
local</code>. Show local variables. * <code>var global</code>. Show global
variables. * <code>var all</code>. Show local, global and instance and
class variables of <code>self</code>. * <code>method instance
&lt;object&gt;</code>. Show methods of <code>&lt;object&gt;</code>.
Basically this is the same as running <code>ps
&lt;object&gt;.instance_methods(false)</code>. * <code>method
&lt;class-or-module&gt;</code>. Show methods of the class or module
<code>&lt;class-or-module&gt;</code>. Basically this is the same as running
<code>ps &lt;class-or-module&gt;.methods</code>.</p>

<h3 id="label-Examining+Program+Source+Files-3A+list">Examining Program Source Files: list<span><a href="#label-Examining+Program+Source+Files-3A+list">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><code>byebug</code> can print parts of your script&#39;s source. When your
script stops, <code>byebug</code> spontaneously lists the source code
around the line where it stopped that line. It does that when you change
the current stack frame as well. Implicitly there is a default line
location. Each time a list command is run that implicit location is
updated, so that running several list commands in succession shows a
contiguous block of program text.</p>

<p>If you don&#39;t need code context displayed every time, you can issue the
<code>set noautolist</code> command. Now whenever you want code listed, you
can explicitly issue the <code>list</code> command or its abbreviation
<code>l</code>. Notice that when a second listing is displayed, we continue
listing from the place we last left off. When the beginning or end of the
file is reached, the line range to be shown is adjusted so “it doesn&#39;t
overflow”. You can set the <code>noautolist</code> option by default by
dropping <code>set noautolist</code> in byebug&#39;s startup file
<code>.byebugrc</code>.</p>

<p>If you want to set how many lines to be printed by default rather than use
the initial number of lines, 10, use the <code>set listsize</code> command
([listsize()). To see the entire program in one shot, give an explicit
starting and ending line number. You can print other portions of source
files by giving explicit position as a parameter to the list command.</p>

<p>There are several ways to specify what part of the file you want to print.
<code>list nnn</code> prints lines centered around line number
<code>nnn</code> in the current source file. <code>l</code> prints more
lines, following the last lines printed. <code>list -</code> prints lines
just before the lines last printed. <code>list nnn-mmm</code> prints lines
between <code>nnn</code> and <code>mmm</code> inclusive. <code>list
=</code> prints lines centered around where the script is stopped.
Repeating a <code>list</code> command with <code>RET</code> discards the
argument, so it is equivalent to typing just <code>list</code>. This is
more useful than listing the same lines again. An exception is made for an
argument of <code>-</code>: that argument is preserved in repetition so
that each repetition moves up in the source file.</p>

<h3 id="label-Editing+Source+files-3A+edit">Editing Source files: edit<span><a href="#label-Editing+Source+files-3A+edit">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>To edit a source file, use the <code>edit</code> command. The editor of
your choice is invoked with the current line set to the active line in the
program. Alternatively, you can give a line specification to specify what
part of the file you want to edit.</p>

<p>You can customize <code>byebug</code> to use any editor you want by using
the <code>EDITOR</code> environment variable. The only restriction is that
your editor (say <code>ex</code>) recognizes the following command-line
syntax: <code> ex +nnn file </code></p>

<p>The optional numeric value <code>+nnn</code> specifies the line number in
the file where you want to start editing. For example, to configure
<code>byebug</code> to use the <code>vi</code> editor, you could use these
commands with the <code>sh</code> shell:</p>

<pre>EDITOR=/usr/bin/vi
export EDITOR
byebug ...</pre>

<p>or in the <code>csh</code> shell, <code>bash setenv EDITOR /usr/bin/vi
byebug ... </code></p>

<h3 id="label-The+stack+trace">The stack trace<span><a href="#label-The+stack+trace">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When your script has stopped, one thing you&#39;ll probably want to know is
where it stopped and some idea of how it got there.</p>

<p>Each time your script calls a method or enters a block, information about
this action is saved. This information is what we call a <em>stack
frame</em> or just a <em>frame</em>. The set of all frames at a certain
point in the program&#39;s execution is called the <em>stack trace</em> or
just the <em>stack</em>. Each frame contains a line number and the
source-file name that the line refers to. If the frame is the beginning of
a method it also contains the method name.</p>

<p>When your script is started, the stack has only one frame, that of the
<code>main</code> method. This is called the <em>initial frame</em> or the
<em>outermost frame</em>. Each time a method is called, a new frame is
added to the stack trace. Each time a method returns, the frame for that
method invocation is removed. If a method is recursive, there can be many
frames for the same method. The frame for the method in which execution is
actually occurring is called the <em>innermost frame</em>. This is the most
recently created of all the stack frames that still exist.</p>

<p>Every time the debugger stops, one entry in the stack is selected as the
current frame. Many byebug commands refer implicitly to the selected block.
In particular, whenever you ask <a href="Byebug.html">Byebug</a> to list
lines without giving a line number or location the value is found in the
selected frame. There are special commands to select whichever frame
you&#39;re interested in, such as <code>up</code>, <code>down</code> and
<code>frame</code>.</p>

<p>After switching frames, when you issue a <code>list</code> command without
any position information, the position used is the location in the frame
that you just switched between, rather than a location that got updated via
a prior <code>list</code> command.</p>

<p><a href="Byebug.html">Byebug</a> assigns numbers to all existing stack
frames, starting with zero for the <em>innermost frame</em>, one for the
frame that called it, and so on upward. These numbers do not really exist
in your script, they are assigned by <a href="Byebug.html">Byebug</a> to
give you a way of designating stack frames in commands.</p>

<h3 id="label-Printing+the+Stack-3A+where+command">Printing the Stack: <code>where</code> command<span><a href="#label-Printing+the+Stack-3A+where+command">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The command <code>where</code>, aliased to <code>bt</code> or
<code>backtrace</code> prints the call stack., It shows one line per frame,
for many frames, starting with the place that you are stopped at (frame
zero), followed by its caller (frame one), and on up the stack. Each frame
is numbered and can be referred to in the <code>frame</code> command. The
position of the current frame is marked with <code>--&gt;</code>.</p>

<p>The are some special frames generated for methods that are implemented in
C. One such method is <code>each</code>. They are marked differently in the
call stack to indicate that we cannot switch to those frames. This is
because they have no source code in Ruby, so we can not debug them using <a
href="Byebug.html">Byebug</a>.</p>

<pre>(byebug) where
--&gt; #0 Object.gcd(a#Fixnum, b#Fixnum) at line gcd.rb:6
    #1 at line gcd.rb:19</pre>

<h3 id="label-Selecting+a+frame-3A+up-2C+down+and+frame+commands">Selecting a frame: <code>up</code>, <code>down</code> and <code>frame</code> commands<span><a href="#label-Selecting+a+frame-3A+up-2C+down+and+frame+commands">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><code>up &lt;n&gt;</code>: Move <code>n</code> frames up the stack, towards
the outermost frame (higher frame numbers, frames that have existed
longer). <code>n</code> defaults to one.</p>
</li><li>
<p><code>down &lt;n&gt;</code>: Move <code>n</code> frames down the stack,
towards the <em>innermost frame</em> (lower frame numbers, frames that were
created more recently). <code>n</code> defaults to one.</p>
</li><li>
<p><code>frame &lt;n&gt;</code>: Allows you to move to an arbitrary frame.
<code>n</code> is the stack frame number or 0 if no frame number is given.
<code>frame 0</code> will show the current and most recent stack frame. If
a negative number is given, counting is from the other end of the stack
frame, so <code>frame -1</code> shows the least-recent, outermost stack
frame. Without an argument, <code>frame</code> prints the current stack
frame.</p>
</li></ul>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

