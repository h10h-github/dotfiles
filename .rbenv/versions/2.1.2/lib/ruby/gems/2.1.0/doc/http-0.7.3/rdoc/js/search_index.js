var search_data = {"index":{"searchIndex":["http","chainable","client","error","headers","mixin","mimetype","adapter","json","options","openssl","ssl","redirector","endlessredirecterror","toomanyredirectserror","request","unsupportedmethoderror","unsupportedschemeerror","writer","requesterror","response","body","parser","status","responseerror","stateerror","object","<<()","==()","[]()","[]()","[]()","[]()","[]()","[]=()","__getobj__()","__method__()","__setobj__()","accept()","add()","add()","add_body_type_headers()","add_headers()","append()","argument_error!()","auth()","basic_auth()","canonicalize_header()","charset()","chunk()","coerce()","coerce()","connect()","content_type()","decode()","default_headers()","default_headers=()","default_options()","default_options=()","delete()","delete()","dup()","each()","each()","encode()","finish_response()","finished?()","flush()","follow()","get()","get()","head()","headers?()","http_version()","initialize_copy()","inspect()","inspect()","inspect()","join_headers()","keys()","make_request_body()","make_request_uri()","merge()","merge()","merge!()","mime_type()","new()","new()","new()","new()","new()","new()","new()","new()","new()","normalize()","normalize_uri()","on_body()","on_headers_complete()","on_message_complete()","options()","parse()","patch()","perform()","post()","put()","read_headers!()","read_more()","readpartial()","readpartial()","reason()","register_adapter()","register_alias()","request()","request()","reset()","send_request_body()","send_request_header()","set()","start_tls()","status_code()","stream()","stream()","stream!()","symbolize()","symbolize()","through()","to_a()","to_a()","to_h()","to_hash()","trace()","validate_body_type!()","via()","with()","with_follow()","with_headers()","with_headers()"],"longSearchIndex":["http","http::chainable","http::client","http::error","http::headers","http::headers::mixin","http::mimetype","http::mimetype::adapter","http::mimetype::json","http::options","http::options::openssl","http::options::openssl::ssl","http::redirector","http::redirector::endlessredirecterror","http::redirector::toomanyredirectserror","http::request","http::request::unsupportedmethoderror","http::request::unsupportedschemeerror","http::request::writer","http::requesterror","http::response","http::response::body","http::response::parser","http::response::status","http::responseerror","http::stateerror","object","http::response::parser#<<()","http::headers#==()","http::headers#[]()","http::headers::[]()","http::mimetype::[]()","http::options#[]()","http::response::status::[]()","http::headers#[]=()","http::response::status#__getobj__()","http::request#__method__()","http::response::status#__setobj__()","http::chainable#accept()","http::headers#add()","http::response::parser#add()","http::request::writer#add_body_type_headers()","http::request::writer#add_headers()","http::headers#append()","http::options#argument_error!()","http::chainable#auth()","http::chainable#basic_auth()","http::headers#canonicalize_header()","http::response#charset()","http::response::parser#chunk()","http::headers::coerce()","http::response::status::coerce()","http::chainable#connect()","http::response#content_type()","http::mimetype::json#decode()","http::chainable#default_headers()","http::chainable#default_headers=()","http::chainable#default_options()","http::chainable#default_options=()","http::chainable#delete()","http::headers#delete()","http::options#dup()","http::headers#each()","http::response::body#each()","http::mimetype::json#encode()","http::client#finish_response()","http::response::parser#finished?()","http::response#flush()","http::chainable#follow()","http::chainable#get()","http::headers#get()","http::chainable#head()","http::response::parser#headers?()","http::response::parser#http_version()","http::headers#initialize_copy()","http::headers#inspect()","http::response#inspect()","http::response::status#inspect()","http::request::writer#join_headers()","http::headers#keys()","http::client#make_request_body()","http::client#make_request_uri()","http::headers#merge()","http::options#merge()","http::headers#merge!()","http::response#mime_type()","http::client::new()","http::headers::new()","http::options::new()","http::options::new()","http::request::writer::new()","http::response::new()","http::response::body::new()","http::response::parser::new()","http::response::status::new()","http::mimetype::normalize()","http::client#normalize_uri()","http::response::parser#on_body()","http::response::parser#on_headers_complete()","http::response::parser#on_message_complete()","http::chainable#options()","http::response#parse()","http::chainable#patch()","http::client#perform()","http::chainable#post()","http::chainable#put()","http::client#read_headers!()","http::client#read_more()","http::client#readpartial()","http::response::body#readpartial()","http::response::status#reason()","http::mimetype::register_adapter()","http::mimetype::register_alias()","http::chainable#request()","http::client#request()","http::response::parser#reset()","http::request::writer#send_request_body()","http::request::writer#send_request_header()","http::headers#set()","http::client#start_tls()","http::response::parser#status_code()","http::chainable#stream()","http::request::writer#stream()","http::response#stream!()","http::response::status::symbolize()","http::response::status#symbolize()","http::chainable#through()","http::headers#to_a()","http::response#to_a()","http::headers#to_h()","http::options#to_hash()","http::chainable#trace()","http::request::writer#validate_body_type!()","http::chainable#via()","http::chainable#with()","http::chainable#with_follow()","http::chainable#with_headers()","http::options#with_headers()"],"info":[["HTTP","","HTTP.html","","<p>HTTP should be easy\n"],["HTTP::Chainable","","HTTP/Chainable.html","",""],["HTTP::Client","","HTTP/Client.html","","<p>Clients make requests and receive responses\n"],["HTTP::Error","","HTTP/Error.html","","<p>Generic error\n"],["HTTP::Headers","","HTTP/Headers.html","","<p>HTTP Headers container.\n"],["HTTP::Headers::Mixin","","HTTP/Headers/Mixin.html","","<p>Provides shared behavior for {HTTP::Request} and {HTTP::Response}. Expects\n`@headers` to be an instance …\n"],["HTTP::MimeType","","HTTP/MimeType.html","","<p>MIME type encode/decode adapters\n"],["HTTP::MimeType::Adapter","","HTTP/MimeType/Adapter.html","","<p>Base encode/decode MIME type adapter\n"],["HTTP::MimeType::JSON","","HTTP/MimeType/JSON.html","","<p>JSON encode/decode MIME type adapter\n"],["HTTP::Options","","HTTP/Options.html","",""],["HTTP::Options::OpenSSL","","HTTP/Options/OpenSSL.html","",""],["HTTP::Options::OpenSSL::SSL","","HTTP/Options/OpenSSL/SSL.html","",""],["HTTP::Redirector","","HTTP/Redirector.html","",""],["HTTP::Redirector::EndlessRedirectError","","HTTP/Redirector/EndlessRedirectError.html","","<p>Notifies that following redirects got into an endless loop\n"],["HTTP::Redirector::TooManyRedirectsError","","HTTP/Redirector/TooManyRedirectsError.html","","<p>Notifies that we reached max allowed redirect hops\n"],["HTTP::Request","","HTTP/Request.html","",""],["HTTP::Request::UnsupportedMethodError","","HTTP/Request/UnsupportedMethodError.html","","<p>The method given was not understood\n"],["HTTP::Request::UnsupportedSchemeError","","HTTP/Request/UnsupportedSchemeError.html","","<p>The scheme of given URI was not understood\n"],["HTTP::Request::Writer","","HTTP/Request/Writer.html","",""],["HTTP::RequestError","","HTTP/RequestError.html","","<p>Generic Request error\n"],["HTTP::Response","","HTTP/Response.html","",""],["HTTP::Response::Body","","HTTP/Response/Body.html","","<p>A streamable response body, also easily converted into a string\n"],["HTTP::Response::Parser","","HTTP/Response/Parser.html","",""],["HTTP::Response::Status","","HTTP/Response/Status.html","",""],["HTTP::ResponseError","","HTTP/ResponseError.html","","<p>Generic Response error\n"],["HTTP::StateError","","HTTP/StateError.html","","<p>Request to do something when we&#39;re in the wrong state\n"],["Object","","Object.html","",""],["<<","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-3C-3C","(data)",""],["==","HTTP::Headers","HTTP/Headers.html#method-i-3D-3D","(other)","<p>Compares headers to another Headers or Array of key/value pairs\n<p>@return [Boolean]\n"],["[]","HTTP::Headers","HTTP/Headers.html#method-i-5B-5D","(name)","<p>Smart version of {#get}.\n<p>@return [nil] if header was not set @return [String] if header has exactly\none …\n"],["[]","HTTP::Headers","HTTP/Headers.html#method-c-5B-5D","(object)",""],["[]","HTTP::MimeType","HTTP/MimeType.html#method-c-5B-5D","(type)","<p>Returns adapter associated with MIME type\n<p>@param [#to_s] type @raise [Error] if no adapter found @return …\n"],["[]","HTTP::Options","HTTP/Options.html#method-i-5B-5D","(option)",""],["[]","HTTP::Response::Status","HTTP/Response/Status.html#method-c-5B-5D","(object)",""],["[]=","HTTP::Headers","HTTP/Headers.html#method-i-5B-5D-3D","(name, value)",""],["__getobj__","HTTP::Response::Status","HTTP/Response/Status.html#method-i-__getobj__","()",""],["__method__","HTTP::Request","HTTP/Request.html#method-i-__method__","(*args)","<p>The following alias may be removed in two minor versions (0.8.0) or one\nmajor version (1.0.0)\n"],["__setobj__","HTTP::Response::Status","HTTP/Response/Status.html#method-i-__setobj__","(obj)",""],["accept","HTTP::Chainable","HTTP/Chainable.html#method-i-accept","(type)","<p>Accept the given MIME type(s) @param type\n"],["add","HTTP::Headers","HTTP/Headers.html#method-i-add","(name, value)","<p>Appends header.\n<p>@param [#to_s] name header name @param [Array&lt;#to_s&gt;, #to_s] value\nheader value(s) …\n"],["add","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-add","(data)",""],["add_body_type_headers","HTTP::Request::Writer","HTTP/Request/Writer.html#method-i-add_body_type_headers","()","<p>Adds the headers to the header array for the given request body we are\nworking with\n"],["add_headers","HTTP::Request::Writer","HTTP/Request/Writer.html#method-i-add_headers","()","<p>Adds headers to the request header from the headers array\n"],["append","HTTP::Headers","HTTP/Headers.html#method-i-append","(name, value)","<p>@deprecated Will be removed in 1.0.0\n"],["argument_error!","HTTP::Options","HTTP/Options.html#method-i-argument_error-21","(message)",""],["auth","HTTP::Chainable","HTTP/Chainable.html#method-i-auth","(value, opts = nil)","<p>Make a request with the given Authorization header @param [#to_s] value\nAuthorization header value\n"],["basic_auth","HTTP::Chainable","HTTP/Chainable.html#method-i-basic_auth","(opts)","<p>Make a request with the given Basic authorization header @see\ntools.ietf.org/html/rfc2617 @param [#fetch] …\n"],["canonicalize_header","HTTP::Headers","HTTP/Headers.html#method-i-canonicalize_header","(name)","<p>Transforms `name` to canonical HTTP header capitalization\n<p>@param [String] name @return [String] canonical …\n"],["charset","HTTP::Response","HTTP/Response.html#method-i-charset","()","<p>Charset of response (if any)\n<p>@return [String, nil]\n"],["chunk","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-chunk","()",""],["coerce","HTTP::Headers","HTTP/Headers.html#method-c-coerce","(object)","<p>Coerces given `object` into Headers.\n<p>@raise [Error] if object can&#39;t be coerced @param [#to_hash,  …\n"],["coerce","HTTP::Response::Status","HTTP/Response/Status.html#method-c-coerce","(object)","<p>Coerces given value to Status.\n<p>@example\n\n<pre>Status.coerce(:bad_request) # =&gt; Status.new(400)\nStatus.coerce(&quot;400&quot;) ...</pre>\n"],["connect","HTTP::Chainable","HTTP/Chainable.html#method-i-connect","(uri, options = {})","<p>Convert to a transparent TCP/IP tunnel @param uri @option options [Hash]\n"],["content_type","HTTP::Response","HTTP/Response.html#method-i-content_type","()","<p>Parsed Content-Type header\n<p>@return [HTTP::ContentType]\n"],["decode","HTTP::MimeType::JSON","HTTP/MimeType/JSON.html#method-i-decode","(str)","<p>Decodes JSON\n"],["default_headers","HTTP::Chainable","HTTP/Chainable.html#method-i-default_headers","()","<p>Get headers of HTTP options\n"],["default_headers=","HTTP::Chainable","HTTP/Chainable.html#method-i-default_headers-3D","(headers)","<p>Set headers of HTTP options @param headers\n"],["default_options","HTTP::Chainable","HTTP/Chainable.html#method-i-default_options","()","<p>Get options for HTTP @return [HTTP::Options]\n"],["default_options=","HTTP::Chainable","HTTP/Chainable.html#method-i-default_options-3D","(opts)","<p>Set options for HTTP @param opts @return [HTTP::Options]\n"],["delete","HTTP::Chainable","HTTP/Chainable.html#method-i-delete","(uri, options = {})","<p>Delete a resource @param uri @option options [Hash]\n"],["delete","HTTP::Headers","HTTP/Headers.html#method-i-delete","(name)","<p>Removes header.\n<p>@param [#to_s] name header name @return [void]\n"],["dup","HTTP::Options","HTTP/Options.html#method-i-dup","()",""],["each","HTTP::Headers","HTTP/Headers.html#method-i-each","(&blk)","<p>Calls the given block once for each key/value pair in headers container.\n<p>@return [Enumerator] if no block …\n"],["each","HTTP::Response::Body","HTTP/Response/Body.html#method-i-each","()","<p>Iterate over the body, allowing it to be enumerable\n"],["encode","HTTP::MimeType::JSON","HTTP/MimeType/JSON.html#method-i-encode","(obj)","<p>Encodes object to JSON\n"],["finish_response","HTTP::Client","HTTP/Client.html#method-i-finish_response","()","<p>Callback for when we&#39;ve reached the end of a response\n"],["finished?","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-finished-3F","()",""],["flush","HTTP::Response","HTTP/Response.html#method-i-flush","()","<p>Flushes body and returns self-reference\n<p>@return [Response]\n"],["follow","HTTP::Chainable","HTTP/Chainable.html#method-i-follow","(opts = true)","<p>Make client follow redirects. @param opts @return [HTTP::Client] @see\nRedirector#initialize\n"],["get","HTTP::Chainable","HTTP/Chainable.html#method-i-get","(uri, options = {})","<p>Get a resource @param uri @option options [Hash]\n"],["get","HTTP::Headers","HTTP/Headers.html#method-i-get","(name)","<p>Returns list of header values if any.\n<p>@return [Array&lt;String&gt;]\n"],["head","HTTP::Chainable","HTTP/Chainable.html#method-i-head","(uri, options = {})","<p>Request a get sans response body @param uri @option options [Hash]\n"],["headers?","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-headers-3F","()",""],["http_version","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-http_version","()",""],["initialize_copy","HTTP::Headers","HTTP/Headers.html#method-i-initialize_copy","(orig)","<p>Properly clones internal key/value storage.\n<p>@api private\n"],["inspect","HTTP::Headers","HTTP/Headers.html#method-i-inspect","()","<p>Returns human-readable representation of `self` instance.\n<p>@return [String]\n"],["inspect","HTTP::Response","HTTP/Response.html#method-i-inspect","()","<p>Inspect a response\n"],["inspect","HTTP::Response::Status","HTTP/Response/Status.html#method-i-inspect","()","<p>Printable version of HTTP Status, surrounded by quote marks, with special\ncharacters escaped.\n<p>(see String#inspect …\n"],["join_headers","HTTP::Request::Writer","HTTP/Request/Writer.html#method-i-join_headers","()","<p>Joins the headers specified in the request into a correctly formatted http\nrequest header string\n"],["keys","HTTP::Headers","HTTP/Headers.html#method-i-keys","()","<p>Returns list of header names.\n<p>@return [Array&lt;String&gt;]\n"],["make_request_body","HTTP::Client","HTTP/Client.html#method-i-make_request_body","(opts, headers)","<p>Create the request body object to send\n"],["make_request_uri","HTTP::Client","HTTP/Client.html#method-i-make_request_uri","(uri, options)","<p>Merges query params if needed\n"],["merge","HTTP::Headers","HTTP/Headers.html#method-i-merge","(other)","<p>Returns new instance with `other` headers merged in.\n<p>@see #merge! @return [Headers]\n"],["merge","HTTP::Options","HTTP/Options.html#method-i-merge","(other)",""],["merge!","HTTP::Headers","HTTP/Headers.html#method-i-merge-21","(other)","<p>Merges `other` headers into `self`.\n<p>@see #merge @return [void]\n"],["mime_type","HTTP::Response","HTTP/Response.html#method-i-mime_type","()","<p>MIME type of response (if any)\n<p>@return [String, nil]\n"],["new","HTTP::Client","HTTP/Client.html#method-c-new","(default_options = {})",""],["new","HTTP::Headers","HTTP/Headers.html#method-c-new","()","<p>Class constructor.\n"],["new","HTTP::Options","HTTP/Options.html#method-c-new","(options = {})",""],["new","HTTP::Options","HTTP/Options.html#method-c-new","(options = {})",""],["new","HTTP::Request::Writer","HTTP/Request/Writer.html#method-c-new","(socket, body, headers, headerstart)",""],["new","HTTP::Response","HTTP/Response.html#method-c-new","(status, version, headers, body, uri = nil)",""],["new","HTTP::Response::Body","HTTP/Response/Body.html#method-c-new","(client)",""],["new","HTTP::Response::Parser","HTTP/Response/Parser.html#method-c-new","()",""],["new","HTTP::Response::Status","HTTP/Response/Status.html#method-c-new","(code)","<p>@param [#to_i] code\n"],["normalize","HTTP::MimeType","HTTP/MimeType.html#method-c-normalize","(type)","<p>Resolves type by shortcut if possible\n<p>@param [#to_s] type @return [String]\n"],["normalize_uri","HTTP::Client","HTTP/Client.html#method-i-normalize_uri","(uri)","<p>Normalize URI\n<p>@param [#to_s] uri @return [URI]\n"],["on_body","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-on_body","(chunk)",""],["on_headers_complete","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-on_headers_complete","(headers)","<p>HTTP::Parser callbacks\n"],["on_message_complete","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-on_message_complete","()",""],["options","HTTP::Chainable","HTTP/Chainable.html#method-i-options","(uri, options = {})","<p>Return the methods supported on the given URI @param uri @option options\n[Hash]\n"],["parse","HTTP::Response","HTTP/Response.html#method-i-parse","(as = nil)","<p>Parse response body with corresponding MIME type adapter.\n<p>@param [#to_s] as Parse as given MIME type\n\n<pre>instead ...</pre>\n"],["patch","HTTP::Chainable","HTTP/Chainable.html#method-i-patch","(uri, options = {})","<p>Apply partial modifications to a resource @param uri @option options [Hash]\n"],["perform","HTTP::Client","HTTP/Client.html#method-i-perform","(req, options)","<p>Perform a single (no follow) HTTP request\n"],["post","HTTP::Chainable","HTTP/Chainable.html#method-i-post","(uri, options = {})","<p>Post to a resource @param uri @option options [Hash]\n"],["put","HTTP::Chainable","HTTP/Chainable.html#method-i-put","(uri, options = {})","<p>Put to a resource @param uri @option options [Hash]\n"],["read_headers!","HTTP::Client","HTTP/Client.html#method-i-read_headers-21","()","<p>Reads data from socket up until headers\n"],["read_more","HTTP::Client","HTTP/Client.html#method-i-read_more","(size)","<p>Feeds some more data into parser\n"],["readpartial","HTTP::Client","HTTP/Client.html#method-i-readpartial","(size = BUFFER_SIZE)","<p>Read a chunk of the body\n<p>@return [String] data chunk @return [Nil] when no more data left\n"],["readpartial","HTTP::Response::Body","HTTP/Response/Body.html#method-i-readpartial","(*args)","<p>(see HTTP::Client#readpartial)\n"],["reason","HTTP::Response::Status","HTTP/Response/Status.html#method-i-reason","()","<p>@see REASONS @return [String, nil] status message\n"],["register_adapter","HTTP::MimeType","HTTP/MimeType.html#method-c-register_adapter","(type, adapter)","<p>Associate MIME type with adapter\n<p>@example\n\n<pre>module JsonAdapter\n  class &lt;&lt; self\n    def encode(obj)\n      ...</pre>\n"],["register_alias","HTTP::MimeType","HTTP/MimeType.html#method-c-register_alias","(type, shortcut)","<p>Register a shortcut for MIME type\n<p>@example\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">HTTP</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">MimeType</span>.<span class=\"ruby-identifier\">register_alias</span> <span class=\"ruby-string\">&#39;application/json&#39;</span>, :<span class=\"ruby-identifier\">json</span>\n</pre>\n"],["request","HTTP::Chainable","HTTP/Chainable.html#method-i-request","(verb, uri, options = {})","<p>Make an HTTP request with the given verb @param uri @option options [Hash]\n"],["request","HTTP::Client","HTTP/Client.html#method-i-request","(verb, uri, opts = {})","<p>Make an HTTP request\n"],["reset","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-reset","()",""],["send_request_body","HTTP::Request::Writer","HTTP/Request/Writer.html#method-i-send_request_body","()",""],["send_request_header","HTTP::Request::Writer","HTTP/Request/Writer.html#method-i-send_request_header","()",""],["set","HTTP::Headers","HTTP/Headers.html#method-i-set","(name, value)","<p>Sets header.\n<p>@param (see #add) @return [void]\n"],["start_tls","HTTP::Client","HTTP/Client.html#method-i-start_tls","(socket, host, options)","<p>Initialize TLS connection\n"],["status_code","HTTP::Response::Parser","HTTP/Response/Parser.html#method-i-status_code","()",""],["stream","HTTP::Chainable","HTTP/Chainable.html#method-i-stream","()","<p>Alias for with_response(:object)\n"],["stream","HTTP::Request::Writer","HTTP/Request/Writer.html#method-i-stream","()","<p>Stream the request to a socket\n"],["stream!","HTTP::Response","HTTP/Response.html#method-i-stream-21","()","<p>Assert that the body is actively being streamed\n"],["symbolize","HTTP::Response::Status","HTTP/Response/Status.html#method-c-symbolize","(str)","<p>Symbolizes given string\n<p>@example\n\n<pre>symbolize &quot;Bad Request&quot;           # =&gt; :bad_request\nsymbolize &quot;Request-URI ...</pre>\n"],["symbolize","HTTP::Response::Status","HTTP/Response/Status.html#method-i-symbolize","()","<p>Symbolized {#reason}\n<p>@return [nil] unless code is well-known (see REASONS) @return [Symbol]\n"],["through","HTTP::Chainable","HTTP/Chainable.html#method-i-through","(*proxy)",""],["to_a","HTTP::Headers","HTTP/Headers.html#method-i-to_a","()","<p>Returns headers key/value pairs.\n<p>@return [Array&lt;[String, String]&gt;]\n"],["to_a","HTTP::Response","HTTP/Response.html#method-i-to_a","()","<p>Returns an Array ala Rack: `[status, headers, body]`\n<p>@return [Array(Fixnum, Hash, String)]\n"],["to_h","HTTP::Headers","HTTP/Headers.html#method-i-to_h","()","<p>Returns Rack-compatible headers Hash\n<p>@return [Hash]\n"],["to_hash","HTTP::Options","HTTP/Options.html#method-i-to_hash","()",""],["trace","HTTP::Chainable","HTTP/Chainable.html#method-i-trace","(uri, options = {})","<p>Echo the request back to the client @param uri @option options [Hash]\n"],["validate_body_type!","HTTP::Request::Writer","HTTP/Request/Writer.html#method-i-validate_body_type-21","()",""],["via","HTTP::Chainable","HTTP/Chainable.html#method-i-via","(*proxy)","<p>Make a request through an HTTP proxy @param [Array] proxy @raise\n[Request::Error] if HTTP proxy is invalid …\n"],["with","HTTP::Chainable","HTTP/Chainable.html#method-i-with","(headers)",""],["with_follow","HTTP::Chainable","HTTP/Chainable.html#method-i-with_follow","(opts = true)","<p>@deprecated @see #follow\n"],["with_headers","HTTP::Chainable","HTTP/Chainable.html#method-i-with_headers","(headers)","<p>Make a request with the given headers @param headers\n"],["with_headers","HTTP::Options","HTTP/Options.html#method-i-with_headers","(headers)",""]]}}