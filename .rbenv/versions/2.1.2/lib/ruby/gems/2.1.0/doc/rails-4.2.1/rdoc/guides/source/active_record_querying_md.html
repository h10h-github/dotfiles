<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>active_record_querying - rails-4.2.1 Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/darkfish.js"></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Active+Record+Query+Interface">Active Record Query Interface</a>
    <li><a href="#label-Retrieving+Objects+from+the+Database">Retrieving Objects from the Database</a>
    <li><a href="#label-Retrieving+a+Single+Object">Retrieving a Single Object</a>
    <li><a href="#label-find"><code>find</code></a>
    <li><a href="#label-take"><code>take</code></a>
    <li><a href="#label-first"><code>first</code></a>
    <li><a href="#label-last"><code>last</code></a>
    <li><a href="#label-find_by"><code>find_by</code></a>
    <li><a href="#label-Retrieving+Multiple+Objects+in+Batches">Retrieving Multiple Objects in Batches</a>
    <li><a href="#label-find_each"><code>find_each</code></a>
    <li><a href="#label-Options+for+find_each">Options for <code>find_each</code></a>
    <li><a href="#label-find_in_batches"><code>find_in_batches</code></a>
    <li><a href="#label-Options+for+find_in_batches">Options for <code>find_in_batches</code></a>
    <li><a href="#label-Conditions">Conditions</a>
    <li><a href="#label-Pure+String+Conditions">Pure String Conditions</a>
    <li><a href="#label-Array+Conditions">Array Conditions</a>
    <li><a href="#label-Placeholder+Conditions">Placeholder Conditions</a>
    <li><a href="#label-Hash+Conditions">Hash Conditions</a>
    <li><a href="#label-Equality+Conditions">Equality Conditions</a>
    <li><a href="#label-Range+Conditions">Range Conditions</a>
    <li><a href="#label-Subset+Conditions">Subset Conditions</a>
    <li><a href="#label-NOT+Conditions">NOT Conditions</a>
    <li><a href="#label-Ordering">Ordering</a>
    <li><a href="#label-Selecting+Specific+Fields">Selecting Specific Fields</a>
    <li><a href="#label-Limit+and+Offset">Limit and Offset</a>
    <li><a href="#label-Group">Group</a>
    <li><a href="#label-Total+of+grouped+items">Total of grouped items</a>
    <li><a href="#label-Having">Having</a>
    <li><a href="#label-Overriding+Conditions">Overriding Conditions</a>
    <li><a href="#label-unscope"><code>unscope</code></a>
    <li><a href="#label-only"><code>only</code></a>
    <li><a href="#label-reorder"><code>reorder</code></a>
    <li><a href="#label-reverse_order"><code>reverse_order</code></a>
    <li><a href="#label-rewhere"><code>rewhere</code></a>
    <li><a href="#label-Null+Relation">Null Relation</a>
    <li><a href="#label-Readonly+Objects">Readonly Objects</a>
    <li><a href="#label-Locking+Records+for+Update">Locking Records for Update</a>
    <li><a href="#label-Optimistic+Locking">Optimistic Locking</a>
    <li><a href="#label-Pessimistic+Locking">Pessimistic Locking</a>
    <li><a href="#label-Joining+Tables">Joining Tables</a>
    <li><a href="#label-Using+a+String+SQL+Fragment">Using a String SQL Fragment</a>
    <li><a href="#label-Using+Array-2FHash+of+Named+Associations">Using Array/Hash of Named Associations</a>
    <li><a href="#label-Joining+a+Single+Association">Joining a Single Association</a>
    <li><a href="#label-Joining+Multiple+Associations">Joining Multiple Associations</a>
    <li><a href="#label-Joining+Nested+Associations+-28Single+Level-29">Joining Nested Associations (Single Level)</a>
    <li><a href="#label-Joining+Nested+Associations+-28Multiple+Level-29">Joining Nested Associations (Multiple Level)</a>
    <li><a href="#label-Specifying+Conditions+on+the+Joined+Tables">Specifying Conditions on the Joined Tables</a>
    <li><a href="#label-Eager+Loading+Associations">Eager Loading Associations</a>
    <li><a href="#label-Eager+Loading+Multiple+Associations">Eager Loading Multiple Associations</a>
    <li><a href="#label-Array+of+Multiple+Associations">Array of Multiple Associations</a>
    <li><a href="#label-Nested+Associations+Hash">Nested Associations Hash</a>
    <li><a href="#label-Specifying+Conditions+on+Eager+Loaded+Associations">Specifying Conditions on Eager Loaded Associations</a>
    <li><a href="#label-Scopes">Scopes</a>
    <li><a href="#label-Passing+in+arguments">Passing in arguments</a>
    <li><a href="#label-Applying+a+default+scope">Applying a default scope</a>
    <li><a href="#label-Merging+of+scopes">Merging of scopes</a>
    <li><a href="#label-Removing+All+Scoping">Removing All Scoping</a>
    <li><a href="#label-Dynamic+Finders">Dynamic Finders</a>
    <li><a href="#label-Find+or+Build+a+New+Object">Find or Build a New Object</a>
    <li><a href="#label-find_or_create_by"><code>find_or_create_by</code></a>
    <li><a href="#label-find_or_create_by-21"><code>find_or_create_by!</code></a>
    <li><a href="#label-find_or_initialize_by"><code>find_or_initialize_by</code></a>
    <li><a href="#label-Finding+by+SQL">Finding by SQL</a>
    <li><a href="#label-select_all"><code>select_all</code></a>
    <li><a href="#label-pluck"><code>pluck</code></a>
    <li><a href="#label-ids"><code>ids</code></a>
    <li><a href="#label-Existence+of+Objects">Existence of Objects</a>
    <li><a href="#label-Calculations">Calculations</a>
    <li><a href="#label-Count">Count</a>
    <li><a href="#label-Average">Average</a>
    <li><a href="#label-Minimum">Minimum</a>
    <li><a href="#label-Maximum">Maximum</a>
    <li><a href="#label-Sum">Sum</a>
    <li><a href="#label-Running+EXPLAIN">Running EXPLAIN</a>
    <li><a href="#label-Interpreting+EXPLAIN">Interpreting EXPLAIN</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../README_md.html">README</a>
  
    <li><a href="../../guides/CHANGELOG_md.html">CHANGELOG</a>
  
    <li><a href="../../guides/Rakefile.html">Rakefile</a>
  
    <li><a href="../../guides/assets/images/icons/README.html">README</a>
  
    <li><a href="../../guides/assets/javascripts/guides_js.html">guides.js</a>
  
    <li><a href="../../guides/assets/javascripts/jquery_min_js.html">jquery.min.js</a>
  
    <li><a href="../../guides/assets/javascripts/responsive-tables_js.html">responsive-tables.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushAS3_js.html">shBrushAS3.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushAppleScript_js.html">shBrushAppleScript.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushBash_js.html">shBrushBash.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushCSharp_js.html">shBrushCSharp.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushColdFusion_js.html">shBrushColdFusion.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushCpp_js.html">shBrushCpp.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushCss_js.html">shBrushCss.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushDelphi_js.html">shBrushDelphi.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushDiff_js.html">shBrushDiff.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushErlang_js.html">shBrushErlang.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushGroovy_js.html">shBrushGroovy.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushJScript_js.html">shBrushJScript.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushJava_js.html">shBrushJava.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushJavaFX_js.html">shBrushJavaFX.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPerl_js.html">shBrushPerl.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPhp_js.html">shBrushPhp.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPlain_js.html">shBrushPlain.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPowerShell_js.html">shBrushPowerShell.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPython_js.html">shBrushPython.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushRuby_js.html">shBrushRuby.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushSass_js.html">shBrushSass.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushScala_js.html">shBrushScala.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushSql_js.html">shBrushSql.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushVb_js.html">shBrushVb.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushXml_js.html">shBrushXml.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shCore_js.html">shCore.js</a>
  
    <li><a href="../../guides/assets/stylesheets/fixes_css.html">fixes.css</a>
  
    <li><a href="../../guides/assets/stylesheets/kindle_css.html">kindle.css</a>
  
    <li><a href="../../guides/assets/stylesheets/main_css.html">main.css</a>
  
    <li><a href="../../guides/assets/stylesheets/print_css.html">print.css</a>
  
    <li><a href="../../guides/assets/stylesheets/reset_css.html">reset.css</a>
  
    <li><a href="../../guides/assets/stylesheets/responsive-tables_css.html">responsive-tables.css</a>
  
    <li><a href="../../guides/assets/stylesheets/style_css.html">style.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCore_css.html">shCore.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreDefault_css.html">shCoreDefault.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreDjango_css.html">shCoreDjango.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreEclipse_css.html">shCoreEclipse.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreEmacs_css.html">shCoreEmacs.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreFadeToGrey_css.html">shCoreFadeToGrey.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreMDUltra_css.html">shCoreMDUltra.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreMidnight_css.html">shCoreMidnight.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreRDark_css.html">shCoreRDark.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeDefault_css.html">shThemeDefault.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeDjango_css.html">shThemeDjango.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeEclipse_css.html">shThemeEclipse.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeEmacs_css.html">shThemeEmacs.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeFadeToGrey_css.html">shThemeFadeToGrey.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeMDUltra_css.html">shThemeMDUltra.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeMidnight_css.html">shThemeMidnight.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeRDark_css.html">shThemeRDark.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeRailsGuides_css.html">shThemeRailsGuides.css</a>
  
    <li><a href="../../guides/source/2_2_release_notes_md.html">2_2_release_notes</a>
  
    <li><a href="../../guides/source/2_3_release_notes_md.html">2_3_release_notes</a>
  
    <li><a href="../../guides/source/3_0_release_notes_md.html">3_0_release_notes</a>
  
    <li><a href="../../guides/source/3_1_release_notes_md.html">3_1_release_notes</a>
  
    <li><a href="../../guides/source/3_2_release_notes_md.html">3_2_release_notes</a>
  
    <li><a href="../../guides/source/4_0_release_notes_md.html">4_0_release_notes</a>
  
    <li><a href="../../guides/source/4_1_release_notes_md.html">4_1_release_notes</a>
  
    <li><a href="../../guides/source/4_2_release_notes_md.html">4_2_release_notes</a>
  
    <li><a href="../../guides/source/action_controller_overview_md.html">action_controller_overview</a>
  
    <li><a href="../../guides/source/action_mailer_basics_md.html">action_mailer_basics</a>
  
    <li><a href="../../guides/source/action_view_overview_md.html">action_view_overview</a>
  
    <li><a href="../../guides/source/active_job_basics_md.html">active_job_basics</a>
  
    <li><a href="../../guides/source/active_model_basics_md.html">active_model_basics</a>
  
    <li><a href="../../guides/source/active_record_basics_md.html">active_record_basics</a>
  
    <li><a href="../../guides/source/active_record_callbacks_md.html">active_record_callbacks</a>
  
    <li><a href="../../guides/source/active_record_migrations_md.html">active_record_migrations</a>
  
    <li><a href="../../guides/source/active_record_postgresql_md.html">active_record_postgresql</a>
  
    <li><a href="../../guides/source/active_record_querying_md.html">active_record_querying</a>
  
    <li><a href="../../guides/source/active_record_validations_md.html">active_record_validations</a>
  
    <li><a href="../../guides/source/active_support_core_extensions_md.html">active_support_core_extensions</a>
  
    <li><a href="../../guides/source/active_support_instrumentation_md.html">active_support_instrumentation</a>
  
    <li><a href="../../guides/source/api_documentation_guidelines_md.html">api_documentation_guidelines</a>
  
    <li><a href="../../guides/source/asset_pipeline_md.html">asset_pipeline</a>
  
    <li><a href="../../guides/source/association_basics_md.html">association_basics</a>
  
    <li><a href="../../guides/source/autoloading_and_reloading_constants_md.html">autoloading_and_reloading_constants</a>
  
    <li><a href="../../guides/source/caching_with_rails_md.html">caching_with_rails</a>
  
    <li><a href="../../guides/source/command_line_md.html">command_line</a>
  
    <li><a href="../../guides/source/configuring_md.html">configuring</a>
  
    <li><a href="../../guides/source/contributing_to_ruby_on_rails_md.html">contributing_to_ruby_on_rails</a>
  
    <li><a href="../../guides/source/debugging_rails_applications_md.html">debugging_rails_applications</a>
  
    <li><a href="../../guides/source/development_dependencies_install_md.html">development_dependencies_install</a>
  
    <li><a href="../../guides/source/documents_yaml.html">documents.yaml</a>
  
    <li><a href="../../guides/source/engines_md.html">engines</a>
  
    <li><a href="../../guides/source/form_helpers_md.html">form_helpers</a>
  
    <li><a href="../../guides/source/generators_md.html">generators</a>
  
    <li><a href="../../guides/source/getting_started_md.html">getting_started</a>
  
    <li><a href="../../guides/source/i18n_md.html">i18n</a>
  
    <li><a href="../../guides/source/initialization_md.html">initialization</a>
  
    <li><a href="../../guides/source/layouts_and_rendering_md.html">layouts_and_rendering</a>
  
    <li><a href="../../guides/source/maintenance_policy_md.html">maintenance_policy</a>
  
    <li><a href="../../guides/source/nested_model_forms_md.html">nested_model_forms</a>
  
    <li><a href="../../guides/source/plugins_md.html">plugins</a>
  
    <li><a href="../../guides/source/rails_application_templates_md.html">rails_application_templates</a>
  
    <li><a href="../../guides/source/rails_on_rack_md.html">rails_on_rack</a>
  
    <li><a href="../../guides/source/routing_md.html">routing</a>
  
    <li><a href="../../guides/source/ruby_on_rails_guides_guidelines_md.html">ruby_on_rails_guides_guidelines</a>
  
    <li><a href="../../guides/source/security_md.html">security</a>
  
    <li><a href="../../guides/source/testing_md.html">testing</a>
  
    <li><a href="../../guides/source/upgrading_ruby_on_rails_md.html">upgrading_ruby_on_rails</a>
  
    <li><a href="../../guides/source/working_with_javascript_in_rails_md.html">working_with_javascript_in_rails</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page guides/source/active_record_querying.md">

<h1 id="label-Active+Record+Query+Interface">Active Record Query Interface<span><a href="#label-Active+Record+Query+Interface">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>This guide covers different ways to retrieve data from the database using
Active Record.</p>

<p>After reading this guide, you will know:</p>
<ul><li>
<p>How to find records using a variety of methods and conditions.</p>
</li><li>
<p>How to specify the order, retrieved attributes, grouping, and other
properties of the found records.</p>
</li><li>
<p>How to use eager loading to reduce the number of database queries needed
for data retrieval.</p>
</li><li>
<p>How to use dynamic finders methods.</p>
</li><li>
<p>How to check for the existence of particular records.</p>
</li><li>
<p>How to perform various calculations on Active Record models.</p>
</li><li>
<p>How to run EXPLAIN on relations.</p>
</li></ul>
<hr>

<p>If you&#39;re used to using raw SQL to find database records, then you will
generally find that there are better ways to carry out the same operations
in Rails. Active Record insulates you from the need to use SQL in most
cases.</p>

<p>Code examples throughout this guide will refer to one or more of the
following models:</p>

<p>TIP: All of the following models use <code>id</code> as the primary key,
unless specified otherwise.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">address</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">orders</span>
  <span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">roles</span>
<span class="ruby-keyword">end</span>
</pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Address</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">client</span>
<span class="ruby-keyword">end</span>
</pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Order</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">client</span>, <span class="ruby-identifier">counter_cache</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span>
</pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Role</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_and_belongs_to_many</span> :<span class="ruby-identifier">clients</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Active Record will perform queries on the database for you and is
compatible with most database systems (MySQL, PostgreSQL and SQLite to name
a few). Regardless of which database system you&#39;re using, the Active
Record method format will always be the same.</p>

<h2 id="label-Retrieving+Objects+from+the+Database">Retrieving Objects from the Database<span><a href="#label-Retrieving+Objects+from+the+Database">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To retrieve objects from the database, Active Record provides several
finder methods. Each finder method allows you to pass arguments into it to
perform certain queries on your database without writing raw SQL.</p>

<p>The methods are:</p>
<ul><li>
<p><code>bind</code></p>
</li><li>
<p><code>create_with</code></p>
</li><li>
<p><code>distinct</code></p>
</li><li>
<p><code>eager_load</code></p>
</li><li>
<p><code>extending</code></p>
</li><li>
<p><code>from</code></p>
</li><li>
<p><code>group</code></p>
</li><li>
<p><code>having</code></p>
</li><li>
<p><code>includes</code></p>
</li><li>
<p><code>joins</code></p>
</li><li>
<p><code>limit</code></p>
</li><li>
<p><code>lock</code></p>
</li><li>
<p><code>none</code></p>
</li><li>
<p><code>offset</code></p>
</li><li>
<p><code>order</code></p>
</li><li>
<p><code>preload</code></p>
</li><li>
<p><code>readonly</code></p>
</li><li>
<p><code>references</code></p>
</li><li>
<p><code>reorder</code></p>
</li><li>
<p><code>reverse_order</code></p>
</li><li>
<p><code>select</code></p>
</li><li>
<p><code>uniq</code></p>
</li><li>
<p><code>where</code></p>
</li></ul>

<p>All of the above methods return an instance of
<code>ActiveRecord::Relation</code>.</p>

<p>The primary operation of <code>Model.find(options)</code> can be summarized
as:</p>
<ul><li>
<p>Convert the supplied options to an equivalent SQL query.</p>
</li><li>
<p>Fire the SQL query and retrieve the corresponding results from the
database.</p>
</li><li>
<p>Instantiate the equivalent Ruby object of the appropriate model for every
resulting row.</p>
</li><li>
<p>Run <code>after_find</code> callbacks, if any.</p>
</li></ul>

<h3 id="label-Retrieving+a+Single+Object">Retrieving a Single <a href="../../Object.html">Object</a><span><a href="#label-Retrieving+a+Single+Object">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Active Record provides several different ways of retrieving a single
object.</p>

<h4 id="label-find"><code>find</code><span><a href="#label-find">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Using the <code>find</code> method, you can retrieve the object
corresponding to the specified <em>primary key</em> that matches any
supplied options. For example:</p>

<pre class="ruby"><span class="ruby-comment"># Find the client with primary key (id) 10.</span>
<span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">find</span>(<span class="ruby-value">10</span>)
<span class="ruby-comment"># =&gt; #&lt;Client id: 10, first_name: &quot;Ryan&quot;&gt;</span>
</pre>

<p>The SQL equivalent of the above is:</p>

<pre>SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1</pre>

<p>The <code>find</code> method will raise an
<code>ActiveRecord::RecordNotFound</code> exception if no matching record
is found.</p>

<p>You can also use this method to query for multiple objects. Call the
<code>find</code> method and pass in an array of primary keys. The return
will be an array containing all of the matching records for the supplied
<em>primary keys</em>. For example:</p>

<pre class="ruby"><span class="ruby-comment"># Find the clients with primary keys 1 and 10.</span>
<span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">find</span>([<span class="ruby-value">1</span>, <span class="ruby-value">10</span>]) <span class="ruby-comment"># Or even Client.find(1, 10)</span>
<span class="ruby-comment"># =&gt; [#&lt;Client id: 1, first_name: &quot;Lifo&quot;&gt;, #&lt;Client id: 10, first_name: &quot;Ryan&quot;&gt;]</span>
</pre>

<p>The SQL equivalent of the above is:</p>

<pre>SELECT * FROM clients WHERE (clients.id IN (1,10))</pre>

<p>WARNING: The <code>find</code> method will raise an
<code>ActiveRecord::RecordNotFound</code> exception unless a matching
record is found for <strong>all</strong> of the supplied primary keys.</p>

<h4 id="label-take"><code>take</code><span><a href="#label-take">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>take</code> method retrieves a record without any implicit
ordering. For example:</p>

<pre class="ruby"><span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">take</span>
<span class="ruby-comment"># =&gt; #&lt;Client id: 1, first_name: &quot;Lifo&quot;&gt;</span>
</pre>

<p>The SQL equivalent of the above is:</p>

<pre>SELECT * FROM clients LIMIT 1</pre>

<p>The <code>take</code> method returns <code>nil</code> if no record is found
and no exception will be raised.</p>

<p>You can pass in a numerical argument to the <code>take</code> method to
return up to that number of results. For example</p>

<pre class="ruby"><span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">2</span>)
<span class="ruby-comment"># =&gt; [</span>
  <span class="ruby-comment">#&lt;Client id: 1, first_name: &quot;Lifo&quot;&gt;,</span>
  <span class="ruby-comment">#&lt;Client id: 220, first_name: &quot;Sara&quot;&gt;</span>
]
</pre>

<p>The SQL equivalent of the above is:</p>

<pre>SELECT * FROM clients LIMIT 2</pre>

<p>The <code>take!</code> method behaves exactly like <code>take</code>,
except that it will raise <code>ActiveRecord::RecordNotFound</code> if no
matching record is found.</p>

<p>TIP: The retrieved record may vary depending on the database engine.</p>

<h4 id="label-first"><code>first</code><span><a href="#label-first">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>first</code> method finds the first record ordered by the primary
key. For example:</p>

<pre class="ruby"><span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">first</span>
<span class="ruby-comment"># =&gt; #&lt;Client id: 1, first_name: &quot;Lifo&quot;&gt;</span>
</pre>

<p>The SQL equivalent of the above is:</p>

<pre>SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1</pre>

<p>The <code>first</code> method returns <code>nil</code> if no matching
record is found and no exception will be raised.</p>

<p>You can pass in a numerical argument to the <code>first</code> method to
return up to that number of results. For example</p>

<pre class="ruby"><span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">3</span>)
<span class="ruby-comment"># =&gt; [</span>
  <span class="ruby-comment">#&lt;Client id: 1, first_name: &quot;Lifo&quot;&gt;,</span>
  <span class="ruby-comment">#&lt;Client id: 2, first_name: &quot;Fifo&quot;&gt;,</span>
  <span class="ruby-comment">#&lt;Client id: 3, first_name: &quot;Filo&quot;&gt;</span>
]
</pre>

<p>The SQL equivalent of the above is:</p>

<pre>SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3</pre>

<p>The <code>first!</code> method behaves exactly like <code>first</code>,
except that it will raise <code>ActiveRecord::RecordNotFound</code> if no
matching record is found.</p>

<h4 id="label-last"><code>last</code><span><a href="#label-last">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>last</code> method finds the last record ordered by the primary
key. For example:</p>

<pre class="ruby"><span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">last</span>
<span class="ruby-comment"># =&gt; #&lt;Client id: 221, first_name: &quot;Russel&quot;&gt;</span>
</pre>

<p>The SQL equivalent of the above is:</p>

<pre>SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1</pre>

<p>The <code>last</code> method returns <code>nil</code> if no matching record
is found and no exception will be raised.</p>

<p>You can pass in a numerical argument to the <code>last</code> method to
return up to that number of results. For example</p>

<pre class="ruby"><span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">last</span>(<span class="ruby-value">3</span>)
<span class="ruby-comment"># =&gt; [</span>
  <span class="ruby-comment">#&lt;Client id: 219, first_name: &quot;James&quot;&gt;,</span>
  <span class="ruby-comment">#&lt;Client id: 220, first_name: &quot;Sara&quot;&gt;,</span>
  <span class="ruby-comment">#&lt;Client id: 221, first_name: &quot;Russel&quot;&gt;</span>
]
</pre>

<p>The SQL equivalent of the above is:</p>

<pre>SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3</pre>

<p>The <code>last!</code> method behaves exactly like <code>last</code>,
except that it will raise <code>ActiveRecord::RecordNotFound</code> if no
matching record is found.</p>

<h4 id="label-find_by"><code>find_by</code><span><a href="#label-find_by">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>find_by</code> method finds the first record matching some
conditions. For example:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">find_by</span> <span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Lifo&#39;</span>
<span class="ruby-comment"># =&gt; #&lt;Client id: 1, first_name: &quot;Lifo&quot;&gt;</span>

<span class="ruby-constant">Client</span>.<span class="ruby-identifier">find_by</span> <span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Jon&#39;</span>
<span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>It is equivalent to writing:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Lifo&#39;</span>).<span class="ruby-identifier">take</span>
</pre>

<p>The <code>find_by!</code> method behaves exactly like <code>find_by</code>,
except that it will raise <code>ActiveRecord::RecordNotFound</code> if no
matching record is found. For example:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">find_by!</span> <span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;does not exist&#39;</span>
<span class="ruby-comment"># =&gt; ActiveRecord::RecordNotFound</span>
</pre>

<p>This is equivalent to writing:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;does not exist&#39;</span>).<span class="ruby-identifier">take!</span>
</pre>

<h3 id="label-Retrieving+Multiple+Objects+in+Batches">Retrieving Multiple Objects in Batches<span><a href="#label-Retrieving+Multiple+Objects+in+Batches">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>We often need to iterate over a large set of records, as when we send a
newsletter to a large set of users, or when we export data.</p>

<p>This may appear straightforward:</p>

<pre class="ruby"><span class="ruby-comment"># This is very inefficient when the users table has thousands of rows.</span>
<span class="ruby-constant">User</span>.<span class="ruby-identifier">all</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">user</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">NewsMailer</span>.<span class="ruby-identifier">weekly</span>(<span class="ruby-identifier">user</span>).<span class="ruby-identifier">deliver_now</span>
<span class="ruby-keyword">end</span>
</pre>

<p>But this approach becomes increasingly impractical as the table size
increases, since <code>User.all.each</code> instructs Active Record to
fetch <em>the entire table</em> in a single pass, build a model object per
row, and then keep the entire array of model objects in memory. Indeed, if
we have a large number of records, the entire collection may exceed the
amount of memory available.</p>

<p>Rails provides two methods that address this problem by dividing records
into memory-friendly batches for processing. The first method,
<code>find_each</code>, retrieves a batch of records and then yields
<em>each</em> record to the block individually as a model. The second
method, <code>find_in_batches</code>, retrieves a batch of records and then
yields <em>the entire batch</em> to the block as an array of models.</p>

<p>TIP: The <code>find_each</code> and <code>find_in_batches</code> methods
are intended for use in the batch processing of a large number of records
that wouldn&#39;t fit in memory all at once. If you just need to loop over
a thousand records the regular find methods are the preferred option.</p>

<h4 id="label-find_each"><code>find_each</code><span><a href="#label-find_each">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>find_each</code> method retrieves a batch of records and then
yields <em>each</em> record to the block individually as a model. In the
following example, <code>find_each</code> will retrieve 1000 records (the
current default for both <code>find_each</code> and
<code>find_in_batches</code>) and then yield each record individually to
the block as a model. This process is repeated until all of the records
have been processed:</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">find_each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">user</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">NewsMailer</span>.<span class="ruby-identifier">weekly</span>(<span class="ruby-identifier">user</span>).<span class="ruby-identifier">deliver_now</span>
<span class="ruby-keyword">end</span>
</pre>

<p>To add conditions to a <code>find_each</code> operation you can chain other
Active Record methods such as <code>where</code>:</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">weekly_subscriber</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>).<span class="ruby-identifier">find_each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">user</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">NewsMailer</span>.<span class="ruby-identifier">weekly</span>(<span class="ruby-identifier">user</span>).<span class="ruby-identifier">deliver_now</span>
<span class="ruby-keyword">end</span>
</pre>

<h5 id="label-Options+for+find_each">Options for <code>find_each</code><span><a href="#label-Options+for+find_each">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>The <code>find_each</code> method accepts most of the options allowed by
the regular <code>find</code> method, except for <code>:order</code> and
<code>:limit</code>, which are reserved for internal use by
<code>find_each</code>.</p>

<p>Two additional options, <code>:batch_size</code> and <code>:start</code>,
are available as well.</p>

<p><strong><code>:batch_size</code></strong></p>

<p>The <code>:batch_size</code> option allows you to specify the number of
records to be retrieved in each batch, before being passed individually to
the block. For example, to retrieve records in batches of 5000:</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">find_each</span>(<span class="ruby-identifier">batch_size</span><span class="ruby-operator">:</span> <span class="ruby-value">5000</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">user</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">NewsMailer</span>.<span class="ruby-identifier">weekly</span>(<span class="ruby-identifier">user</span>).<span class="ruby-identifier">deliver_now</span>
<span class="ruby-keyword">end</span>
</pre>

<p><strong><code>:start</code></strong></p>

<p>By default, records are fetched in ascending order of the primary key,
which must be an integer. The <code>:start</code> option allows you to
configure the first ID of the sequence whenever the lowest ID is not the
one you need. This would be useful, for example, if you wanted to resume an
interrupted batch process, provided you saved the last processed ID as a
checkpoint.</p>

<p>For example, to send newsletters only to users with the primary key
starting from 2000, and to retrieve them in batches of 5000:</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">find_each</span>(<span class="ruby-identifier">start</span><span class="ruby-operator">:</span> <span class="ruby-value">2000</span>, <span class="ruby-identifier">batch_size</span><span class="ruby-operator">:</span> <span class="ruby-value">5000</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">user</span><span class="ruby-operator">|</span>
  <span class="ruby-constant">NewsMailer</span>.<span class="ruby-identifier">weekly</span>(<span class="ruby-identifier">user</span>).<span class="ruby-identifier">deliver_now</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Another example would be if you wanted multiple workers handling the same
processing queue. You could have each worker handle 10000 records by
setting the appropriate <code>:start</code> option on each worker.</p>

<h4 id="label-find_in_batches"><code>find_in_batches</code><span><a href="#label-find_in_batches">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>find_in_batches</code> method is similar to
<code>find_each</code>, since both retrieve batches of records. The
difference is that <code>find_in_batches</code> yields <em>batches</em> to
the block as an array of models, instead of individually. The following
example will yield to the supplied block an array of up to 1000 invoices at
a time, with the final block containing any remaining invoices:</p>

<pre class="ruby"><span class="ruby-comment"># Give add_invoices an array of 1000 invoices at a time</span>
<span class="ruby-constant">Invoice</span>.<span class="ruby-identifier">find_in_batches</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">invoices</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">export</span>.<span class="ruby-identifier">add_invoices</span>(<span class="ruby-identifier">invoices</span>)
<span class="ruby-keyword">end</span>
</pre>

<h5 id="label-Options+for+find_in_batches">Options for <code>find_in_batches</code><span><a href="#label-Options+for+find_in_batches">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>The <code>find_in_batches</code> method accepts the same
<code>:batch_size</code> and <code>:start</code> options as
<code>find_each</code>.</p>

<h2 id="label-Conditions">Conditions<span><a href="#label-Conditions">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>where</code> method allows you to specify conditions to limit the
records returned, representing the <code>WHERE</code>-part of the SQL
statement. Conditions can either be specified as a string, array, or hash.</p>

<h3 id="label-Pure+String+Conditions">Pure String Conditions<span><a href="#label-Pure+String+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you&#39;d like to add conditions to your find, you could just specify
them in there, just like <code>Client.where(&quot;orders_count =
&#39;2&#39;&quot;)</code>. This will find all clients where the
<code>orders_count</code> field&#39;s value is 2.</p>

<p>WARNING: Building your own conditions as pure strings can leave you
vulnerable to SQL injection exploits. For example,
<code>Client.where(&quot;first_name LIKE
&#39;%#{params[:first_name]}%&#39;&quot;)</code> is not safe. See the next
section for the preferred way to handle conditions using an array.</p>

<h3 id="label-Array+Conditions">Array Conditions<span><a href="#label-Array+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Now what if that number could vary, say as an argument from somewhere? The
find would then take the form:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;orders_count = ?&quot;</span>, <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">orders</span>])
</pre>

<p>Active Record will go through the first element in the conditions value and
any additional elements will replace the question marks <code>(?)</code> in
the first element.</p>

<p>If you want to specify multiple conditions:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;orders_count = ? AND locked = ?&quot;</span>, <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">orders</span>], <span class="ruby-keyword">false</span>)
</pre>

<p>In this example, the first question mark will be replaced with the value in
<code>params[:orders]</code> and the second will be replaced with the SQL
representation of <code>false</code>, which depends on the adapter.</p>

<p>This code is highly preferable:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;orders_count = ?&quot;</span>, <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">orders</span>])
</pre>

<p>to this code:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-node">&quot;orders_count = #{params[:orders]}&quot;</span>)
</pre>

<p>because of argument safety. Putting the variable directly into the
conditions string will pass the variable to the database
<strong>as-is</strong>. This means that it will be an unescaped variable
directly from a user who may have malicious intent. If you do this, you put
your entire database at risk because once a user finds out they can exploit
your database they can do just about anything to it. Never ever put your
arguments directly inside the conditions string.</p>

<p>TIP: For more information on the dangers of SQL injection, see the <a
href="security.html#sql-injection">Ruby on Rails Security Guide</a>.</p>

<h4 id="label-Placeholder+Conditions">Placeholder Conditions<span><a href="#label-Placeholder+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Similar to the <code>(?)</code> replacement style of params, you can also
specify keys/values hash in your array conditions:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;created_at &gt;= :start_date AND created_at &lt;= :end_date&quot;</span>,
  {<span class="ruby-identifier">start_date</span><span class="ruby-operator">:</span> <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">start_date</span>], <span class="ruby-identifier">end_date</span><span class="ruby-operator">:</span> <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">end_date</span>]})
</pre>

<p>This makes for clearer readability if you have a large number of variable
conditions.</p>

<h3 id="label-Hash+Conditions">Hash Conditions<span><a href="#label-Hash+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Active Record also allows you to pass in hash conditions which can increase
the readability of your conditions syntax. With hash conditions, you pass
in a hash with keys of the fields you want conditionalised and the values
of how you want to conditionalise them:</p>

<p>NOTE: Only equality, range and subset checking are possible with Hash
conditions.</p>

<h4 id="label-Equality+Conditions">Equality Conditions<span><a href="#label-Equality+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">locked</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
</pre>

<p>The field name can also be a string:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&#39;locked&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
</pre>

<p>In the case of a belongs_to relationship, an association key can be used to
specify the model if an Active Record object is used as the value. This
method works with polymorphic relationships as well.</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">author</span><span class="ruby-operator">:</span> <span class="ruby-identifier">author</span>)
<span class="ruby-constant">Author</span>.<span class="ruby-identifier">joins</span>(:<span class="ruby-identifier">articles</span>).<span class="ruby-identifier">where</span>(<span class="ruby-identifier">articles</span><span class="ruby-operator">:</span> { <span class="ruby-identifier">author</span><span class="ruby-operator">:</span> <span class="ruby-identifier">author</span> })
</pre>

<p>NOTE: The values cannot be symbols. For example, you cannot do
<code>Client.where(status: :active)</code>.</p>

<h4 id="label-Range+Conditions">Range Conditions<span><a href="#label-Range+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">created_at</span><span class="ruby-operator">:</span> (<span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">midnight</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">day</span>)<span class="ruby-operator">..</span><span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">midnight</span>)
</pre>

<p>This will find all clients created yesterday by using a
<code>BETWEEN</code> SQL statement:</p>

<pre>SELECT * FROM clients WHERE (clients.created_at BETWEEN &#39;2008-12-21 00:00:00&#39; AND &#39;2008-12-22 00:00:00&#39;)</pre>

<p>This demonstrates a shorter syntax for the examples in <a
href="#array-conditions">Array Conditions</a></p>

<h4 id="label-Subset+Conditions">Subset Conditions<span><a href="#label-Subset+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>If you want to find records using the <code>IN</code> expression you can
pass an array to the conditions hash:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">orders_count</span><span class="ruby-operator">:</span> [<span class="ruby-value">1</span>,<span class="ruby-value">3</span>,<span class="ruby-value">5</span>])
</pre>

<p>This code will generate SQL like this:</p>

<pre>SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))</pre>

<h3 id="label-NOT+Conditions">NOT Conditions<span><a href="#label-NOT+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><code>NOT</code> SQL queries can be built by <code>where.not</code>.</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>.<span class="ruby-identifier">not</span>(<span class="ruby-identifier">author</span><span class="ruby-operator">:</span> <span class="ruby-identifier">author</span>)
</pre>

<p>In other words, this query can be generated by calling <code>where</code>
with no argument, then immediately chain with <code>not</code> passing
<code>where</code> conditions.</p>

<h2 id="label-Ordering">Ordering<span><a href="#label-Ordering">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To retrieve records from the database in a specific order, you can use the
<code>order</code> method.</p>

<p>For example, if you&#39;re getting a set of records and want to order them
in ascending order by the <code>created_at</code> field in your table:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">created_at</span>)
<span class="ruby-comment"># OR</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-string">&quot;created_at&quot;</span>)
</pre>

<p>You could specify <code>ASC</code> or <code>DESC</code> as well:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-identifier">created_at</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">desc</span>)
<span class="ruby-comment"># OR</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-identifier">created_at</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">asc</span>)
<span class="ruby-comment"># OR</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-string">&quot;created_at DESC&quot;</span>)
<span class="ruby-comment"># OR</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-string">&quot;created_at ASC&quot;</span>)
</pre>

<p>Or ordering by multiple fields:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-identifier">orders_count</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">asc</span>, <span class="ruby-identifier">created_at</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">desc</span>)
<span class="ruby-comment"># OR</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">orders_count</span>, <span class="ruby-identifier">created_at</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">desc</span>)
<span class="ruby-comment"># OR</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-string">&quot;orders_count ASC, created_at DESC&quot;</span>)
<span class="ruby-comment"># OR</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-string">&quot;orders_count ASC&quot;</span>, <span class="ruby-string">&quot;created_at DESC&quot;</span>)
</pre>

<p>If you want to call <code>order</code> multiple times e.g. in different
context, new order will append previous one</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">order</span>(<span class="ruby-string">&quot;orders_count ASC&quot;</span>).<span class="ruby-identifier">order</span>(<span class="ruby-string">&quot;created_at DESC&quot;</span>)
<span class="ruby-comment"># SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC</span>
</pre>

<h2 id="label-Selecting+Specific+Fields">Selecting Specific Fields<span><a href="#label-Selecting+Specific+Fields">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>By default, <code>Model.find</code> selects all the fields from the result
set using <code>select *</code>.</p>

<p>To select only a subset of fields from the result set, you can specify the
subset via the <code>select</code> method.</p>

<p>For example, to select only <code>viewable_by</code> and
<code>locked</code> columns:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">select</span>(<span class="ruby-string">&quot;viewable_by, locked&quot;</span>)
</pre>

<p>The SQL query used by this find call will be somewhat like:</p>

<pre>SELECT viewable_by, locked FROM clients</pre>

<p>Be careful because this also means you&#39;re initializing a model object
with only the fields that you&#39;ve selected. If you attempt to access a
field that is not in the initialized record you&#39;ll receive:</p>

<pre>ActiveModel::MissingAttributeError: missing attribute: &lt;attribute&gt;</pre>

<p>Where <code>&lt;attribute&gt;</code> is the attribute you asked for. The
<code>id</code> method will not raise the
<code>ActiveRecord::MissingAttributeError</code>, so just be careful when
working with associations because they need the <code>id</code> method to
function properly.</p>

<p>If you would like to only grab a single record per unique value in a
certain field, you can use <code>distinct</code>:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">distinct</span>
</pre>

<p>This would generate SQL like:</p>

<pre class="ruby"><span class="ruby-constant">SELECT</span> <span class="ruby-constant">DISTINCT</span> <span class="ruby-identifier">name</span> <span class="ruby-constant">FROM</span> <span class="ruby-identifier">clients</span>
</pre>

<p>You can also remove the uniqueness constraint:</p>

<pre class="ruby"><span class="ruby-identifier">query</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">distinct</span>
<span class="ruby-comment"># =&gt; Returns unique names</span>

<span class="ruby-identifier">query</span>.<span class="ruby-identifier">distinct</span>(<span class="ruby-keyword">false</span>)
<span class="ruby-comment"># =&gt; Returns all names, even if there are duplicates</span>
</pre>

<h2 id="label-Limit+and+Offset">Limit and Offset<span><a href="#label-Limit+and+Offset">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To apply <code>LIMIT</code> to the SQL fired by the
<code>Model.find</code>, you can specify the <code>LIMIT</code> using
<code>limit</code> and <code>offset</code> methods on the relation.</p>

<p>You can use <code>limit</code> to specify the number of records to be
retrieved, and use <code>offset</code> to specify the number of records to
skip before starting to return the records. For example</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-value">5</span>)
</pre>

<p>will return a maximum of 5 clients and because it specifies no offset it
will return the first 5 in the table. The SQL it executes looks like this:</p>

<pre>SELECT * FROM clients LIMIT 5</pre>

<p>Adding <code>offset</code> to that</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-value">5</span>).<span class="ruby-identifier">offset</span>(<span class="ruby-value">30</span>)
</pre>

<p>will return instead a maximum of 5 clients beginning with the 31st. The SQL
looks like:</p>

<pre>SELECT * FROM clients LIMIT 5 OFFSET 30</pre>

<h2 id="label-Group">Group<span><a href="#label-Group">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To apply a <code>GROUP BY</code> clause to the SQL fired by the finder, you
can specify the <code>group</code> method on the find.</p>

<p>For example, if you want to find a collection of the dates orders were
created on:</p>

<pre class="ruby"><span class="ruby-constant">Order</span>.<span class="ruby-identifier">select</span>(<span class="ruby-string">&quot;date(created_at) as ordered_date, sum(price) as total_price&quot;</span>).<span class="ruby-identifier">group</span>(<span class="ruby-string">&quot;date(created_at)&quot;</span>)
</pre>

<p>And this will give you a single <code>Order</code> object for each date
where there are orders in the database.</p>

<p>The SQL that would be executed would be something like this:</p>

<pre>SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)</pre>

<h3 id="label-Total+of+grouped+items">Total of grouped items<span><a href="#label-Total+of+grouped+items">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>To get the total of grouped items on a single query call <code>count</code>
after the <code>group</code>.</p>

<pre class="ruby"><span class="ruby-constant">Order</span>.<span class="ruby-identifier">group</span>(:<span class="ruby-identifier">status</span>).<span class="ruby-identifier">count</span>
<span class="ruby-comment"># =&gt; { &#39;awaiting_approval&#39; =&gt; 7, &#39;paid&#39; =&gt; 12 }</span>
</pre>

<p>The SQL that would be executed would be something like this:</p>

<pre>SELECT COUNT (*) AS count_all, status AS status
FROM &quot;orders&quot;
GROUP BY status</pre>

<h2 id="label-Having">Having<span><a href="#label-Having">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>SQL uses the <code>HAVING</code> clause to specify conditions on the
<code>GROUP BY</code> fields. You can add the <code>HAVING</code> clause to
the SQL fired by the <code>Model.find</code> by adding the
<code>:having</code> option to the find.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">Order</span>.<span class="ruby-identifier">select</span>(<span class="ruby-string">&quot;date(created_at) as ordered_date, sum(price) as total_price&quot;</span>).
  <span class="ruby-identifier">group</span>(<span class="ruby-string">&quot;date(created_at)&quot;</span>).<span class="ruby-identifier">having</span>(<span class="ruby-string">&quot;sum(price) &gt; ?&quot;</span>, <span class="ruby-value">100</span>)
</pre>

<p>The SQL that would be executed would be something like this:</p>

<pre>SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) &gt; 100</pre>

<p>This will return single order objects for each day, but only those that are
ordered more than $100 in a day.</p>

<h2 id="label-Overriding+Conditions">Overriding Conditions<span><a href="#label-Overriding+Conditions">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-unscope"><code>unscope</code><span><a href="#label-unscope">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can specify certain conditions to be removed using the
<code>unscope</code> method. For example:</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&#39;id &gt; 10&#39;</span>).<span class="ruby-identifier">limit</span>(<span class="ruby-value">20</span>).<span class="ruby-identifier">order</span>(<span class="ruby-string">&#39;id asc&#39;</span>).<span class="ruby-identifier">unscope</span>(:<span class="ruby-identifier">order</span>)
</pre>

<p>The SQL that would be executed:</p>

<pre>SELECT * FROM articles WHERE id &gt; 10 LIMIT 20

# Original query without `unscope`
SELECT * FROM articles WHERE id &gt; 10 ORDER BY id asc LIMIT 20</pre>

<p>You can also unscope specific <code>where</code> clauses. For example:</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">id</span><span class="ruby-operator">:</span> <span class="ruby-value">10</span>, <span class="ruby-identifier">trashed</span><span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>).<span class="ruby-identifier">unscope</span>(<span class="ruby-identifier">where</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">id</span>)
<span class="ruby-comment"># SELECT &quot;articles&quot;.* FROM &quot;articles&quot; WHERE trashed = 0</span>
</pre>

<p>A relation which has used <code>unscope</code> will affect any relation it
is merged in to:</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">order</span>(<span class="ruby-string">&#39;id asc&#39;</span>).<span class="ruby-identifier">merge</span>(<span class="ruby-constant">Article</span>.<span class="ruby-identifier">unscope</span>(:<span class="ruby-identifier">order</span>))
<span class="ruby-comment"># SELECT &quot;articles&quot;.* FROM &quot;articles&quot;</span>
</pre>

<h3 id="label-only"><code>only</code><span><a href="#label-only">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can also override conditions using the <code>only</code> method. For
example:</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&#39;id &gt; 10&#39;</span>).<span class="ruby-identifier">limit</span>(<span class="ruby-value">20</span>).<span class="ruby-identifier">order</span>(<span class="ruby-string">&#39;id desc&#39;</span>).<span class="ruby-identifier">only</span>(:<span class="ruby-identifier">order</span>, :<span class="ruby-identifier">where</span>)
</pre>

<p>The SQL that would be executed:</p>

<pre>SELECT * FROM articles WHERE id &gt; 10 ORDER BY id DESC

# Original query without `only`
SELECT &quot;articles&quot;.* FROM &quot;articles&quot; WHERE (id &gt; 10) ORDER BY id desc LIMIT 20</pre>

<h3 id="label-reorder"><code>reorder</code><span><a href="#label-reorder">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <code>reorder</code> method overrides the default scope order. For
example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Article</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">comments</span>, <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-identifier">order</span>(<span class="ruby-string">&#39;posted_at DESC&#39;</span>) }
<span class="ruby-keyword">end</span>

<span class="ruby-constant">Article</span>.<span class="ruby-identifier">find</span>(<span class="ruby-value">10</span>).<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">reorder</span>(<span class="ruby-string">&#39;name&#39;</span>)
</pre>

<p>The SQL that would be executed:</p>

<pre>SELECT * FROM articles WHERE id = 10
SELECT * FROM comments WHERE article_id = 10 ORDER BY name</pre>

<p>In case the <code>reorder</code> clause is not used, the SQL executed would
be:</p>

<pre>SELECT * FROM articles WHERE id = 10
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC</pre>

<h3 id="label-reverse_order"><code>reverse_order</code><span><a href="#label-reverse_order">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <code>reverse_order</code> method reverses the ordering clause if
specified.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;orders_count &gt; 10&quot;</span>).<span class="ruby-identifier">order</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">reverse_order</span>
</pre>

<p>The SQL that would be executed:</p>

<pre>SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY name DESC</pre>

<p>If no ordering clause is specified in the query, the
<code>reverse_order</code> orders by the primary key in reverse order.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;orders_count &gt; 10&quot;</span>).<span class="ruby-identifier">reverse_order</span>
</pre>

<p>The SQL that would be executed:</p>

<pre>SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY clients.id DESC</pre>

<p>This method accepts <strong>no</strong> arguments.</p>

<h3 id="label-rewhere"><code>rewhere</code><span><a href="#label-rewhere">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <code>rewhere</code> method overrides an existing, named where
condition. For example:</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">trashed</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>).<span class="ruby-identifier">rewhere</span>(<span class="ruby-identifier">trashed</span><span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>)
</pre>

<p>The SQL that would be executed:</p>

<pre>SELECT * FROM articles WHERE `trashed` = 0</pre>

<p>In case the <code>rewhere</code> clause is not used,</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">trashed</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>).<span class="ruby-identifier">where</span>(<span class="ruby-identifier">trashed</span><span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>)
</pre>

<p>the SQL executed would be:</p>

<pre>SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0</pre>

<h2 id="label-Null+Relation">Null Relation<span><a href="#label-Null+Relation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>none</code> method returns a chainable relation with no records.
Any subsequent conditions chained to the returned relation will continue
generating empty relations. This is useful in scenarios where you need a
chainable response to a method or a scope that could return zero results.</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">none</span> <span class="ruby-comment"># returns an empty Relation and fires no queries.</span>
</pre>

<pre class="ruby"><span class="ruby-comment"># The visible_articles method below is expected to return a Relation.</span>
<span class="ruby-ivar">@articles</span> = <span class="ruby-identifier">current_user</span>.<span class="ruby-identifier">visible_articles</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">name</span><span class="ruby-operator">:</span> <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">name</span>])

<span class="ruby-keyword">def</span> <span class="ruby-identifier">visible_articles</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">role</span>
  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;Country Manager&#39;</span>
    <span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">country</span><span class="ruby-operator">:</span> <span class="ruby-identifier">country</span>)
  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;Reviewer&#39;</span>
    <span class="ruby-constant">Article</span>.<span class="ruby-identifier">published</span>
  <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;Bad User&#39;</span>
    <span class="ruby-constant">Article</span>.<span class="ruby-identifier">none</span> <span class="ruby-comment"># =&gt; returning [] or nil breaks the caller code in this case</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Readonly+Objects">Readonly Objects<span><a href="#label-Readonly+Objects">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Active Record provides <code>readonly</code> method on a relation to
explicitly disallow modification of any of the returned objects. Any
attempt to alter a readonly record will not succeed, raising an
<code>ActiveRecord::ReadOnlyRecord</code> exception.</p>

<pre class="ruby"><span class="ruby-identifier">client</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">readonly</span>.<span class="ruby-identifier">first</span>
<span class="ruby-identifier">client</span>.<span class="ruby-identifier">visits</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
<span class="ruby-identifier">client</span>.<span class="ruby-identifier">save</span>
</pre>

<p>As <code>client</code> is explicitly set to be a readonly object, the above
code will raise an <code>ActiveRecord::ReadOnlyRecord</code> exception when
calling <code>client.save</code> with an updated value of <em>visits</em>.</p>

<h2 id="label-Locking+Records+for+Update">Locking Records for Update<span><a href="#label-Locking+Records+for+Update">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Locking is helpful for preventing race conditions when updating records in
the database and ensuring atomic updates.</p>

<p>Active Record provides two locking mechanisms:</p>
<ul><li>
<p>Optimistic Locking</p>
</li><li>
<p>Pessimistic Locking</p>
</li></ul>

<h3 id="label-Optimistic+Locking">Optimistic Locking<span><a href="#label-Optimistic+Locking">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Optimistic locking allows multiple users to access the same record for
edits, and assumes a minimum of conflicts with the data. It does this by
checking whether another process has made changes to a record since it was
opened. An <code>ActiveRecord::StaleObjectError</code> exception is thrown
if that has occurred and the update is ignored.</p>

<p><strong>Optimistic locking column</strong></p>

<p>In order to use optimistic locking, the table needs to have a column called
<code>lock_version</code> of type integer. Each time the record is updated,
Active Record increments the <code>lock_version</code> column. If an update
request is made with a lower value in the <code>lock_version</code> field
than is currently in the <code>lock_version</code> column in the database,
the update request will fail with an
<code>ActiveRecord::StaleObjectError</code>. Example:</p>

<pre class="ruby"><span class="ruby-identifier">c1</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">find</span>(<span class="ruby-value">1</span>)
<span class="ruby-identifier">c2</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">find</span>(<span class="ruby-value">1</span>)

<span class="ruby-identifier">c1</span>.<span class="ruby-identifier">first_name</span> = <span class="ruby-string">&quot;Michael&quot;</span>
<span class="ruby-identifier">c1</span>.<span class="ruby-identifier">save</span>

<span class="ruby-identifier">c2</span>.<span class="ruby-identifier">name</span> = <span class="ruby-string">&quot;should fail&quot;</span>
<span class="ruby-identifier">c2</span>.<span class="ruby-identifier">save</span> <span class="ruby-comment"># Raises an ActiveRecord::StaleObjectError</span>
</pre>

<p>You&#39;re then responsible for dealing with the conflict by rescuing the
exception and either rolling back, merging, or otherwise apply the business
logic needed to resolve the conflict.</p>

<p>This behavior can be turned off by setting
<code>ActiveRecord::Base.lock_optimistically = false</code>.</p>

<p>To override the name of the <code>lock_version</code> column,
<code>ActiveRecord::Base</code> provides a class attribute called
<code>locking_column</code>:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">locking_column</span> = :<span class="ruby-identifier">lock_client_column</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Pessimistic+Locking">Pessimistic Locking<span><a href="#label-Pessimistic+Locking">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Pessimistic locking uses a locking mechanism provided by the underlying
database. Using <code>lock</code> when building a relation obtains an
exclusive lock on the selected rows. Relations using <code>lock</code> are
usually wrapped inside a transaction for preventing deadlock conditions.</p>

<p>For example:</p>

<pre class="ruby"><span class="ruby-constant">Item</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">i</span> = <span class="ruby-constant">Item</span>.<span class="ruby-identifier">lock</span>.<span class="ruby-identifier">first</span>
  <span class="ruby-identifier">i</span>.<span class="ruby-identifier">name</span> = <span class="ruby-string">&#39;Jones&#39;</span>
  <span class="ruby-identifier">i</span>.<span class="ruby-identifier">save</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The above session produces the following SQL for a MySQL backend:</p>

<pre>SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = &#39;2009-02-07 18:05:56&#39;, `name` = &#39;Jones&#39; WHERE `id` = 1
SQL (0.8ms)   COMMIT</pre>

<p>You can also pass raw SQL to the <code>lock</code> method for allowing
different types of locks. For example, MySQL has an expression called
<code>LOCK IN SHARE MODE</code> where you can lock a record but still allow
other queries to read it. To specify this expression just pass it in as the
lock option:</p>

<pre class="ruby"><span class="ruby-constant">Item</span>.<span class="ruby-identifier">transaction</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">i</span> = <span class="ruby-constant">Item</span>.<span class="ruby-identifier">lock</span>(<span class="ruby-string">&quot;LOCK IN SHARE MODE&quot;</span>).<span class="ruby-identifier">find</span>(<span class="ruby-value">1</span>)
  <span class="ruby-identifier">i</span>.<span class="ruby-identifier">increment!</span>(:<span class="ruby-identifier">views</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>If you already have an instance of your model, you can start a transaction
and acquire the lock in one go using the following code:</p>

<pre class="ruby"><span class="ruby-identifier">item</span> = <span class="ruby-constant">Item</span>.<span class="ruby-identifier">first</span>
<span class="ruby-identifier">item</span>.<span class="ruby-identifier">with_lock</span> <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># This block is called within a transaction,</span>
  <span class="ruby-comment"># item is already locked.</span>
  <span class="ruby-identifier">item</span>.<span class="ruby-identifier">increment!</span>(:<span class="ruby-identifier">views</span>)
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Joining+Tables">Joining Tables<span><a href="#label-Joining+Tables">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Active Record provides a finder method called <code>joins</code> for
specifying <code>JOIN</code> clauses on the resulting SQL. There are
multiple ways to use the <code>joins</code> method.</p>

<h3 id="label-Using+a+String+SQL+Fragment">Using a String SQL Fragment<span><a href="#label-Using+a+String+SQL+Fragment">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can just supply the raw SQL specifying the <code>JOIN</code> clause to
<code>joins</code>:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">joins</span>(<span class="ruby-string">&#39;LEFT OUTER JOIN addresses ON addresses.client_id = clients.id&#39;</span>)
</pre>

<p>This will result in the following SQL:</p>

<pre class="ruby"><span class="ruby-constant">SELECT</span> <span class="ruby-identifier">clients</span>.<span class="ruby-operator">*</span> <span class="ruby-constant">FROM</span> <span class="ruby-identifier">clients</span> <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">addresses</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">addresses</span>.<span class="ruby-identifier">client_id</span> = <span class="ruby-identifier">clients</span>.<span class="ruby-identifier">id</span>
</pre>

<h3 id="label-Using+Array-2FHash+of+Named+Associations">Using Array/Hash of Named Associations<span><a href="#label-Using+Array-2FHash+of+Named+Associations">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>WARNING: This method only works with <code>INNER JOIN</code>.</p>

<p>Active Record lets you use the names of the <a
href="association_basics.html">associations</a> defined on the model as a
shortcut for specifying <code>JOIN</code> clauses for those associations
when using the <code>joins</code> method.</p>

<p>For example, consider the following <code>Category</code>,
<code>Article</code>, <code>Comment</code>, <code>Guest</code> and
<code>Tag</code> models:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Category</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">articles</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Article</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">category</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">comments</span>
  <span class="ruby-identifier">has_many</span> :<span class="ruby-identifier">tags</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Comment</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">article</span>
  <span class="ruby-identifier">has_one</span> :<span class="ruby-identifier">guest</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Guest</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">comment</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">Tag</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">belongs_to</span> :<span class="ruby-identifier">article</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Now all of the following will produce the expected join queries using
<code>INNER JOIN</code>:</p>

<h4 id="label-Joining+a+Single+Association">Joining a Single Association<span><a href="#label-Joining+a+Single+Association">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Category</span>.<span class="ruby-identifier">joins</span>(:<span class="ruby-identifier">articles</span>)
</pre>

<p>This produces:</p>

<pre class="ruby"><span class="ruby-constant">SELECT</span> <span class="ruby-identifier">categories</span>.<span class="ruby-operator">*</span> <span class="ruby-constant">FROM</span> <span class="ruby-identifier">categories</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">articles</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">articles</span>.<span class="ruby-identifier">category_id</span> = <span class="ruby-identifier">categories</span>.<span class="ruby-identifier">id</span>
</pre>

<p>Or, in English: “return a Category object for all categories with
articles”. Note that you will see duplicate categories if more than one
article has the same category. If you want unique categories, you can use
<code>Category.joins(:articles).uniq</code>.</p>

<h4 id="label-Joining+Multiple+Associations">Joining Multiple Associations<span><a href="#label-Joining+Multiple+Associations">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">joins</span>(:<span class="ruby-identifier">category</span>, :<span class="ruby-identifier">comments</span>)
</pre>

<p>This produces:</p>

<pre class="ruby"><span class="ruby-constant">SELECT</span> <span class="ruby-identifier">articles</span>.<span class="ruby-operator">*</span> <span class="ruby-constant">FROM</span> <span class="ruby-identifier">articles</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">categories</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">articles</span>.<span class="ruby-identifier">category_id</span> = <span class="ruby-identifier">categories</span>.<span class="ruby-identifier">id</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">comments</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">comments</span>.<span class="ruby-identifier">article_id</span> = <span class="ruby-identifier">articles</span>.<span class="ruby-identifier">id</span>
</pre>

<p>Or, in English: “return all articles that have a category and at least one
comment”. Note again that articles with multiple comments will show up
multiple times.</p>

<h4 id="label-Joining+Nested+Associations+-28Single+Level-29">Joining Nested Associations (Single Level)<span><a href="#label-Joining+Nested+Associations+-28Single+Level-29">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">joins</span>(<span class="ruby-identifier">comments</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">guest</span>)
</pre>

<p>This produces:</p>

<pre class="ruby"><span class="ruby-constant">SELECT</span> <span class="ruby-identifier">articles</span>.<span class="ruby-operator">*</span> <span class="ruby-constant">FROM</span> <span class="ruby-identifier">articles</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">comments</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">comments</span>.<span class="ruby-identifier">article_id</span> = <span class="ruby-identifier">articles</span>.<span class="ruby-identifier">id</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">guests</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">guests</span>.<span class="ruby-identifier">comment_id</span> = <span class="ruby-identifier">comments</span>.<span class="ruby-identifier">id</span>
</pre>

<p>Or, in English: “return all articles that have a comment made by a guest.”</p>

<h4 id="label-Joining+Nested+Associations+-28Multiple+Level-29">Joining Nested Associations (Multiple Level)<span><a href="#label-Joining+Nested+Associations+-28Multiple+Level-29">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Category</span>.<span class="ruby-identifier">joins</span>(<span class="ruby-identifier">articles</span><span class="ruby-operator">:</span> [{ <span class="ruby-identifier">comments</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">guest</span> }, :<span class="ruby-identifier">tags</span>])
</pre>

<p>This produces:</p>

<pre class="ruby"><span class="ruby-constant">SELECT</span> <span class="ruby-identifier">categories</span>.<span class="ruby-operator">*</span> <span class="ruby-constant">FROM</span> <span class="ruby-identifier">categories</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">articles</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">articles</span>.<span class="ruby-identifier">category_id</span> = <span class="ruby-identifier">categories</span>.<span class="ruby-identifier">id</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">comments</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">comments</span>.<span class="ruby-identifier">article_id</span> = <span class="ruby-identifier">articles</span>.<span class="ruby-identifier">id</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">guests</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">guests</span>.<span class="ruby-identifier">comment_id</span> = <span class="ruby-identifier">comments</span>.<span class="ruby-identifier">id</span>
  <span class="ruby-constant">INNER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-identifier">tags</span> <span class="ruby-constant">ON</span> <span class="ruby-identifier">tags</span>.<span class="ruby-identifier">article_id</span> = <span class="ruby-identifier">articles</span>.<span class="ruby-identifier">id</span>
</pre>

<h3 id="label-Specifying+Conditions+on+the+Joined+Tables">Specifying Conditions on the Joined Tables<span><a href="#label-Specifying+Conditions+on+the+Joined+Tables">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can specify conditions on the joined tables using the regular <a
href="#array-conditions">Array</a> and <a
href="#pure-string-conditions">String</a> conditions. <a
href="#hash-conditions">Hash conditions</a> provides a special syntax for
specifying conditions for the joined tables:</p>

<pre class="ruby"><span class="ruby-identifier">time_range</span> = (<span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">midnight</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">day</span>)<span class="ruby-operator">..</span><span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">midnight</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">joins</span>(:<span class="ruby-identifier">orders</span>).<span class="ruby-identifier">where</span>(<span class="ruby-string">&#39;orders.created_at&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">time_range</span>)
</pre>

<p>An alternative and cleaner syntax is to nest the hash conditions:</p>

<pre class="ruby"><span class="ruby-identifier">time_range</span> = (<span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">midnight</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">day</span>)<span class="ruby-operator">..</span><span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">midnight</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">joins</span>(:<span class="ruby-identifier">orders</span>).<span class="ruby-identifier">where</span>(<span class="ruby-identifier">orders</span><span class="ruby-operator">:</span> { <span class="ruby-identifier">created_at</span><span class="ruby-operator">:</span> <span class="ruby-identifier">time_range</span> })
</pre>

<p>This will find all clients who have orders that were created yesterday,
again using a <code>BETWEEN</code> SQL expression.</p>

<h2 id="label-Eager+Loading+Associations">Eager Loading Associations<span><a href="#label-Eager+Loading+Associations">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Eager loading is the mechanism for loading the associated records of the
objects returned by <code>Model.find</code> using as few queries as
possible.</p>

<p><strong>N + 1 queries problem</strong></p>

<p>Consider the following code, which finds 10 clients and prints their
postcodes:</p>

<pre class="ruby"><span class="ruby-identifier">clients</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-value">10</span>)

<span class="ruby-identifier">clients</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">client</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-identifier">client</span>.<span class="ruby-identifier">address</span>.<span class="ruby-identifier">postcode</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This code looks fine at the first sight. But the problem lies within the
total number of queries executed. The above code executes 1 (to find 10
clients) + 10 (one per each client to load the address) =
<strong>11</strong> queries in total.</p>

<p><strong>Solution to N + 1 queries problem</strong></p>

<p>Active Record lets you specify in advance all the associations that are
going to be loaded. This is possible by specifying the
<code>includes</code> method of the <code>Model.find</code> call. With
<code>includes</code>, Active Record ensures that all of the specified
associations are loaded using the minimum possible number of queries.</p>

<p>Revisiting the above case, we could rewrite <code>Client.limit(10)</code>
to use eager load addresses:</p>

<pre class="ruby"><span class="ruby-identifier">clients</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">includes</span>(:<span class="ruby-identifier">address</span>).<span class="ruby-identifier">limit</span>(<span class="ruby-value">10</span>)

<span class="ruby-identifier">clients</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">client</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-identifier">client</span>.<span class="ruby-identifier">address</span>.<span class="ruby-identifier">postcode</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The above code will execute just <strong>2</strong> queries, as opposed to
<strong>11</strong> queries in the previous case:</p>

<pre>SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))</pre>

<h3 id="label-Eager+Loading+Multiple+Associations">Eager Loading Multiple Associations<span><a href="#label-Eager+Loading+Multiple+Associations">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Active Record lets you eager load any number of associations with a single
<code>Model.find</code> call by using an array, hash, or a nested hash of
array/hash with the <code>includes</code> method.</p>

<h4 id="label-Array+of+Multiple+Associations">Array of Multiple Associations<span><a href="#label-Array+of+Multiple+Associations">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">includes</span>(:<span class="ruby-identifier">category</span>, :<span class="ruby-identifier">comments</span>)
</pre>

<p>This loads all the articles and the associated category and comments for
each article.</p>

<h4 id="label-Nested+Associations+Hash">Nested Associations Hash<span><a href="#label-Nested+Associations+Hash">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">Category</span>.<span class="ruby-identifier">includes</span>(<span class="ruby-identifier">articles</span><span class="ruby-operator">:</span> [{ <span class="ruby-identifier">comments</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">guest</span> }, :<span class="ruby-identifier">tags</span>]).<span class="ruby-identifier">find</span>(<span class="ruby-value">1</span>)
</pre>

<p>This will find the category with id 1 and eager load all of the associated
articles, the associated articles&#39; tags and comments, and every
comment&#39;s guest association.</p>

<h3 id="label-Specifying+Conditions+on+Eager+Loaded+Associations">Specifying Conditions on Eager Loaded Associations<span><a href="#label-Specifying+Conditions+on+Eager+Loaded+Associations">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Even though Active Record lets you specify conditions on the eager loaded
associations just like <code>joins</code>, the recommended way is to use <a
href="#joining-tables">joins</a> instead.</p>

<p>However if you must do this, you may use <code>where</code> as you would
normally.</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">includes</span>(:<span class="ruby-identifier">comments</span>).<span class="ruby-identifier">where</span>(<span class="ruby-identifier">comments</span><span class="ruby-operator">:</span> { <span class="ruby-identifier">visible</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span> })
</pre>

<p>This would generate a query which contains a <code>LEFT OUTER JOIN</code>
whereas the <code>joins</code> method would generate one using the
<code>INNER JOIN</code> function instead.</p>

<pre class="ruby"><span class="ruby-constant">SELECT</span> <span class="ruby-string">&quot;articles&quot;</span>.<span class="ruby-string">&quot;id&quot;</span> <span class="ruby-constant">AS</span> <span class="ruby-identifier">t0_r0</span>, <span class="ruby-operator">...</span> <span class="ruby-string">&quot;comments&quot;</span>.<span class="ruby-string">&quot;updated_at&quot;</span> <span class="ruby-constant">AS</span> <span class="ruby-identifier">t1_r5</span> <span class="ruby-constant">FROM</span> <span class="ruby-string">&quot;articles&quot;</span> <span class="ruby-constant">LEFT</span> <span class="ruby-constant">OUTER</span> <span class="ruby-constant">JOIN</span> <span class="ruby-string">&quot;comments&quot;</span> <span class="ruby-constant">ON</span> <span class="ruby-string">&quot;comments&quot;</span>.<span class="ruby-string">&quot;article_id&quot;</span> = <span class="ruby-string">&quot;articles&quot;</span>.<span class="ruby-string">&quot;id&quot;</span> <span class="ruby-constant">WHERE</span> (<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">visible</span> = <span class="ruby-value">1</span>)
</pre>

<p>If there was no <code>where</code> condition, this would generate the
normal set of two queries.</p>

<p>NOTE: Using <code>where</code> like this will only work when you pass it a
Hash. For SQL-fragments you need use <code>references</code> to force
joined tables:</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">includes</span>(:<span class="ruby-identifier">comments</span>).<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;comments.visible = true&quot;</span>).<span class="ruby-identifier">references</span>(:<span class="ruby-identifier">comments</span>)
</pre>

<p>If, in the case of this <code>includes</code> query, there were no comments
for any articles, all the articles would still be loaded. By using
<code>joins</code> (an INNER JOIN), the join conditions
<strong>must</strong> match, otherwise no records will be returned.</p>

<h2 id="label-Scopes">Scopes<span><a href="#label-Scopes">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Scoping allows you to specify commonly-used queries which can be referenced
as method calls on the association objects or models. With these scopes,
you can use every method previously covered such as <code>where</code>,
<code>joins</code> and <code>includes</code>. All scope methods will return
an <code>ActiveRecord::Relation</code> object which will allow for further
methods (such as other scopes) to be called on it.</p>

<p>To define a simple scope, we use the <code>scope</code> method inside the
class, passing the query that we&#39;d like to run when this scope is
called:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Article</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">scope</span> :<span class="ruby-identifier">published</span>, <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-identifier">where</span>(<span class="ruby-identifier">published</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>) }
<span class="ruby-keyword">end</span>
</pre>

<p>This is exactly the same as defining a class method, and which you use is a
matter of personal preference:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Article</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">published</span>
    <span class="ruby-identifier">where</span>(<span class="ruby-identifier">published</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Scopes are also chainable within scopes:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Article</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">scope</span> :<span class="ruby-identifier">published</span>,               <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-identifier">where</span>(<span class="ruby-identifier">published</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>) }
  <span class="ruby-identifier">scope</span> :<span class="ruby-identifier">published_and_commented</span>, <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-identifier">published</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;comments_count &gt; 0&quot;</span>) }
<span class="ruby-keyword">end</span>
</pre>

<p>To call this <code>published</code> scope we can call it on either the
class:</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">published</span> <span class="ruby-comment"># =&gt; [published articles]</span>
</pre>

<p>Or on an association consisting of <code>Article</code> objects:</p>

<pre class="ruby"><span class="ruby-identifier">category</span> = <span class="ruby-constant">Category</span>.<span class="ruby-identifier">first</span>
<span class="ruby-identifier">category</span>.<span class="ruby-identifier">articles</span>.<span class="ruby-identifier">published</span> <span class="ruby-comment"># =&gt; [published articles belonging to this category]</span>
</pre>

<h3 id="label-Passing+in+arguments">Passing in arguments<span><a href="#label-Passing+in+arguments">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Your scope can take arguments:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Article</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">scope</span> :<span class="ruby-identifier">created_before</span>, <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">time</span>) { <span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;created_at &lt; ?&quot;</span>, <span class="ruby-identifier">time</span>) }
<span class="ruby-keyword">end</span>
</pre>

<p>Call the scope as if it were a class method:</p>

<pre class="ruby"><span class="ruby-constant">Article</span>.<span class="ruby-identifier">created_before</span>(<span class="ruby-constant">Time</span>.<span class="ruby-identifier">zone</span>.<span class="ruby-identifier">now</span>)
</pre>

<p>However, this is just duplicating the functionality that would be provided
to you by a class method.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Article</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">created_before</span>(<span class="ruby-identifier">time</span>)
    <span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;created_at &lt; ?&quot;</span>, <span class="ruby-identifier">time</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Using a class method is the preferred way to accept arguments for scopes.
These methods will still be accessible on the association objects:</p>

<pre class="ruby"><span class="ruby-identifier">category</span>.<span class="ruby-identifier">articles</span>.<span class="ruby-identifier">created_before</span>(<span class="ruby-identifier">time</span>)
</pre>

<h3 id="label-Applying+a+default+scope">Applying a default scope<span><a href="#label-Applying+a+default+scope">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If we wish for a scope to be applied across all queries to the model we can
use the <code>default_scope</code> method within the model itself.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">default_scope</span> { <span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;removed_at IS NULL&quot;</span>) }
<span class="ruby-keyword">end</span>
</pre>

<p>When queries are executed on this model, the SQL query will now look
something like this:</p>

<pre>SELECT * FROM clients WHERE removed_at IS NULL</pre>

<p>If you need to do more complex things with a default scope, you can
alternatively define it as a class method:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_scope</span>
    <span class="ruby-comment"># Should return an ActiveRecord::Relation.</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Merging+of+scopes">Merging of scopes<span><a href="#label-Merging+of+scopes">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Just like <code>where</code> clauses scopes are merged using
<code>AND</code> conditions.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">User</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">scope</span> :<span class="ruby-identifier">active</span>, <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-identifier">where</span> <span class="ruby-identifier">state</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;active&#39;</span> }
  <span class="ruby-identifier">scope</span> :<span class="ruby-identifier">inactive</span>, <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-identifier">where</span> <span class="ruby-identifier">state</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;inactive&#39;</span> }
<span class="ruby-keyword">end</span>

<span class="ruby-constant">User</span>.<span class="ruby-identifier">active</span>.<span class="ruby-identifier">inactive</span>
<span class="ruby-comment"># SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;state&quot; = &#39;active&#39; AND &quot;users&quot;.&quot;state&quot; = &#39;inactive&#39;</span>
</pre>

<p>We can mix and match <code>scope</code> and <code>where</code> conditions
and the final sql will have all conditions joined with <code>AND</code>.</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">active</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">state</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;finished&#39;</span>)
<span class="ruby-comment"># SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;state&quot; = &#39;active&#39; AND &quot;users&quot;.&quot;state&quot; = &#39;finished&#39;</span>
</pre>

<p>If we do want the <code>last where clause</code> to win then
<code>Relation#merge</code> can be used.</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">active</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-constant">User</span>.<span class="ruby-identifier">inactive</span>)
<span class="ruby-comment"># SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;state&quot; = &#39;inactive&#39;</span>
</pre>

<p>One important caveat is that <code>default_scope</code> will be prepended
in <code>scope</code> and <code>where</code> conditions.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">User</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-identifier">default_scope</span> { <span class="ruby-identifier">where</span> <span class="ruby-identifier">state</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;pending&#39;</span> }
  <span class="ruby-identifier">scope</span> :<span class="ruby-identifier">active</span>, <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-identifier">where</span> <span class="ruby-identifier">state</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;active&#39;</span> }
  <span class="ruby-identifier">scope</span> :<span class="ruby-identifier">inactive</span>, <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-identifier">where</span> <span class="ruby-identifier">state</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;inactive&#39;</span> }
<span class="ruby-keyword">end</span>

<span class="ruby-constant">User</span>.<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;state&quot; = &#39;pending&#39;</span>

<span class="ruby-constant">User</span>.<span class="ruby-identifier">active</span>
<span class="ruby-comment"># SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;state&quot; = &#39;pending&#39; AND &quot;users&quot;.&quot;state&quot; = &#39;active&#39;</span>

<span class="ruby-constant">User</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">state</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;inactive&#39;</span>)
<span class="ruby-comment"># SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;state&quot; = &#39;pending&#39; AND &quot;users&quot;.&quot;state&quot; = &#39;inactive&#39;</span>
</pre>

<p>As you can see above the <code>default_scope</code> is being merged in both
<code>scope</code> and <code>where</code> conditions.</p>

<h3 id="label-Removing+All+Scoping">Removing All Scoping<span><a href="#label-Removing+All+Scoping">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If we wish to remove scoping for any reason we can use the
<code>unscoped</code> method. This is especially useful if a
<code>default_scope</code> is specified in the model and should not be
applied for this particular query.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">unscoped</span>.<span class="ruby-identifier">load</span>
</pre>

<p>This method removes all scoping and will do a normal query on the table.</p>

<p>Note that chaining <code>unscoped</code> with a <code>scope</code> does not
work. In these cases, it is recommended that you use the block form of
<code>unscoped</code>:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">unscoped</span> {
  <span class="ruby-constant">Client</span>.<span class="ruby-identifier">created_before</span>(<span class="ruby-constant">Time</span>.<span class="ruby-identifier">zone</span>.<span class="ruby-identifier">now</span>)
}
</pre>

<h2 id="label-Dynamic+Finders">Dynamic Finders<span><a href="#label-Dynamic+Finders">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>For every field (also known as an attribute) you define in your table,
Active Record provides a finder method. If you have a field called
<code>first_name</code> on your <code>Client</code> model for example, you
get <code>find_by_first_name</code> for free from Active Record. If you
have a <code>locked</code> field on the <code>Client</code> model, you also
get <code>find_by_locked</code> and methods.</p>

<p>You can specify an exclamation point (<code>!</code>) on the end of the
dynamic finders to get them to raise an
<code>ActiveRecord::RecordNotFound</code> error if they do not return any
records, like <code>Client.find_by_name!(&quot;Ryan&quot;)</code></p>

<p>If you want to find both by name and locked, you can chain these finders
together by simply typing “<code>and</code>” between the fields. For
example, <code>Client.find_by_first_name_and_locked(&quot;Ryan&quot;,
true)</code>.</p>

<h2 id="label-Find+or+Build+a+New+Object">Find or Build a New <a href="../../Object.html">Object</a><span><a href="#label-Find+or+Build+a+New+Object">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>NOTE: Some dynamic finders have been deprecated in Rails 4.0 and will be
removed in Rails 4.1. The best practice is to use Active Record scopes
instead. You can find the deprecation gem at <a
href="https://github.com/rails/activerecord-deprecated_finders">github.com/rails/activerecord-deprecated_finders</a></p>

<p>It&#39;s common that you need to find a record or create it if it
doesn&#39;t exist. You can do that with the <code>find_or_create_by</code>
and <code>find_or_create_by!</code> methods.</p>

<h3 id="label-find_or_create_by"><code>find_or_create_by</code><span><a href="#label-find_or_create_by">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <code>find_or_create_by</code> method checks whether a record with the
attributes exists. If it doesn&#39;t, then <code>create</code> is called.
Let&#39;s see an example.</p>

<p>Suppose you want to find a client named &#39;Andy&#39;, and if there&#39;s
none, create one. You can do so by running:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">find_or_create_by</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Andy&#39;</span>)
<span class="ruby-comment"># =&gt; #&lt;Client id: 1, first_name: &quot;Andy&quot;, orders_count: 0, locked: true, created_at: &quot;2011-08-30 06:09:27&quot;, updated_at: &quot;2011-08-30 06:09:27&quot;&gt;</span>
</pre>

<p>The SQL generated by this method looks like this:</p>

<pre>SELECT * FROM clients WHERE (clients.first_name = &#39;Andy&#39;) LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES (&#39;2011-08-30 05:22:57&#39;, &#39;Andy&#39;, 1, NULL, &#39;2011-08-30 05:22:57&#39;)
COMMIT</pre>

<p><code>find_or_create_by</code> returns either the record that already
exists or the new record. In our case, we didn&#39;t already have a client
named Andy so the record is created and returned.</p>

<p>The new record might not be saved to the database; that depends on whether
validations passed or not (just like <code>create</code>).</p>

<p>Suppose we want to set the &#39;locked&#39; attribute to <code>false</code>
if we&#39;re creating a new record, but we don&#39;t want to include it in
the query. So we want to find the client named “Andy”, or if that client
doesn&#39;t exist, create a client named “Andy” which is not locked.</p>

<p>We can achieve this in two ways. The first is to use
<code>create_with</code>:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">create_with</span>(<span class="ruby-identifier">locked</span><span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>).<span class="ruby-identifier">find_or_create_by</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Andy&#39;</span>)
</pre>

<p>The second way is using a block:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">find_or_create_by</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Andy&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">c</span>.<span class="ruby-identifier">locked</span> = <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The block will only be executed if the client is being created. The second
time we run this code, the block will be ignored.</p>

<h3 id="label-find_or_create_by-21"><code>find_or_create_by!</code><span><a href="#label-find_or_create_by-21">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can also use <code>find_or_create_by!</code> to raise an exception if
the new record is invalid. Validations are not covered on this guide, but
let&#39;s assume for a moment that you temporarily add</p>

<pre class="ruby"><span class="ruby-identifier">validates</span> :<span class="ruby-identifier">orders_count</span>, <span class="ruby-identifier">presence</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
</pre>

<p>to your <code>Client</code> model. If you try to create a new
<code>Client</code> without passing an <code>orders_count</code>, the
record will be invalid and an exception will be raised:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">find_or_create_by!</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Andy&#39;</span>)
<span class="ruby-comment"># =&gt; ActiveRecord::RecordInvalid: Validation failed: Orders count can&#39;t be blank</span>
</pre>

<h3 id="label-find_or_initialize_by"><code>find_or_initialize_by</code><span><a href="#label-find_or_initialize_by">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <code>find_or_initialize_by</code> method will work just like
<code>find_or_create_by</code> but it will call <code>new</code> instead of
<code>create</code>. This means that a new model instance will be created
in memory but won&#39;t be saved to the database. Continuing with the
<code>find_or_create_by</code> example, we now want the client named
&#39;Nick&#39;:</p>

<pre class="ruby"><span class="ruby-identifier">nick</span> = <span class="ruby-constant">Client</span>.<span class="ruby-identifier">find_or_initialize_by</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Nick&#39;</span>)
<span class="ruby-comment"># =&gt; &lt;Client id: nil, first_name: &quot;Nick&quot;, orders_count: 0, locked: true, created_at: &quot;2011-08-30 06:09:27&quot;, updated_at: &quot;2011-08-30 06:09:27&quot;&gt;</span>

<span class="ruby-identifier">nick</span>.<span class="ruby-identifier">persisted?</span>
<span class="ruby-comment"># =&gt; false</span>

<span class="ruby-identifier">nick</span>.<span class="ruby-identifier">new_record?</span>
<span class="ruby-comment"># =&gt; true</span>
</pre>

<p>Because the object is not yet stored in the database, the SQL generated
looks like this:</p>

<pre>SELECT * FROM clients WHERE (clients.first_name = &#39;Nick&#39;) LIMIT 1</pre>

<p>When you want to save it to the database, just call <code>save</code>:</p>

<pre class="ruby"><span class="ruby-identifier">nick</span>.<span class="ruby-identifier">save</span>
<span class="ruby-comment"># =&gt; true</span>
</pre>

<h2 id="label-Finding+by+SQL">Finding by SQL<span><a href="#label-Finding+by+SQL">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you&#39;d like to use your own SQL to find records in a table you can
use <code>find_by_sql</code>. The <code>find_by_sql</code> method will
return an array of objects even if the underlying query returns just a
single record. For example you could run this query:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">find_by_sql</span>(<span class="ruby-string">&quot;SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc&quot;</span>)
<span class="ruby-comment"># =&gt;  [</span>
  <span class="ruby-comment">#&lt;Client id: 1, first_name: &quot;Lucas&quot; &gt;,</span>
  <span class="ruby-comment">#&lt;Client id: 2, first_name: &quot;Jan&quot; &gt;,</span>
  <span class="ruby-comment"># ...</span>
]
</pre>

<p><code>find_by_sql</code> provides you with a simple way of making custom
calls to the database and retrieving instantiated objects.</p>

<h3 id="label-select_all"><code>select_all</code><span><a href="#label-select_all">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><code>find_by_sql</code> has a close relative called
<code>connection#select_all</code>. <code>select_all</code> will retrieve
objects from the database using custom SQL just like
<code>find_by_sql</code> but will not instantiate them. Instead, you will
get an array of hashes where each hash indicates a record.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">select_all</span>(<span class="ruby-string">&quot;SELECT first_name, created_at FROM clients WHERE id = &#39;1&#39;&quot;</span>)
<span class="ruby-comment"># =&gt; [</span>
  {<span class="ruby-string">&quot;first_name&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;Rafael&quot;</span>, <span class="ruby-string">&quot;created_at&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;2012-11-10 23:23:45.281189&quot;</span>},
  {<span class="ruby-string">&quot;first_name&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;Eileen&quot;</span>, <span class="ruby-string">&quot;created_at&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;2013-12-09 11:22:35.221282&quot;</span>}
]
</pre>

<h3 id="label-pluck"><code>pluck</code><span><a href="#label-pluck">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><code>pluck</code> can be used to query single or multiple columns from the
underlying table of a model. It accepts a list of column names as argument
and returns an array of values of the specified columns with the
corresponding data type.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">active</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>).<span class="ruby-identifier">pluck</span>(:<span class="ruby-identifier">id</span>)
<span class="ruby-comment"># SELECT id FROM clients WHERE active = 1</span>
<span class="ruby-comment"># =&gt; [1, 2, 3]</span>

<span class="ruby-constant">Client</span>.<span class="ruby-identifier">distinct</span>.<span class="ruby-identifier">pluck</span>(:<span class="ruby-identifier">role</span>)
<span class="ruby-comment"># SELECT DISTINCT role FROM clients</span>
<span class="ruby-comment"># =&gt; [&#39;admin&#39;, &#39;member&#39;, &#39;guest&#39;]</span>

<span class="ruby-constant">Client</span>.<span class="ruby-identifier">pluck</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>)
<span class="ruby-comment"># SELECT clients.id, clients.name FROM clients</span>
<span class="ruby-comment"># =&gt; [[1, &#39;David&#39;], [2, &#39;Jeremy&#39;], [3, &#39;Jose&#39;]]</span>
</pre>

<p><code>pluck</code> makes it possible to replace code like:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">id</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">id</span> }
<span class="ruby-comment"># or</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">id</span>).<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span>:<span class="ruby-identifier">id</span>)
<span class="ruby-comment"># or</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">c</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">c</span>.<span class="ruby-identifier">name</span>] }
</pre>

<p>with:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">pluck</span>(:<span class="ruby-identifier">id</span>)
<span class="ruby-comment"># or</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">pluck</span>(:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>)
</pre>

<p>Unlike <code>select</code>, <code>pluck</code> directly converts a database
result into a Ruby <code>Array</code>, without constructing
<code>ActiveRecord</code> objects. This can mean better performance for a
large or often-running query. However, any model method overrides will not
be available. For example:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Client</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">name</span>
    <span class="ruby-node">&quot;I am #{super}&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">Client</span>.<span class="ruby-identifier">select</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">map</span> <span class="ruby-operator">&amp;</span>:<span class="ruby-identifier">name</span>
<span class="ruby-comment"># =&gt; [&quot;I am David&quot;, &quot;I am Jeremy&quot;, &quot;I am Jose&quot;]</span>

<span class="ruby-constant">Client</span>.<span class="ruby-identifier">pluck</span>(:<span class="ruby-identifier">name</span>)
<span class="ruby-comment"># =&gt; [&quot;David&quot;, &quot;Jeremy&quot;, &quot;Jose&quot;]</span>
</pre>

<p>Furthermore, unlike <code>select</code> and other <code>Relation</code>
scopes, <code>pluck</code> triggers an immediate query, and thus cannot be
chained with any further scopes, although it can work with scopes already
constructed earlier:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">pluck</span>(:<span class="ruby-identifier">name</span>).<span class="ruby-identifier">limit</span>(<span class="ruby-value">1</span>)
<span class="ruby-comment"># =&gt; NoMethodError: undefined method `limit&#39; for #&lt;Array:0x007ff34d3ad6d8&gt;</span>

<span class="ruby-constant">Client</span>.<span class="ruby-identifier">limit</span>(<span class="ruby-value">1</span>).<span class="ruby-identifier">pluck</span>(:<span class="ruby-identifier">name</span>)
<span class="ruby-comment"># =&gt; [&quot;David&quot;]</span>
</pre>

<h3 id="label-ids"><code>ids</code><span><a href="#label-ids">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><code>ids</code> can be used to pluck all the IDs for the relation using
the table&#39;s primary key.</p>

<pre class="ruby"><span class="ruby-constant">Person</span>.<span class="ruby-identifier">ids</span>
<span class="ruby-comment"># SELECT id FROM people</span>
</pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Person</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">primary_key</span> = <span class="ruby-string">&quot;person_id&quot;</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">Person</span>.<span class="ruby-identifier">ids</span>
<span class="ruby-comment"># SELECT person_id FROM people</span>
</pre>

<h2 id="label-Existence+of+Objects">Existence of Objects<span><a href="#label-Existence+of+Objects">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you simply want to check for the existence of the object there&#39;s a
method called <code>exists?</code>. This method will query the database
using the same query as <code>find</code>, but instead of returning an
object or collection of objects it will return either <code>true</code> or
<code>false</code>.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-value">1</span>)
</pre>

<p>The <code>exists?</code> method also takes multiple values, but the catch
is that it will return <code>true</code> if any one of those records
exists.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">id</span><span class="ruby-operator">:</span> [<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>])
<span class="ruby-comment"># or</span>
<span class="ruby-constant">Client</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">name</span><span class="ruby-operator">:</span> [<span class="ruby-string">&#39;John&#39;</span>, <span class="ruby-string">&#39;Sergei&#39;</span>])
</pre>

<p>It&#39;s even possible to use <code>exists?</code> without any arguments on
a model or a relation.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Ryan&#39;</span>).<span class="ruby-identifier">exists?</span>
</pre>

<p>The above returns <code>true</code> if there is at least one client with
the <code>first_name</code> &#39;Ryan&#39; and <code>false</code>
otherwise.</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">exists?</span>
</pre>

<p>The above returns <code>false</code> if the <code>clients</code> table is
empty and <code>true</code> otherwise.</p>

<p>You can also use <code>any?</code> and <code>many?</code> to check for
existence on a model or relation.</p>

<pre class="ruby"><span class="ruby-comment"># via a model</span>
<span class="ruby-constant">Article</span>.<span class="ruby-identifier">any?</span>
<span class="ruby-constant">Article</span>.<span class="ruby-identifier">many?</span>

<span class="ruby-comment"># via a named scope</span>
<span class="ruby-constant">Article</span>.<span class="ruby-identifier">recent</span>.<span class="ruby-identifier">any?</span>
<span class="ruby-constant">Article</span>.<span class="ruby-identifier">recent</span>.<span class="ruby-identifier">many?</span>

<span class="ruby-comment"># via a relation</span>
<span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">published</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>).<span class="ruby-identifier">any?</span>
<span class="ruby-constant">Article</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">published</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>).<span class="ruby-identifier">many?</span>

<span class="ruby-comment"># via an association</span>
<span class="ruby-constant">Article</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">categories</span>.<span class="ruby-identifier">any?</span>
<span class="ruby-constant">Article</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">categories</span>.<span class="ruby-identifier">many?</span>
</pre>

<h2 id="label-Calculations">Calculations<span><a href="#label-Calculations">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This section uses count as an example method in this preamble, but the
options described apply to all sub-sections.</p>

<p>All calculation methods work directly on a model:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">count</span>
<span class="ruby-comment"># SELECT count(*) AS count_all FROM clients</span>
</pre>

<p>Or on a relation:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Ryan&#39;</span>).<span class="ruby-identifier">count</span>
<span class="ruby-comment"># SELECT count(*) AS count_all FROM clients WHERE (first_name = &#39;Ryan&#39;)</span>
</pre>

<p>You can also use various finder methods on a relation for performing
complex calculations:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">includes</span>(<span class="ruby-string">&quot;orders&quot;</span>).<span class="ruby-identifier">where</span>(<span class="ruby-identifier">first_name</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;Ryan&#39;</span>, <span class="ruby-identifier">orders</span><span class="ruby-operator">:</span> { <span class="ruby-identifier">status</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;received&#39;</span> }).<span class="ruby-identifier">count</span>
</pre>

<p>Which will execute:</p>

<pre>SELECT count(DISTINCT clients.id) AS count_all FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = client.id WHERE
  (clients.first_name = &#39;Ryan&#39; AND orders.status = &#39;received&#39;)</pre>

<h3 id="label-Count">Count<span><a href="#label-Count">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you want to see how many records are in your model&#39;s table you could
call <code>Client.count</code> and that will return the number. If you want
to be more specific and find all the clients with their age present in the
database you can use <code>Client.count(:age)</code>.</p>

<p>For options, please see the parent section, <a
href="#calculations">Calculations</a>.</p>

<h3 id="label-Average">Average<span><a href="#label-Average">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you want to see the average of a certain number in one of your tables
you can call the <code>average</code> method on the class that relates to
the table. This method call will look something like this:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">average</span>(<span class="ruby-string">&quot;orders_count&quot;</span>)
</pre>

<p>This will return a number (possibly a floating point number such as
3.14159265) representing the average value in the field.</p>

<p>For options, please see the parent section, <a
href="#calculations">Calculations</a>.</p>

<h3 id="label-Minimum">Minimum<span><a href="#label-Minimum">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you want to find the minimum value of a field in your table you can call
the <code>minimum</code> method on the class that relates to the table.
This method call will look something like this:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">minimum</span>(<span class="ruby-string">&quot;age&quot;</span>)
</pre>

<p>For options, please see the parent section, <a
href="#calculations">Calculations</a>.</p>

<h3 id="label-Maximum">Maximum<span><a href="#label-Maximum">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you want to find the maximum value of a field in your table you can call
the <code>maximum</code> method on the class that relates to the table.
This method call will look something like this:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">maximum</span>(<span class="ruby-string">&quot;age&quot;</span>)
</pre>

<p>For options, please see the parent section, <a
href="#calculations">Calculations</a>.</p>

<h3 id="label-Sum">Sum<span><a href="#label-Sum">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you want to find the sum of a field for all records in your table you
can call the <code>sum</code> method on the class that relates to the
table. This method call will look something like this:</p>

<pre class="ruby"><span class="ruby-constant">Client</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-string">&quot;orders_count&quot;</span>)
</pre>

<p>For options, please see the parent section, <a
href="#calculations">Calculations</a>.</p>

<h2 id="label-Running+EXPLAIN">Running EXPLAIN<span><a href="#label-Running+EXPLAIN">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can run EXPLAIN on the queries triggered by relations. For example,</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">id</span><span class="ruby-operator">:</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">joins</span>(:<span class="ruby-identifier">articles</span>).<span class="ruby-identifier">explain</span>
</pre>

<p>may yield</p>

<pre>EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table    | type  | possible_keys |
+----+-------------+----------+-------+---------------+
|  1 | SIMPLE      | users    | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL   | NULL          |
+----+-------------+----------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)</pre>

<p>under MySQL.</p>

<p>Active Record performs a pretty printing that emulates the one of the
database shells. So, the same query running with the PostgreSQL adapter
would yield instead</p>

<pre>EXPLAIN for: SELECT &quot;users&quot;.* FROM &quot;users&quot; INNER JOIN &quot;articles&quot; ON &quot;articles&quot;.&quot;user_id&quot; = &quot;users&quot;.&quot;id&quot; WHERE &quot;users&quot;.&quot;id&quot; = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (articles.user_id = users.id)
   -&gt;  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   -&gt;  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
         Filter: (articles.user_id = 1)
(6 rows)</pre>

<p>Eager loading may trigger more than one query under the hood, and some
queries may need the results of previous ones. Because of that,
<code>explain</code> actually executes the query, and then asks for the
query plans. For example,</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">id</span><span class="ruby-operator">:</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">includes</span>(:<span class="ruby-identifier">articles</span>).<span class="ruby-identifier">explain</span>
</pre>

<p>yields</p>

<pre>EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
+----+-------------+-------+-------+---------------+
|  1 | SIMPLE      | users | const | PRIMARY       |
+----+-------------+-------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `articles`.* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
+----+-------------+----------+------+---------------+
|  1 | SIMPLE      | articles | ALL  | NULL          |
+----+-------------+----------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)</pre>

<p>under MySQL.</p>

<h3 id="label-Interpreting+EXPLAIN">Interpreting EXPLAIN<span><a href="#label-Interpreting+EXPLAIN">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Interpretation of the output of EXPLAIN is beyond the scope of this guide.
The following pointers may be helpful:</p>
<ul><li>
<p>SQLite3: <a href="http://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p>
</li><li>
<p>MySQL: <a
href="http://dev.mysql.com/doc/refman/5.6/en/explain-output.html">EXPLAIN
Output Format</a></p>
</li><li>
<p>PostgreSQL: <a
href="http://www.postgresql.org/docs/current/static/using-explain.html">Using
EXPLAIN</a></p>
</li></ul>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

