var search_data = {"index":{"searchIndex":["compositesexpprocessor","examples","methodbasedsexpprocessor","notemptyerror","object","parsetreetestcase","sexp","sexpany","sexpinterpreter","sexpmatchspecial","sexpmatchspecials","sexpprocessor","environment","sexpprocessorerror","sexptypeerror","unique","unknownnodeerror","unsupportednodeerror","<<()","==()","===()","===()","=~()","any()","[]()","[]=()","a_method()","add_18tests()","add_19edgecases()","add_19tests()","add_test()","add_tests()","after_process_hook()","all()","an_alias()","array_type?()","assert_empty()","assert_type()","before_process_hook()","clone_same()","copy_test_case()","current()","deep_clone()","deep_each()","depth()","each_of_type()","each_sexp()","expand_dirs_to_files()","find_and_replace_all()","find_node()","find_nodes()","from_array()","generate_test()","generate_tests()","gsub()","head()","in_context()","in_klass()","in_method()","in_sklass()","inherited()","inspect()","install_missing_reporter()","klass_name()","line()","mass()","method_missing()","method_name()","new()","new()","new()","new()","new()","next()","on_error_in()","on_error_in()","previous()","process()","process()","process_class()","process_defn()","process_defs()","process_dummy()","process_module()","process_sclass()","process_until_empty()","reset()","rest()","rewrite()","s()","scope()","scope()","setup()","sexp_body()","sexp_type()","shift()","signature()","structure()","sub()","testcase_order()","testcases()","unsupported_tests()","with_new_method_stack()","history","manifest","readme"],"longSearchIndex":["compositesexpprocessor","examples","methodbasedsexpprocessor","notemptyerror","object","parsetreetestcase","sexp","sexpany","sexpinterpreter","sexpmatchspecial","sexpmatchspecials","sexpprocessor","sexpprocessor::environment","sexpprocessorerror","sexptypeerror","unique","unknownnodeerror","unsupportednodeerror","compositesexpprocessor#<<()","sexpany#==()","sexp#===()","sexpany#===()","sexp#=~()","sexpmatchspecials#any()","sexpprocessor::environment#[]()","sexpprocessor::environment#[]=()","examples#a_method()","parsetreetestcase::add_18tests()","parsetreetestcase::add_19edgecases()","parsetreetestcase::add_19tests()","parsetreetestcase::add_test()","parsetreetestcase::add_tests()","parsetreetestcase#after_process_hook()","sexpprocessor::environment#all()","examples#an_alias()","sexp#array_type?()","sexpprocessor#assert_empty()","sexpprocessor#assert_type()","parsetreetestcase#before_process_hook()","parsetreetestcase::clone_same()","parsetreetestcase::copy_test_case()","sexpprocessor::environment#current()","object#deep_clone()","sexp#deep_each()","sexpprocessor::environment#depth()","sexp#each_of_type()","sexp#each_sexp()","sexpprocessor::expand_dirs_to_files()","sexp#find_and_replace_all()","sexp#find_node()","sexp#find_nodes()","sexp::from_array()","parsetreetestcase::generate_test()","parsetreetestcase::generate_tests()","sexp#gsub()","sexp#head()","sexpprocessor#in_context()","methodbasedsexpprocessor#in_klass()","methodbasedsexpprocessor#in_method()","methodbasedsexpprocessor#in_sklass()","parsetreetestcase::inherited()","sexpany#inspect()","parsetreetestcase::install_missing_reporter()","methodbasedsexpprocessor#klass_name()","sexp#line()","sexp#mass()","sexp#method_missing()","methodbasedsexpprocessor#method_name()","methodbasedsexpprocessor::new()","sexp::new()","sexpinterpreter::new()","sexpprocessor::new()","sexpprocessor::environment::new()","unique::next()","compositesexpprocessor#on_error_in()","sexpprocessor#on_error_in()","parsetreetestcase::previous()","compositesexpprocessor#process()","sexpprocessor#process()","methodbasedsexpprocessor#process_class()","methodbasedsexpprocessor#process_defn()","methodbasedsexpprocessor#process_defs()","sexpprocessor#process_dummy()","methodbasedsexpprocessor#process_module()","methodbasedsexpprocessor#process_sclass()","methodbasedsexpprocessor#process_until_empty()","unique::reset()","sexp#rest()","sexpprocessor#rewrite()","object#s()","sexpprocessor#scope()","sexpprocessor::environment#scope()","parsetreetestcase#setup()","sexp#sexp_body()","sexp#sexp_type()","sexp#shift()","methodbasedsexpprocessor#signature()","sexp#structure()","sexp#sub()","parsetreetestcase::testcase_order()","parsetreetestcase::testcases()","parsetreetestcase::unsupported_tests()","methodbasedsexpprocessor#with_new_method_stack()","","",""],"info":[["CompositeSexpProcessor","","CompositeSexpProcessor.html","","<p>Implements the Composite pattern on SexpProcessor. Need we say more?\n<p>Yeah… probably. Implements a SexpProcessor …\n"],["Examples","","Examples.html","","<p>key: wwtt = what were they thinking?\n"],["MethodBasedSexpProcessor","","MethodBasedSexpProcessor.html","","<p>A simple subclass of SexpProcessor that tracks method and class stacks for\nyou. Use #method_name, #klass_name …\n"],["NotEmptyError","","NotEmptyError.html","","<p>Raised by SexpProcessor if a processor did not process every node in a sexp\nand @require_empty is true. …\n"],["Object","","Object.html","",""],["ParseTreeTestCase","","ParseTreeTestCase.html","",""],["Sexp","","Sexp.html","","<p>Sexps are the basic storage mechanism of SexpProcessor.  Sexps have a\n<code>type</code> (to be renamed <code>node_type</code>) …\n"],["SexpAny","","SexpAny.html","",""],["SexpInterpreter","","SexpInterpreter.html","","<p>A simple subclass of SexpProcessor that defines a pattern I commonly use:\nnon-mutative and strict process …\n"],["SexpMatchSpecial","","SexpMatchSpecial.html","",""],["SexpMatchSpecials","","SexpMatchSpecials.html","",""],["SexpProcessor","","SexpProcessor.html","","<p>SexpProcessor provides a uniform interface to process Sexps.\n<p>In order to create your own SexpProcessor …\n"],["SexpProcessor::Environment","","SexpProcessor/Environment.html","","<p>I really hate this here, but I hate subdirs in my lib dir more… I guess it\nis kinda like shaving… …\n"],["SexpProcessorError","","SexpProcessorError.html","","<p>SexpProcessor base exception class.\n"],["SexpTypeError","","SexpTypeError.html","","<p>Raised if assert_type encounters an unexpected sexp type.\n"],["Unique","","Unique.html","","<p>Unique creates unique variable names.\n"],["UnknownNodeError","","UnknownNodeError.html","","<p>Raised by SexpProcessor if it is in strict mode and sees a node for which\nthere is no processor available. …\n"],["UnsupportedNodeError","","UnsupportedNodeError.html","","<p>Raised by SexpProcessor if it sees a node type listed in its unsupported\nlist.\n"],["<<","CompositeSexpProcessor","CompositeSexpProcessor.html#method-i-3C-3C","(processor)","<p>Add a <code>processor</code> to the list of processors to run.\n"],["==","SexpAny","SexpAny.html#method-i-3D-3D","(o)",""],["===","Sexp","Sexp.html#method-i-3D-3D-3D","(sexp)","<p>Returns true if this Sexp&#39;s pattern matches <code>sexp</code>.\n"],["===","SexpAny","SexpAny.html#method-i-3D-3D-3D","(o)",""],["=~","Sexp","Sexp.html#method-i-3D-7E","(pattern)","<p>Returns true if this Sexp matches <code>pattern</code>.  (Opposite of\n#===.)\n"],["ANY","SexpMatchSpecials","SexpMatchSpecials.html#method-i-ANY","()",""],["[]","SexpProcessor::Environment","SexpProcessor/Environment.html#method-i-5B-5D","(name)","<p>TODO: depth_of\n"],["[]=","SexpProcessor::Environment","SexpProcessor/Environment.html#method-i-5B-5D-3D","(name, val)",""],["a_method","Examples","Examples.html#method-i-a_method","(x)",""],["add_18tests","ParseTreeTestCase","ParseTreeTestCase.html#method-c-add_18tests","(name, hash)",""],["add_19edgecases","ParseTreeTestCase","ParseTreeTestCase.html#method-c-add_19edgecases","(ruby, sexp, cases)",""],["add_19tests","ParseTreeTestCase","ParseTreeTestCase.html#method-c-add_19tests","(name, hash)",""],["add_test","ParseTreeTestCase","ParseTreeTestCase.html#method-c-add_test","(name, data, klass = self.name[4..-1])",""],["add_tests","ParseTreeTestCase","ParseTreeTestCase.html#method-c-add_tests","(name, hash)",""],["after_process_hook","ParseTreeTestCase","ParseTreeTestCase.html#method-i-after_process_hook","(klass, node, data, input_name, output_name)",""],["all","SexpProcessor::Environment","SexpProcessor/Environment.html#method-i-all","()",""],["an_alias","Examples","Examples.html#method-i-an_alias","(x)",""],["array_type?","Sexp","Sexp.html#method-i-array_type-3F","()","<p>Returns true if the node_type is <code>array</code> or <code>args</code>.\n<p>REFACTOR: to TypedSexp - we only care when we have units. …\n"],["assert_empty","SexpProcessor","SexpProcessor.html#method-i-assert_empty","(meth, exp, exp_orig)",""],["assert_type","SexpProcessor","SexpProcessor.html#method-i-assert_type","(list, typ)","<p>Raises unless the Sexp type for <code>list</code> matches <code>typ</code>\n"],["before_process_hook","ParseTreeTestCase","ParseTreeTestCase.html#method-i-before_process_hook","(klass, node, data, input_name, output_name)",""],["clone_same","ParseTreeTestCase","ParseTreeTestCase.html#method-c-clone_same","()",""],["copy_test_case","ParseTreeTestCase","ParseTreeTestCase.html#method-c-copy_test_case","(nonverbose, klass)",""],["current","SexpProcessor::Environment","SexpProcessor/Environment.html#method-i-current","()",""],["deep_clone","Object","Object.html#method-i-deep_clone","()","<p>deep_clone is the usual Marshalling hack to make a deep copy. It is rather\nslow, so use it sparingly. …\n"],["deep_each","Sexp","Sexp.html#method-i-deep_each","(&block)","<p>Recursively enumerates the sexp yielding to <code>block</code> for every\nelement. TODO: test\n"],["depth","SexpProcessor::Environment","SexpProcessor/Environment.html#method-i-depth","()",""],["each_of_type","Sexp","Sexp.html#method-i-each_of_type","(t, &b)","<p>Enumeratates the sexp yielding to <code>b</code> when the node_type ==\n<code>t</code>.\n"],["each_sexp","Sexp","Sexp.html#method-i-each_sexp","()","<p>Recursively enumerates all sub-sexps skipping non-Sexp elements. TODO: test\n"],["expand_dirs_to_files","SexpProcessor","SexpProcessor.html#method-c-expand_dirs_to_files","(*dirs)","<p>Expand an array of directories into a flattened array of paths, eg:\n\n<pre>MyProcessor.run MyProcessor.expand_dirs_to_files ...</pre>\n"],["find_and_replace_all","Sexp","Sexp.html#method-i-find_and_replace_all","(from, to)","<p>Replaces all elements whose node_type is <code>from</code> with\n<code>to</code>. Used only for the most trivial of rewrites.\n"],["find_node","Sexp","Sexp.html#method-i-find_node","(name, delete = false)",""],["find_nodes","Sexp","Sexp.html#method-i-find_nodes","(name)","<p>Find every node with type <code>name</code>.\n"],["from_array","Sexp","Sexp.html#method-c-from_array","(a)","<p>Creates a new Sexp from Array <code>a</code>.\n"],["generate_test","ParseTreeTestCase","ParseTreeTestCase.html#method-c-generate_test","(klass, node, data, input_name, output_name)",""],["generate_tests","ParseTreeTestCase","ParseTreeTestCase.html#method-c-generate_tests","(klass)",""],["gsub","Sexp","Sexp.html#method-i-gsub","(pattern, repl)","<p>Replaces all Sexps matching <code>pattern</code> with Sexp\n<code>repl</code>.\n"],["head","Sexp","Sexp.html#method-i-head","()",""],["in_context","SexpProcessor","SexpProcessor.html#method-i-in_context","(type)",""],["in_klass","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-in_klass","(name)","<p>Adds name to the class stack, for the duration of the block\n"],["in_method","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-in_method","(name, file, line)","<p>Adds name to the method stack, for the duration of the block\n"],["in_sklass","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-in_sklass","()","<p>Tracks whether we&#39;re in a singleton class or not. Doesn&#39;t track\nactual receiver.\n"],["inherited","ParseTreeTestCase","ParseTreeTestCase.html#method-c-inherited","(klass)",""],["inspect","SexpAny","SexpAny.html#method-i-inspect","()",""],["install_missing_reporter","ParseTreeTestCase","ParseTreeTestCase.html#method-c-install_missing_reporter","()",""],["klass_name","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-klass_name","()","<p>Returns the first class in the list, or @@no_class if there are none.\n"],["line","Sexp","Sexp.html#method-i-line","(n=nil)","<p>If passed a line number, sets the line and returns self. Otherwise returns\nthe line number. This allows …\n"],["mass","Sexp","Sexp.html#method-i-mass","()","<p>Returns the size of the sexp, flattened.\n"],["method_missing","Sexp","Sexp.html#method-i-method_missing","(meth, delete = false)","<p>Returns the node named <code>node</code>, deleting it if\n<code>delete</code> is true.\n"],["method_name","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-method_name","()","<p>Returns the first method in the list, or “#none” if there are none.\n"],["new","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-c-new","()",""],["new","Sexp","Sexp.html#method-c-new","(*args)","<p>Create a new Sexp containing <code>args</code>.\n"],["new","SexpInterpreter","SexpInterpreter.html#method-c-new","()",""],["new","SexpProcessor","SexpProcessor.html#method-c-new","()","<p>Creates a new SexpProcessor.  Use super to invoke this initializer from\nSexpProcessor subclasses, then …\n"],["new","SexpProcessor::Environment","SexpProcessor/Environment.html#method-c-new","()",""],["next","Unique","Unique.html#method-c-next","()",""],["on_error_in","CompositeSexpProcessor","CompositeSexpProcessor.html#method-i-on_error_in","(node_type, &block)",""],["on_error_in","SexpProcessor","SexpProcessor.html#method-i-on_error_in","(node_type, &block)","<p>Registers an error handler for <code>node</code>\n"],["previous","ParseTreeTestCase","ParseTreeTestCase.html#method-c-previous","(key, extra=0)",""],["process","CompositeSexpProcessor","CompositeSexpProcessor.html#method-i-process","(exp)","<p>Run <code>exp</code> through all of the processors, returning the final\nresult.\n"],["process","SexpProcessor","SexpProcessor.html#method-i-process","(exp)","<p>Default Sexp processor.  Invokes process_&lt;type&gt; methods matching the\nSexp type given.  Performs …\n"],["process_class","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-process_class","(exp)","<p>Process a class node until empty. Tracks all nesting. If you have to\nsubclass and override this method, …\n"],["process_defn","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-process_defn","(exp)","<p>Process a method node until empty. Tracks your location. If you have to\nsubclass and override this method, …\n"],["process_defs","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-process_defs","(exp)","<p>Process a singleton method node until empty. Tracks your location. If you\nhave to subclass and override …\n"],["process_dummy","SexpProcessor","SexpProcessor.html#method-i-process_dummy","(exp)","<p>A fairly generic processor for a dummy node. Dummy nodes are used when your\nprocessor is doing a complicated …\n"],["process_module","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-process_module","(exp)","<p>Process a module node until empty. Tracks all nesting. If you have to\nsubclass and override this method, …\n"],["process_sclass","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-process_sclass","(exp)","<p>Process a singleton class node until empty. Tracks all nesting. If you have\nto subclass and override …\n"],["process_until_empty","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-process_until_empty","(exp)","<p>Process each element of #exp in turn.\n"],["reset","Unique","Unique.html#method-c-reset","()",""],["rest","Sexp","Sexp.html#method-i-rest","()",""],["rewrite","SexpProcessor","SexpProcessor.html#method-i-rewrite","(exp)",""],["s","Object","Object.html#method-i-s","(*args)","<p>This is a very important shortcut to make using Sexps much more awesome.\n"],["scope","SexpProcessor","SexpProcessor.html#method-i-scope","(&block)","<p>Add a scope level to the current env. Eg:\n\n<pre>def process_defn exp\n  name = exp.shift\n  args = process(exp.shift) ...</pre>\n"],["scope","SexpProcessor::Environment","SexpProcessor/Environment.html#method-i-scope","()",""],["setup","ParseTreeTestCase","ParseTreeTestCase.html#method-i-setup","()",""],["sexp_body","Sexp","Sexp.html#method-i-sexp_body","()","<p>Returns the Sexp body, ie the values without the node type.\n"],["sexp_type","Sexp","Sexp.html#method-i-sexp_type","()","<p>Returns the node type of the Sexp.\n"],["shift","Sexp","Sexp.html#method-i-shift","()","<p>If run with debug, Sexp will raise if you shift on an empty Sexp. Helps\nwith debugging.\n"],["signature","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-signature","()","<p>Returns the method signature for the current method.\n"],["structure","Sexp","Sexp.html#method-i-structure","()","<p>Returns the bare bones structure of the sexp. s(:a, :b, s(:c, :d), :e)\n=&gt; s(:a, s(:c))\n"],["sub","Sexp","Sexp.html#method-i-sub","(pattern, repl)","<p>Replaces the Sexp matching <code>pattern</code> with <code>repl</code>.\n"],["testcase_order","ParseTreeTestCase","ParseTreeTestCase.html#method-c-testcase_order","()",""],["testcases","ParseTreeTestCase","ParseTreeTestCase.html#method-c-testcases","()",""],["unsupported_tests","ParseTreeTestCase","ParseTreeTestCase.html#method-c-unsupported_tests","(*tests)",""],["with_new_method_stack","MethodBasedSexpProcessor","MethodBasedSexpProcessor.html#method-i-with_new_method_stack","()","<p>Reset the method stack for the duration of the block. Used for class\nscoping.\n"],["History","","History_txt.html","","<p>4.5.0 / 2015-03-09\n<p>1 minor enhancement:\n<p>Added SexpProcessor::expand_dirs_to_files as a utility to cmdline …\n"],["Manifest","","Manifest_txt.html","","<p>History.txt Manifest.txt README.txt Rakefile\nlib/composite_sexp_processor.rb lib/pt_testcase.rb lib/sexp.rb …\n"],["README","","README_txt.html","","<p>SexpProcessor\n<p>home  &mdash; github.com/seattlerb/sexp_processor\n<p>rdoc  &mdash; docs.seattlerb.org/sexp_processor\n"]]}}