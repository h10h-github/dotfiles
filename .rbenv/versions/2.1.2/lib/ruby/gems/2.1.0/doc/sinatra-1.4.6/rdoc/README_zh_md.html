<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>README.zh - Sinatra</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Sinatra">Sinatra</a>
    <li><a href="#label-myapp.rb">myapp.rb</a>
    <li><a href="#label-E8-B7-AF-E7-94-B1-28route-29">路由(route)</a>
    <li><a href="#label-E6-9D-A1-E4-BB-B6">条件</a>
    <li><a href="#label-E8-BF-94-E5-9B-9E-E5-80-BC">返回值</a>
    <li><a href="#label-E8-87-AA-E5-AE-9A-E4-B9-89-E8-B7-AF-E7-94-B1-E5-8C-B9-E9-85-8D-E5-99-A8">自定义路由匹配器</a>
    <li><a href="#label-E9-9D-99-E6-80-81-E6-96-87-E4-BB-B6">静态文件</a>
    <li><a href="#label-E8-A7-86-E5-9B-BE+-2F+-E6-A8-A1-E6-9D-BF">视图 / 模板</a>
    <li><a href="#label-Haml-E6-A8-A1-E6-9D-BF">Haml模板</a>
    <li><a href="#label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml">你需要在你的应用中引入 haml</a>
    <li><a href="#label-Erb-E6-A8-A1-E6-9D-BF">Erb模板</a>
    <li><a href="#label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+erb">你需要在你的应用中引入 erb</a>
    <li><a href="#label-Erubis">Erubis</a>
    <li><a href="#label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+erubis">你需要在你的应用中引入 erubis</a>
    <li><a href="#label-Builder+-E6-A8-A1-E6-9D-BF">Builder 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5builder">需要在你的应用中引入builder</a>
    <li><a href="#label-Nokogiri+-E6-A8-A1-E6-9D-BF">Nokogiri 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+nokogiri">需要在你的应用中引入 nokogiri</a>
    <li><a href="#label-Sass+-E6-A8-A1-E6-9D-BF">Sass 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml+-E6-88-96-E8-80-85+sass">需要在你的应用中引入 haml 或者 sass</a>
    <li><a href="#label-Scss+-E6-A8-A1-E6-9D-BF">Scss 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml+-E6-88-96-E8-80-85+sass">需要在你的应用中引入 haml 或者 sass</a>
    <li><a href="#label-Less+-E6-A8-A1-E6-9D-BF">Less 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+less">需要在你的应用中引入 less</a>
    <li><a href="#label-Liquid+-E6-A8-A1-E6-9D-BF">Liquid 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+liquid">需要在你的应用中引入 liquid</a>
    <li><a href="#label-Markdown+-E6-A8-A1-E6-9D-BF">Markdown 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5rdiscount">需要在你的应用中引入rdiscount</a>
    <li><a href="#label-Textile+-E6-A8-A1-E6-9D-BF">Textile 模板</a>
    <li><a href="#label-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5redcloth">在你的应用中引入redcloth</a>
    <li><a href="#label-RDoc+-E6-A8-A1-E6-9D-BF">RDoc 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5rdoc-2Fmarkup-2Fto_html">需要在你的应用中引入rdoc/markup/to_html</a>
    <li><a href="#label-Radius+-E6-A8-A1-E6-9D-BF">Radius 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5radius">需要在你的应用中引入radius</a>
    <li><a href="#label-Markaby+-E6-A8-A1-E6-9D-BF">Markaby 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+markaby">需要在你的应用中引入 markaby</a>
    <li><a href="#label-Slim+-E6-A8-A1-E6-9D-BF">Slim 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+slim">需要在你的应用中引入 slim</a>
    <li><a href="#label-Creole+-E6-A8-A1-E6-9D-BF">Creole 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+creole">需要在你的应用中引入 creole</a>
    <li><a href="#label-CoffeeScript+-E6-A8-A1-E6-9D-BF">CoffeeScript 模板</a>
    <li><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5coffee-script">需要在你的应用中引入coffee-script</a>
    <li><a href="#label-E5-B5-8C-E5-85-A5-E6-A8-A1-E6-9D-BF-E5-AD-97-E7-AC-A6-E4-B8-B2">嵌入模板字符串</a>
    <li><a href="#label-E5-9C-A8-E6-A8-A1-E6-9D-BF-E4-B8-AD-E8-AE-BF-E9-97-AE-E5-8F-98-E9-87-8F">在模板中访问变量</a>
    <li><a href="#label-E5-86-85-E8-81-94-E6-A8-A1-E6-9D-BF">内联模板</a>
    <li><a href="#label-E5-85-B7-E5-90-8D-E6-A8-A1-E6-9D-BF">具名模板</a>
    <li><a href="#label-E5-85-B3-E8-81-94-E6-96-87-E4-BB-B6-E6-89-A9-E5-B1-95-E5-90-8D">关联文件扩展名</a>
    <li><a href="#label-E6-B7-BB-E5-8A-A0-E4-BD-A0-E8-87-AA-E5-B7-B1-E7-9A-84-E6-A8-A1-E7-89-88-E5-BC-95-E6-93-8E">添加你自己的模版引擎</a>
    <li><a href="#label-E8-BF-87-E6-BB-A4-E5-99-A8">过滤器</a>
    <li><a href="#label-E8-BE-85-E5-8A-A9-E6-96-B9-E6-B3-95">辅助方法</a>
    <li><a href="#label-E4-BD-BF-E7-94-A8+Sessions">使用 Sessions</a>
    <li><a href="#label-E6-8C-82-E8-B5-B7">挂起</a>
    <li><a href="#label-E8-AE-A9-E8-B7-AF">让路</a>
    <li><a href="#label-E8-A7-A6-E5-8F-91-E5-8F-A6-E4-B8-80-E4-B8-AA-E8-B7-AF-E7-94-B1">触发另一个路由</a>
    <li><a href="#label-E8-AE-BE-E5-AE-9A+-E6-B6-88-E6-81-AF-E4-BD-93-EF-BC-8C-E7-8A-B6-E6-80-81-E7-A0-81-E5-92-8C-E6-B6-88-E6-81-AF-E5-A4-B4">设定 消息体，状态码和消息头</a>
    <li><a href="#label-E5-AA-92-E4-BD-93-28MIME-29-E7-B1-BB-E5-9E-8B">媒体(MIME)类型</a>
    <li><a href="#label-E7-94-9F-E6-88-90+URL">生成 URL</a>
    <li><a href="#label-E6-B5-8F-E8-A7-88-E5-99-A8-E9-87-8D-E5-AE-9A-E5-90-91">浏览器重定向</a>
    <li><a href="#label-E7-BC-93-E5-AD-98-E6-8E-A7-E5-88-B6">缓存控制</a>
    <li><a href="#label-E5-8F-91-E9-80-81-E6-96-87-E4-BB-B6">发送文件</a>
    <li><a href="#label-E8-AE-BF-E9-97-AE-E8-AF-B7-E6-B1-82-E5-AF-B9-E8-B1-A1">访问请求对象</a>
    <li><a href="#label-E5-9C-A8+http-3A-2F-2Fexample.com-2Fexample+-E4-B8-8A-E8-BF-90-E8-A1-8C-E7-9A-84-E5-BA-94-E7-94-A8">在 <a href="http://example.com/example">example.com/example</a> 上运行的应用</a>
    <li><a href="#label-E9-99-84-E4-BB-B6">附件</a>
    <li><a href="#label-E6-9F-A5-E6-89-BE-E6-A8-A1-E6-9D-BF-E6-96-87-E4-BB-B6">查找模板文件</a>
    <li><a href="#label-E9-85-8D-E7-BD-AE">配置</a>
    <li><a href="#label-E5-8F-AF-E9-80-89-E7-9A-84-E8-AE-BE-E7-BD-AE">可选的设置</a>
    <li><a href="#label-E9-94-99-E8-AF-AF-E5-A4-84-E7-90-86">错误处理</a>
    <li><a href="#label-E6-9C-AA-E6-89-BE-E5-88-B0">未找到</a>
    <li><a href="#label-E9-94-99-E8-AF-AF">错误</a>
    <li><a href="#label-Rack+-E4-B8-AD-E9-97-B4-E4-BB-B6">Rack 中间件</a>
    <li><a href="#label-E6-B5-8B-E8-AF-95">测试</a>
    <li><a href="#label-Sinatra-3A-3ABase+-+-E4-B8-AD-E9-97-B4-E4-BB-B6-EF-BC-8C-E7-A8-8B-E5-BA-8F-E5-BA-93-E5-92-8C-E6-A8-A1-E5-9D-97-E5-8C-96-E5-BA-94-E7-94-A8">Sinatra::Base - 中间件，程序库和模块化应用</a>
    <li><a href="#label-E6-A8-A1-E5-9D-97-E5-8C-96+vs.+-E4-BC-A0-E7-BB-9F-E7-9A-84-E6-96-B9-E5-BC-8F">模块化 vs. 传统的方式</a>
    <li><a href="#label-E8-BF-90-E8-A1-8C-E4-B8-80-E4-B8-AA-E6-A8-A1-E5-9D-97-E5-8C-96-E5-BA-94-E7-94-A8">运行一个模块化应用</a>
    <li><a href="#label-my_app.rb">my_app.rb</a>
    <li><a href="#label-config.ru">config.ru</a>
    <li><a href="#label-E4-BD-BF-E7-94-A8config.ru-E8-BF-90-E8-A1-8C-E4-BC-A0-E7-BB-9F-E6-96-B9-E5-BC-8F-E7-9A-84-E5-BA-94-E7-94-A8">使用config.ru运行传统方式的应用</a>
    <li><a href="#label-app.rb">app.rb</a>
    <li><a href="#label-E4-BB-80-E4-B9-88-E6-97-B6-E5-80-99-E7-94-A8+config.ru-3F">什么时候用 config.ru?</a>
    <li><a href="#label-E6-8A-8ASinatra-E5-BD-93-E6-88-90-E4-B8-AD-E9-97-B4-E4-BB-B6-E6-9D-A5-E4-BD-BF-E7-94-A8">把Sinatra当成中间件来使用</a>
    <li><a href="#label-E5-8F-98-E9-87-8F-E5-9F-9F-E5-92-8C-E7-BB-91-E5-AE-9A">变量域和绑定</a>
    <li><a href="#label-E5-BA-94-E7-94-A8-2F-E7-B1-BB+-E5-8F-98-E9-87-8F-E5-9F-9F">应用/类 变量域</a>
    <li><a href="#label-E8-AF-B7-E6-B1-82-2F-E5-AE-9E-E4-BE-8B+-E5-8F-98-E9-87-8F-E5-9F-9F">请求/实例 变量域</a>
    <li><a href="#label-E4-BB-A3-E7-90-86-E5-8F-98-E9-87-8F-E5-9F-9F">代理变量域</a>
    <li><a href="#label-E5-91-BD-E4-BB-A4-E8-A1-8C">命令行</a>
    <li><a href="#label-E5-BF-85-E8-A6-81-E6-9D-A1-E4-BB-B6">必要条件</a>
    <li><a href="#label-E7-B4-A7-E8-BF-BD-E5-89-8D-E6-B2-BF">紧追前沿</a>
    <li><a href="#label-E9-80-9A-E8-BF-87Bundler">通过Bundler</a>
    <li><a href="#label-E5-85-B6-E4-BB-96-E7-9A-84-E4-BE-9D-E8-B5-96-E5-85-B3-E7-B3-BB">其他的依赖关系</a>
    <li><a href="#label-E4-BD-BF-E7-94-A8-E8-87-AA-E5-B7-B1-E7-9A-84">使用自己的</a>
    <li><a href="#label-E5-85-A8-E5-B1-80-E5-AE-89-E8-A3-85">全局安装</a>
    <li><a href="#label-E6-9B-B4-E5-A4-9A">更多</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./LICENSE.html">LICENSE</a>
  
    <li><a href="./README_de_md.html">README.de</a>
  
    <li><a href="./README_es_md.html">README.es</a>
  
    <li><a href="./README_fr_md.html">README.fr</a>
  
    <li><a href="./README_hu_md.html">README.hu</a>
  
    <li><a href="./README_ja_md.html">README.ja</a>
  
    <li><a href="./README_ko_md.html">README.ko</a>
  
    <li><a href="./README_md.html">README</a>
  
    <li><a href="./README_pt-br_md.html">README.pt-br</a>
  
    <li><a href="./README_pt-pt_md.html">README.pt-pt</a>
  
    <li><a href="./README_ru_md.html">README.ru</a>
  
    <li><a href="./README_zh_md.html">README.zh</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page README.zh.md">

<h1 id="label-Sinatra"><a href="Sinatra.html">Sinatra</a><span><a href="#label-Sinatra">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><em>注：本文档是英文版的翻译，内容更新有可能不及时。 如有不一致的地方，请以英文版为准。</em></p>

<p>Sinatra是一个基于Ruby语言的<a
href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>（
领域专属语言），可以轻松、快速的创建web应用。</p>

<p>~~~~ ruby</p>

<h1 id="label-myapp.rb">myapp.rb<span><a href="#label-myapp.rb">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;sinatra&#39;</p>

<p>get &#39;/&#39; do  &#39;Hello world!&#39; end ~~~~</p>

<p>安装gem，然后运行：</p>

<p>~~~~ shell gem install sinatra ruby myapp.rb ~~~~</p>

<p>在该地址查看： <a href="http://localhost:4567">localhost:4567</a></p>

<p>这个时候访问地址将绑定到 127.0.0.1 和 localhost ，如果使用 vagrant 进行开发，访问会失败，此时就需要进行 ip 绑定了：</p>

<p>~~~~ shell ruby myapp.rb -o 0.0.0.0 ~~~~</p>

<p><code>-o</code> 这个参数就是进行 Listening 时候监听的绑定，能从通过 IP、127.0.0.1、localhost +
端口号进行访问。</p>

<p>安装Sintra后，最好再运行<code>gem install
thin</code>安装Thin。这样，Sinatra会优先选择Thin作为服务器。</p>

<h2 id="label-E8-B7-AF-E7-94-B1-28route-29">路由(route)<span><a href="#label-E8-B7-AF-E7-94-B1-28route-29">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>在Sinatra中，一个路由分为两部分：HTTP方法(GET, POST等)和URL匹配范式。 每个路由都有一个要执行的代码块：</p>

<p>~~~~ ruby get &#39;/&#39; do  .. 显示内容 .. end</p>

<p>post &#39;/&#39; do  .. 创建内容 .. end</p>

<p>put &#39;/&#39; do  .. 更新内容 .. end</p>

<p>delete &#39;/&#39; do  .. 删除内容 .. end</p>

<p>options &#39;/&#39; do  .. 显示命令列表 .. end</p>

<p>link &#39;/&#39; do  .. 建立某种联系 .. end</p>

<p>unlink &#39;/&#39; do  .. 解除某种联系 .. end</p>

<p>~~~~</p>

<p>路由按照它们被定义的顺序进行匹配。 第一个与请求匹配的路由会被调用。</p>

<p>路由范式可以包括具名参数，可通过<code>params</code>哈希表获得：</p>

<p>~~~~ ruby get &#39;/hello/:name&#39; do  # 匹配 “GET /hello/foo” 和 “GET
/hello/bar”  # <a href="'name'">params</a> 的值是 &#39;foo&#39; 或者
&#39;bar&#39;  “Hello #{<a href="'name'">params</a>}!” end ~~~~</p>

<p>你同样可以通过代码块参数获得具名参数：</p>

<p>~~~~ ruby get &#39;/hello/:name&#39; do |n|  “Hello #{n}!” end ~~~~</p>

<p>路由范式也可以包含通配符参数， <a href="'splat'">可以通过params</a>数组获得。</p>

<p>~~~~ ruby get &#39;/say/<em>/to/</em>&#39; do  # 匹配 /say/hello/to/world  <a
href="'splat'">params</a> # =&gt; [“hello”, “world”] end</p>

<p>get &#39;/download/<em>.</em>&#39; do  # 匹配 /download/path/to/file.xml  <a
href="'splat'">params</a> # =&gt; [“path/to/file”, “xml”] end ~~~~</p>

<p>通过正则表达式匹配的路由：</p>

<p>~~~~ ruby get /<a href=“w”>A/hello/(</a>+)z/ do  “Hello, #{<a
href="'captures'">params</a>.first}!” end ~~~~</p>

<p>或者使用代码块参数：</p>

<p>~~~~ ruby get %r{/<a href="\w">hello/(</a>+)} do |c|  “Hello, #{c}!” end
~~~~</p>

<h3 id="label-E6-9D-A1-E4-BB-B6">条件<span><a href="#label-E6-9D-A1-E4-BB-B6">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>路由也可以包含多样的匹配条件，比如user agent：</p>

<p>~~~~ ruby get &#39;/foo&#39;, :agent =&gt; /Songbird (<a
href=“d/”>d.d)</a>*?/ do  “你正在使用Songbird，版本是 #{<a
href="'agent'">params</a>[0]}” end</p>

<p>get &#39;/foo&#39; do  # 匹配除Songbird以外的浏览器 end ~~~~</p>

<p>其他可选的条件是 <code>host_name</code> 和 <code>provides</code>：</p>

<p>~~~~ ruby get &#39;/&#39;, :host_name =&gt; /^admin./ do  “管理员区域，无权进入！” end</p>

<p>get &#39;/&#39;, :provides =&gt; &#39;html&#39; do  haml :index end</p>

<p>get &#39;/&#39;, :provides =&gt; [&#39;rss&#39;, &#39;atom&#39;,
&#39;xml&#39;] do  builder :feed end ~~~~</p>

<p>你也可以自定义条件：</p>

<p>~~~~ ruby set(:probability) { |value| condition { rand &lt;= value } }</p>

<p>get &#39;/win_a_car&#39;, :probability =&gt; 0.1 do  “You won!” end</p>

<p>get &#39;/win_a_car&#39; do  “Sorry, you lost.” end ~~~~</p>

<h3 id="label-E8-BF-94-E5-9B-9E-E5-80-BC">返回值<span><a href="#label-E8-BF-94-E5-9B-9E-E5-80-BC">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>路由代码块的返回值至少决定了返回给HTTP客户端的响应体， 或者至少决定了在Rack堆栈中的下一个中间件。
大多数情况下，将是一个字符串，就像上面的例子中的一样。 但是其他值也是可以接受的。</p>

<p>你可以返回任何对象，或者是一个合理的Rack响应， <a href="Rack.html">Rack</a> body对象或者HTTP状态码：</p>
<ul><li>
<p>一个包含三个元素的数组: <code>[状态 (Fixnum), 头 (Hash), 响应体 (回应 #each)]</code></p>
</li><li>
<p>一个包含两个元素的数组: <code>[状态 (Fixnum), 响应体 (回应 #each)]</code></p>
</li><li>
<p>一个能够回应 <code>#each</code> ，只传回字符串的对象</p>
</li><li>
<p>一个代表状态码的数字</p>
</li></ul>

<p>那样，我们可以轻松的实现例如流式传输的例子：</p>

<p>~~~~ ruby class Stream  def each  100.times { |i| yield “#{i}n” }  end end</p>

<p>get(&#39;/&#39;) { Stream.new } ~~~~</p>

<h3 id="label-E8-87-AA-E5-AE-9A-E4-B9-89-E8-B7-AF-E7-94-B1-E5-8C-B9-E9-85-8D-E5-99-A8">自定义路由匹配器<span><a href="#label-E8-87-AA-E5-AE-9A-E4-B9-89-E8-B7-AF-E7-94-B1-E5-8C-B9-E9-85-8D-E5-99-A8">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>如上显示，Sinatra内置了对于使用字符串和正则表达式作为路由匹配的支持。 但是，它并没有只限于此。 你可以非常容易地定义你自己的匹配器:</p>

<p>~~~~ ruby class AllButPattern  Match = Struct.new(:captures)</p>

<p>def initialize(except)  @except = except  @captures = Match.new([])  end</p>

<p>def match(str)  @captures unless @except === str  end end</p>

<p>def all_but(pattern)  AllButPattern.new(pattern) end</p>

<p>get all_but(“/index”) do  # … end ~~~~</p>

<p>上面的例子可能太繁琐了， 因为它也可以用更简单的方式表述:</p>

<p>~~~~ ruby get // do  pass if request.path_info == “/index”  # … end ~~~~</p>

<p>或者，使用消极向前查找:</p>

<p>~~~~ ruby get %r{^(?!/index$)} do  # … end ~~~~</p>

<h2 id="label-E9-9D-99-E6-80-81-E6-96-87-E4-BB-B6">静态文件<span><a href="#label-E9-9D-99-E6-80-81-E6-96-87-E4-BB-B6">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>静态文件是从 <code>./public_folder</code> 目录提供服务。你可以通过设置<code>:public</code>
选项设定一个不同的位置：</p>

<p>~~~~ ruby set :public_folder, File.dirname(<strong>FILE</strong>) +
&#39;/static&#39; ~~~~</p>

<p>请注意public目录名并没有被包含在URL之中。文件 <code>./public/css/style.css</code>是通过
<code>http://example.com/css/style.css</code>地址访问的。</p>

<h2 id="label-E8-A7-86-E5-9B-BE+-2F+-E6-A8-A1-E6-9D-BF">视图 / 模板<span><a href="#label-E8-A7-86-E5-9B-BE+-2F+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>模板被假定直接位于<code>./views</code>目录。 要使用不同的视图目录：</p>

<p>~~~~ ruby set :views, File.dirname(<strong>FILE</strong>) +
&#39;/templates&#39; ~~~~</p>

<p>重要提示：你只可以通过符号引用模板， 即使它们在子目录下 （在这种情况下，使用
<code>:&#39;subdir/template&#39;</code>）。 如果你不用符号、而用字符串的话，
填充方法会只把你传入的字符串当成内容显示出来，而不调用模板。</p>

<h3 id="label-Haml-E6-A8-A1-E6-9D-BF">Haml模板<span><a href="#label-Haml-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>haml</code> gem/library以填充 HAML 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml">你需要在你的应用中引入 haml<span><a href="#label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;haml&#39;</p>

<p>get &#39;/&#39; do  haml :index end ~~~~</p>

<p>填充 <code>./views/index.haml</code>。</p>

<p><a
href="http://haml.info/docs/yardoc/file.HAML_REFERENCE.html#options">Haml的选项</a>
可以通过Sinatra的配置全局设定， 参见 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置</a>， 也可以个别的被覆盖。</p>

<p>~~~~ ruby set :haml, {:format =&gt; :html5 } # 默认的Haml输出格式是 :xhtml</p>

<p>get &#39;/&#39; do  haml :index, :haml_options =&gt; {:format =&gt; :html4
} # 被覆盖，变成:html4 end ~~~~</p>

<h3 id="label-Erb-E6-A8-A1-E6-9D-BF">Erb模板<span><a href="#label-Erb-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>~~~~ ruby</p>

<h1 id="label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+erb">你需要在你的应用中引入 erb<span><a href="#label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+erb">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;erb&#39;</p>

<p>get &#39;/&#39; do  erb :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.erb</code></p>

<h3 id="label-Erubis">Erubis<span><a href="#label-Erubis">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>erubis</code> gem/library以填充 erubis 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+erubis">你需要在你的应用中引入 erubis<span><a href="#label-E4-BD-A0-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+erubis">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;erubis&#39;</p>

<p>get &#39;/&#39; do  erubis :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.erubis</code></p>

<p>使用Erubis代替Erb也是可能的:</p>

<p>~~~~ ruby require &#39;erubis&#39; Tilt.register :erb, <a
href=":erubis">Tilt</a></p>

<p>get &#39;/&#39; do  erb :index end ~~~~</p>

<p>使用Erubis来填充 <code>./views/index.erb</code>。</p>

<h3 id="label-Builder+-E6-A8-A1-E6-9D-BF">Builder 模板<span><a href="#label-Builder+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>builder</code> gem/library 以填充 builder templates：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5builder">需要在你的应用中引入builder<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5builder">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;builder&#39;</p>

<p>get &#39;/&#39; do  builder :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.builder</code>。</p>

<h3 id="label-Nokogiri+-E6-A8-A1-E6-9D-BF">Nokogiri 模板<span><a href="#label-Nokogiri+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>nokogiri</code> gem/library 以填充 nokogiri 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+nokogiri">需要在你的应用中引入 nokogiri<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+nokogiri">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;nokogiri&#39;</p>

<p>get &#39;/&#39; do  nokogiri :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.nokogiri</code>。</p>

<h3 id="label-Sass+-E6-A8-A1-E6-9D-BF">Sass 模板<span><a href="#label-Sass+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>haml</code> 或者 <code>sass</code> gem/library 以填充 Sass 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml+-E6-88-96-E8-80-85+sass">需要在你的应用中引入 haml 或者 sass<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml+-E6-88-96-E8-80-85+sass">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;sass&#39;</p>

<p>get &#39;/stylesheet.css&#39; do  sass :stylesheet end ~~~~</p>

<p>这里调用的是 <code>./views/stylesheet.sass</code>。</p>

<p><a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Sass
的选项</a> 可以通过Sinatra选项全局设定， 参考 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置（英文）</a>,
也可以在个体的基础上覆盖。</p>

<p>~~~~ ruby set :sass, {:style =&gt; :compact } # 默认的 Sass 样式是 :nested</p>

<p>get &#39;/stylesheet.css&#39; do  sass :stylesheet, :style =&gt; :expanded
# 覆盖 end ~~~~</p>

<h3 id="label-Scss+-E6-A8-A1-E6-9D-BF">Scss 模板<span><a href="#label-Scss+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>haml</code> 或者 <code>sass</code> gem/library 来填充 Scss templates：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml+-E6-88-96-E8-80-85+sass">需要在你的应用中引入 haml 或者 sass<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+haml+-E6-88-96-E8-80-85+sass">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;sass&#39;</p>

<p>get &#39;/stylesheet.css&#39; do  scss :stylesheet end ~~~~</p>

<p>这里调用的是 <code>./views/stylesheet.scss</code>。</p>

<p><a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Scss的选项</a>
可以通过Sinatra选项全局设定， 参考 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置（英文）</a>,
也可以在个体的基础上覆盖。</p>

<p>~~~~ ruby set :scss, :style =&gt; :compact # default Scss style is :nested</p>

<p>get &#39;/stylesheet.css&#39; do  scss :stylesheet, :style =&gt; :expanded
# overridden end ~~~~</p>

<h3 id="label-Less+-E6-A8-A1-E6-9D-BF">Less 模板<span><a href="#label-Less+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>less</code> gem/library 以填充 Less 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+less">需要在你的应用中引入 less<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+less">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;less&#39;</p>

<p>get &#39;/stylesheet.css&#39; do  less :stylesheet end ~~~~</p>

<p>这里调用的是 <code>./views/stylesheet.less</code>。</p>

<h3 id="label-Liquid+-E6-A8-A1-E6-9D-BF">Liquid 模板<span><a href="#label-Liquid+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>liquid</code> gem/library 来填充 Liquid 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+liquid">需要在你的应用中引入 liquid<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+liquid">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;liquid&#39;</p>

<p>get &#39;/&#39; do  liquid :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.liquid</code>。</p>

<p>因为你不能在Liquid 模板中调用 Ruby 方法 (除了 <code>yield</code>) ， 你几乎总是需要传递locals给它：</p>

<p>~~~~ ruby liquid :index, :locals =&gt; { :key =&gt; &#39;value&#39; } ~~~~</p>

<h3 id="label-Markdown+-E6-A8-A1-E6-9D-BF">Markdown 模板<span><a href="#label-Markdown+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>rdiscount</code> gem/library 以填充 Markdown 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5rdiscount">需要在你的应用中引入rdiscount<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5rdiscount">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require “rdiscount”</p>

<p>get &#39;/&#39; do  markdown :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.markdown</code> (<code>md</code> 和
<code>mkd</code> 也是合理的文件扩展名)。</p>

<p>在markdown中是不可以调用方法的，也不可以传递 locals给它。 你因此一般会结合其他的填充引擎来使用它：</p>

<p>~~~~ ruby erb :overview, :locals =&gt; { :text =&gt;
markdown(:introduction) } ~~~~</p>

<p>请注意你也可以从其他模板中调用 markdown 方法：</p>

<p>~~~~ ruby %h1 Hello From Haml! %p= markdown(:greetings) ~~~~</p>

<p>既然你不能在Markdown中调用Ruby，你不能使用Markdown编写的布局。 不过，使用其他填充引擎作为模版的布局是可能的，
通过传递<code>:layout_engine</code>选项:</p>

<p>~~~~ ruby get &#39;/&#39; do  markdown :index, :layout_engine =&gt; :erb
end ~~~~</p>

<p>这将会调用 <code>./views/index.md</code> 并使用 <code>./views/layout.erb</code>
作为布局。</p>

<p>请记住你可以全局设定这个选项:</p>

<p>~~~~ ruby set :markdown, :layout_engine =&gt; :haml, :layout =&gt; :post</p>

<p>get &#39;/&#39; do  markdown :index end ~~~~</p>

<p>这将会调用 <code>./views/index.markdown</code> (和任何其他的 Markdown 模版) 并使用
<code>./views/post.haml</code> 作为布局.</p>

<p>也可能使用BlueCloth而不是RDiscount来解析Markdown文件:</p>

<p>~~~~ ruby require &#39;bluecloth&#39;</p>

<p>Tilt.register &#39;markdown&#39;, BlueClothTemplate Tilt.register
&#39;mkd&#39;, BlueClothTemplate Tilt.register &#39;md&#39;,
BlueClothTemplate</p>

<p>get &#39;/&#39; do  markdown :index end ~~~~</p>

<p>使用BlueCloth来填充 <code>./views/index.md</code> 。</p>

<h3 id="label-Textile+-E6-A8-A1-E6-9D-BF">Textile 模板<span><a href="#label-Textile+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>RedCloth</code> gem/library 以填充 Textile 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5redcloth">在你的应用中引入redcloth<span><a href="#label-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5redcloth">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require “redcloth”</p>

<p>get &#39;/&#39; do  textile :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.textile</code>。</p>

<p>在textile中是不可以调用方法的，也不可以传递 locals给它。 你因此一般会结合其他的填充引擎来使用它：</p>

<p>~~~~ ruby erb :overview, :locals =&gt; { :text =&gt; textile(:introduction)
} ~~~~</p>

<p>请注意你也可以从其他模板中调用<code>textile</code>方法：</p>

<p>~~~~ ruby %h1 Hello From Haml! %p= textile(:greetings) ~~~~</p>

<p>既然你不能在Textile中调用Ruby，你不能使用Textile编写的布局。 不过，使用其他填充引擎作为模版的布局是可能的，
通过传递<code>:layout_engine</code>选项:</p>

<p>~~~~ ruby get &#39;/&#39; do  textile :index, :layout_engine =&gt; :erb end
~~~~</p>

<p>这将会填充 <code>./views/index.textile</code> 并使用
<code>./views/layout.erb</code> 作为布局。</p>

<p>请记住你可以全局设定这个选项:</p>

<p>~~~~ ruby set :textile, :layout_engine =&gt; :haml, :layout =&gt; :post</p>

<p>get &#39;/&#39; do  textile :index end ~~~~</p>

<p>这将会调用 <code>./views/index.textile</code> (和任何其他的 Textile 模版) 并使用
<code>./views/post.haml</code> 作为布局.</p>

<h3 id="label-RDoc+-E6-A8-A1-E6-9D-BF">RDoc 模板<span><a href="#label-RDoc+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>RDoc</code> gem/library 以填充RDoc模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5rdoc-2Fmarkup-2Fto_html">需要在你的应用中引入rdoc/markup/to_html<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5rdoc-2Fmarkup-2Fto_html">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require “rdoc” require “rdoc/markup/to_html”</p>

<p>get &#39;/&#39; do  rdoc :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.rdoc</code>。</p>

<p>在rdoc中是不可以调用方法的，也不可以传递locals给它。 你因此一般会结合其他的填充引擎来使用它：</p>

<p>~~~~ ruby erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }
~~~~</p>

<p>请注意你也可以从其他模板中调用<code>rdoc</code>方法：</p>

<p>~~~~ ruby %h1 Hello From Haml! %p= rdoc(:greetings) ~~~~</p>

<p>既然你不能在RDoc中调用Ruby，你不能使用RDoc编写的布局。 不过，使用其他填充引擎作为模版的布局是可能的，
通过传递<code>:layout_engine</code>选项:</p>

<p>~~~~ ruby get &#39;/&#39; do  rdoc :index, :layout_engine =&gt; :erb end
~~~~</p>

<p>这将会调用 <code>./views/index.rdoc</code> 并使用 <code>./views/layout.erb</code>
作为布局。</p>

<p>请记住你可以全局设定这个选项:</p>

<p>~~~~ ruby set :rdoc, :layout_engine =&gt; :haml, :layout =&gt; :post</p>

<p>get &#39;/&#39; do  rdoc :index end ~~~~</p>

<p>这将会调用 <code>./views/index.rdoc</code> (和任何其他的 RDoc 模版) 并使用
<code>./views/post.haml</code> 作为布局.</p>

<h3 id="label-Radius+-E6-A8-A1-E6-9D-BF">Radius 模板<span><a href="#label-Radius+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>radius</code> gem/library 以填充 Radius 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5radius">需要在你的应用中引入radius<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5radius">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;radius&#39;</p>

<p>get &#39;/&#39; do  radius :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.radius</code>。</p>

<p>因为你不能在Radius 模板中调用 Ruby 方法 (除了 <code>yield</code>) ， 你几乎总是需要传递locals给它：</p>

<p>~~~~ ruby radius :index, :locals =&gt; { :key =&gt; &#39;value&#39; } ~~~~</p>

<h3 id="label-Markaby+-E6-A8-A1-E6-9D-BF">Markaby 模板<span><a href="#label-Markaby+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入<code>markaby</code> gem/library以填充Markaby模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+markaby">需要在你的应用中引入 markaby<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+markaby">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;markaby&#39;</p>

<p>get &#39;/&#39; do  markaby :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.mab</code>。</p>

<p>你也可以使用嵌入的 Markaby:</p>

<p>~~~~ ruby get &#39;/&#39; do  markaby { h1 “Welcome!” } end ~~~~</p>

<h3 id="label-Slim+-E6-A8-A1-E6-9D-BF">Slim 模板<span><a href="#label-Slim+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>slim</code> gem/library 来填充 Slim 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+slim">需要在你的应用中引入 slim<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+slim">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;slim&#39;</p>

<p>get &#39;/&#39; do  slim :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.slim</code>。</p>

<h3 id="label-Creole+-E6-A8-A1-E6-9D-BF">Creole 模板<span><a href="#label-Creole+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>creole</code> gem/library 来填充 Creole 模板：</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+creole">需要在你的应用中引入 creole<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5+creole">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;creole&#39;</p>

<p>get &#39;/&#39; do  creole :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.creole</code>。</p>

<h3 id="label-CoffeeScript+-E6-A8-A1-E6-9D-BF">CoffeeScript 模板<span><a href="#label-CoffeeScript+-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>需要引入 <code>coffee-script</code> gem/library 并至少满足下面条件一项 以执行Javascript:</p>
<ul><li>
<p><code>node</code> (来自 Node.js) 在你的路径中</p>
</li><li>
<p>你正在运行 OSX</p>
</li><li>
<p><code>therubyracer</code> gem/library</p>
</li></ul>

<p>请察看 <a
href="http://github.com/josh/ruby-coffee-script">github.com/josh/ruby-coffee-script</a>
获取更新的选项。</p>

<p>现在你可以调用 CoffeeScript 模版了:</p>

<p>~~~~ ruby</p>

<h1 id="label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5coffee-script">需要在你的应用中引入coffee-script<span><a href="#label-E9-9C-80-E8-A6-81-E5-9C-A8-E4-BD-A0-E7-9A-84-E5-BA-94-E7-94-A8-E4-B8-AD-E5-BC-95-E5-85-A5coffee-script">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;coffee-script&#39;</p>

<p>get &#39;/application.js&#39; do  coffee :application end ~~~~</p>

<p>这里调用的是 <code>./views/application.coffee</code>。</p>

<h3 id="label-E5-B5-8C-E5-85-A5-E6-A8-A1-E6-9D-BF-E5-AD-97-E7-AC-A6-E4-B8-B2">嵌入模板字符串<span><a href="#label-E5-B5-8C-E5-85-A5-E6-A8-A1-E6-9D-BF-E5-AD-97-E7-AC-A6-E4-B8-B2">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>~~~~ ruby get &#39;/&#39; do  haml &#39;%div.title Hello World&#39; end
~~~~</p>

<p>调用嵌入模板字符串。</p>

<h3 id="label-E5-9C-A8-E6-A8-A1-E6-9D-BF-E4-B8-AD-E8-AE-BF-E9-97-AE-E5-8F-98-E9-87-8F">在模板中访问变量<span><a href="#label-E5-9C-A8-E6-A8-A1-E6-9D-BF-E4-B8-AD-E8-AE-BF-E9-97-AE-E5-8F-98-E9-87-8F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>模板和路由执行器在同样的上下文求值。 在路由执行器中赋值的实例变量可以直接被模板访问。</p>

<p>~~~~ ruby get &#39;/:id&#39; do  @foo = <a href="'id'">Foo.find(params</a>)
haml &#39;%h1= @foo.name&#39; end ~~~~</p>

<p>或者，显式地指定一个本地变量的哈希：</p>

<p>~~~~ ruby get &#39;/:id&#39; do  foo = <a href="'id'">Foo.find(params</a>) 
haml &#39;%h1= foo.name&#39;, :locals =&gt; { :foo =&gt; foo } end ~~~~</p>

<p>典型的使用情况是在别的模板中按照局部模板的方式来填充。</p>

<h3 id="label-E5-86-85-E8-81-94-E6-A8-A1-E6-9D-BF">内联模板<span><a href="#label-E5-86-85-E8-81-94-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>模板可以在源文件的末尾定义：</p>

<p>~~~~ ruby require &#39;sinatra&#39;</p>

<p>get &#39;/&#39; do  haml :index end</p>

<p><strong>END</strong></p>

<p>@@ layout %html  = yield</p>

<p>@@ index %div.title Hello world!!!!! ~~~~</p>

<p>注意：引入sinatra的源文件中定义的内联模板才能被自动载入。 如果你在其他源文件中有内联模板， 需要显式执行调用<code>enable
:inline_templates</code>。</p>

<h3 id="label-E5-85-B7-E5-90-8D-E6-A8-A1-E6-9D-BF">具名模板<span><a href="#label-E5-85-B7-E5-90-8D-E6-A8-A1-E6-9D-BF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>模板可以通过使用顶层 <code>template</code> 方法定义：</p>

<p>~~~~ ruby template :layout do  “%htmln =yieldn” end</p>

<p>template :index do  &#39;%div.title Hello World!&#39; end</p>

<p>get &#39;/&#39; do  haml :index end ~~~~</p>

<p>如果存在名为“layout”的模板，该模板会在每个模板填充的时候被使用。 你可以单独地通过传送 <code>:layout =&gt;
false</code>来禁用， 或者通过<code>set :haml, :layout =&gt; false</code>来禁用他们。</p>

<p>~~~~ ruby get &#39;/&#39; do  haml :index, :layout =&gt; !request.xhr? end
~~~~</p>

<h3 id="label-E5-85-B3-E8-81-94-E6-96-87-E4-BB-B6-E6-89-A9-E5-B1-95-E5-90-8D">关联文件扩展名<span><a href="#label-E5-85-B3-E8-81-94-E6-96-87-E4-BB-B6-E6-89-A9-E5-B1-95-E5-90-8D">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>为了关联一个文件扩展名到一个模版引擎，使用 <code>Tilt.register</code>。比如，如果你喜欢使用 <code>tt</code>
作为Textile模版的扩展名，你可以这样做:</p>

<p>~~~~ ruby Tilt.register :tt, <a href=":textile">Tilt</a> ~~~~</p>

<h3 id="label-E6-B7-BB-E5-8A-A0-E4-BD-A0-E8-87-AA-E5-B7-B1-E7-9A-84-E6-A8-A1-E7-89-88-E5-BC-95-E6-93-8E">添加你自己的模版引擎<span><a href="#label-E6-B7-BB-E5-8A-A0-E4-BD-A0-E8-87-AA-E5-B7-B1-E7-9A-84-E6-A8-A1-E7-89-88-E5-BC-95-E6-93-8E">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>首先，通过Tilt注册你自己的引擎，然后创建一个填充方法:</p>

<p>~~~~ ruby Tilt.register :myat, MyAwesomeTemplateEngine</p>

<p>helpers do  def myat(*args) render(:myat, *args) end end</p>

<p>get &#39;/&#39; do  myat :index end ~~~~</p>

<p>这里调用的是 <code>./views/index.myat</code>。察看 <a
href="https://github.com/rtomayko/tilt">github.com/rtomayko/tilt</a>
来更多了解Tilt.</p>

<h2 id="label-E8-BF-87-E6-BB-A4-E5-99-A8">过滤器<span><a href="#label-E8-BF-87-E6-BB-A4-E5-99-A8">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>前置过滤器在每个请求前，在请求的上下文环境中被执行， 而且可以修改请求和响应。 在过滤器中设定的实例变量可以被路由和模板访问：</p>

<p>~~~~ ruby before do  @note = &#39;Hi!&#39;  request.path_info =
&#39;/foo/bar/baz&#39; end</p>

<p>get &#39;/foo/*&#39; do  @note #=&gt; &#39;Hi!&#39;  <a
href="'splat'">params</a> #=&gt; &#39;bar/baz&#39; end ~~~~</p>

<p>后置过滤器在每个请求之后，在请求的上下文环境中执行， 而且可以修改请求和响应。 在前置过滤器和路由中设定的实例变量可以被后置过滤器访问：</p>

<p>~~~~ ruby after do  puts response.status end ~~~~</p>

<p>请注意：除非你显式使用 <code>body</code> 方法，而不是在路由中直接返回字符串， 消息体在后置过滤器是不可用的，
因为它在之后才会生成。</p>

<p>过滤器可以可选地带有范式， 只有请求路径满足该范式时才会执行：</p>

<p>~~~~ ruby before &#39;/protected/*&#39; do  authenticate! end</p>

<p>after &#39;/create/:slug&#39; do |slug|  <a href="'last_slug'">session</a>
= slug end ~~~~</p>

<p>和路由一样，过滤器也可以带有条件:</p>

<p>~~~~ ruby before :agent =&gt; /Songbird/ do  # … end</p>

<p>after &#39;/blog/*&#39;, :host_name =&gt; &#39;example.com&#39; do  # … end
~~~~</p>

<h2 id="label-E8-BE-85-E5-8A-A9-E6-96-B9-E6-B3-95">辅助方法<span><a href="#label-E8-BE-85-E5-8A-A9-E6-96-B9-E6-B3-95">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>使用顶层的 <code>helpers</code> 方法来定义辅助方法， 以便在路由处理器和模板中使用：</p>

<p>~~~~ ruby helpers do  def bar(name)  “#{name}bar”  end end</p>

<p>get &#39;/:name&#39; do  <a href="'name'">bar(params</a>) end ~~~~</p>

<h3 id="label-E4-BD-BF-E7-94-A8+Sessions">使用 Sessions<span><a href="#label-E4-BD-BF-E7-94-A8+Sessions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Session被用来在请求之间保持状态。如果被激活，每一个用户会话 对应有一个session哈希:</p>

<p>~~~~ ruby enable :sessions</p>

<p>get &#39;/&#39; do  “value = ” &lt;&lt; <a
href="'value'">session</a>.inspect end</p>

<p>get &#39;/:value&#39; do  <a href="'value'">session</a> = <a
href="'value'">params</a> end ~~~~</p>

<p>请注意 <code>enable :sessions</code> 实际上保存所有的数据在一个cookie之中。
这可能不会总是做你想要的（比如，保存大量的数据会增加你的流量）。 你可以使用任何的Rack session中间件，为了这么做， *不要*调用
<code>enable :sessions</code>，而是 按照自己的需要引入你的中间件：</p>

<p>~~~~ ruby use Rack::Session::Pool, :expire_after =&gt; 2592000</p>

<p>get &#39;/&#39; do  “value = ” &lt;&lt; <a
href="'value'">session</a>.inspect end</p>

<p>get &#39;/:value&#39; do  <a href="'value'">session</a> = <a
href="'value'">params</a> end ~~~~</p>

<h3 id="label-E6-8C-82-E8-B5-B7">挂起<span><a href="#label-E6-8C-82-E8-B5-B7">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>要想直接地停止请求，在过滤器或者路由中使用：</p>

<p>~~~~ ruby halt ~~~~</p>

<p>你也可以指定挂起时的状态码：</p>

<p>~~~~ ruby halt 410 ~~~~</p>

<p>或者消息体：</p>

<p>~~~~ ruby halt &#39;this will be the body&#39; ~~~~</p>

<p>或者两者;</p>

<p>~~~~ ruby halt 401, &#39;go away!&#39; ~~~~</p>

<p>也可以带消息头：</p>

<p>~~~~ ruby halt 402, {&#39;Content-Type&#39; =&gt; &#39;text/plain&#39;},
&#39;revenge&#39; ~~~~</p>

<h3 id="label-E8-AE-A9-E8-B7-AF">让路<span><a href="#label-E8-AE-A9-E8-B7-AF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>一个路由可以放弃处理，将处理让给下一个匹配的路由，使用 <code>pass</code>：</p>

<p>~~~~ ruby get &#39;/guess/:who&#39; do  pass unless <a
href="'who'">params</a> == &#39;Frank&#39;  &#39;You got me!&#39; end</p>

<p>get &#39;/guess/*&#39; do  &#39;You missed!&#39; end ~~~~</p>

<p>路由代码块被直接退出，控制流继续前进到下一个匹配的路由。 如果没有匹配的路由，将返回404。</p>

<h3 id="label-E8-A7-A6-E5-8F-91-E5-8F-A6-E4-B8-80-E4-B8-AA-E8-B7-AF-E7-94-B1">触发另一个路由<span><a href="#label-E8-A7-A6-E5-8F-91-E5-8F-A6-E4-B8-80-E4-B8-AA-E8-B7-AF-E7-94-B1">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>有些时候，<code>pass</code> 并不是你想要的，你希望得到的是另一个路由的结果 。简单的使用 <code>call</code>
可以做到这一点:</p>

<p>~~~~ ruby get &#39;/foo&#39; do  status, headers, body = call
env.merge(“PATH_INFO” =&gt; &#39;/bar&#39;)  [status, headers,
body.map(&amp;:upcase)] end</p>

<p>get &#39;/bar&#39; do  “bar” end ~~~~</p>

<p>请注意在以上例子中，你可以更加简化测试并增加性能，只要简单的移动</p>

<pre>&lt;tt&gt;&quot;bar&quot;&lt;/tt&gt;到一个被&lt;tt&gt;/foo&lt;/tt&gt;</pre>

<p>和 <code>/bar</code>同时使用的helper。</p>

<p>如果你希望请求被发送到同一个应用，而不是副本， 使用 <code>call!</code> 而不是 <code>call</code>.</p>

<p>如果想更多了解 <code>call</code>，请察看 <a href="Rack.html">Rack</a> specification。</p>

<h3 id="label-E8-AE-BE-E5-AE-9A+-E6-B6-88-E6-81-AF-E4-BD-93-EF-BC-8C-E7-8A-B6-E6-80-81-E7-A0-81-E5-92-8C-E6-B6-88-E6-81-AF-E5-A4-B4">设定 消息体，状态码和消息头<span><a href="#label-E8-AE-BE-E5-AE-9A+-E6-B6-88-E6-81-AF-E4-BD-93-EF-BC-8C-E7-8A-B6-E6-80-81-E7-A0-81-E5-92-8C-E6-B6-88-E6-81-AF-E5-A4-B4">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>通过路由代码块的返回值来设定状态码和消息体不仅是可能的，而且是推荐的。 但是，在某些场景中你可能想在作业流程中的特定点上设置消息体。 你可以通过
<code>body</code> 辅助方法这么做。 如果你这样做了， 你可以在那以后使用该方法获得消息体:</p>

<p>~~~~ ruby get &#39;/foo&#39; do  body “bar” end</p>

<p>after do  puts body end ~~~~</p>

<p>也可以传一个代码块给 <code>body</code>，它将会被Rack处理器执行（ 这将可以被用来实现streaming，参见“返回值”）。</p>

<p>和消息体类似，你也可以设定状态码和消息头:</p>

<p>~~~~ ruby get &#39;/foo&#39; do  status 418  headers \  “Allow” =&gt;
“BREW, POST, GET, PROPFIND, WHEN”,  “Refresh” =&gt; “Refresh: 20; <a
href="http://www.ietf.org/rfc/rfc2324.txt">www.ietf.org/rfc/rfc2324.txt</a>”
body “I&#39;m a tea pot!” end ~~~~</p>

<p>如同 <code>body</code>, 不带参数的 <code>headers</code> 和 <code>status</code>
可以用来访问 他们你的当前值.</p>

<h3 id="label-E5-AA-92-E4-BD-93-28MIME-29-E7-B1-BB-E5-9E-8B">媒体(MIME)类型<span><a href="#label-E5-AA-92-E4-BD-93-28MIME-29-E7-B1-BB-E5-9E-8B">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>使用 <code>send_file</code> 或者静态文件的时候，Sinatra可能不能识别你的媒体类型。 使用
<code>mime_type</code> 通过文件扩展名来注册它们：</p>

<p>~~~~ ruby mime_type :foo, &#39;text/foo&#39; ~~~~</p>

<p>你也可以使用 <code>content_type</code> 辅助方法：</p>

<p>~~~~ ruby get &#39;/&#39; do  content_type :foo  “foo foo foo” end ~~~~</p>

<h3 id="label-E7-94-9F-E6-88-90+URL">生成 URL<span><a href="#label-E7-94-9F-E6-88-90+URL">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>为了生成URL，你需要使用 <code>url</code> 辅助方法， 例如，在Haml中:</p>

<p>~~~~ ruby %a{:href =&gt; url(&#39;/foo&#39;)} foo ~~~~</p>

<p>如果使用反向代理和Rack路由，生成URL的时候会考虑这些因素。</p>

<p>这个方法还有一个别名 <code>to</code> (见下面的例子).</p>

<h3 id="label-E6-B5-8F-E8-A7-88-E5-99-A8-E9-87-8D-E5-AE-9A-E5-90-91">浏览器重定向<span><a href="#label-E6-B5-8F-E8-A7-88-E5-99-A8-E9-87-8D-E5-AE-9A-E5-90-91">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>你可以通过 <code>redirect</code> 辅助方法触发浏览器重定向:</p>

<p>~~~~ ruby get &#39;/foo&#39; do  redirect to(&#39;/bar&#39;) end ~~~~</p>

<p>其他参数的用法，与 <code>halt</code>相同:</p>

<p>~~~~ ruby redirect to(&#39;/bar&#39;), 303 redirect &#39;<a
href="http://google.com">google.com</a>&#39;, &#39;wrong place, buddy&#39;
~~~~</p>

<p>用 <code>redirect back</code>可以把用户重定向到原始页面:</p>

<p>~~~~ ruby get &#39;/foo&#39; do  “&lt;a href=&#39;/bar&#39;&gt;do
something&lt;/a&gt;” end</p>

<p>get &#39;/bar&#39; do  do_something  redirect back end ~~~~</p>

<p>如果想传递参数给redirect，可以用query string:</p>

<p>~~~~ ruby redirect to(&#39;/bar?sum=42&#39;) ~~~~</p>

<p>或者用session:</p>

<p>~~~~ ruby enable :sessions</p>

<p>get &#39;/foo&#39; do  <a href="'secret'">session</a> = &#39;foo&#39; 
redirect to(&#39;/bar&#39;) end</p>

<p>get &#39;/bar&#39; do  <a href="'secret'">session</a> end ~~~~</p>

<h3 id="label-E7-BC-93-E5-AD-98-E6-8E-A7-E5-88-B6">缓存控制<span><a href="#label-E7-BC-93-E5-AD-98-E6-8E-A7-E5-88-B6">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>要使用HTTP缓存，必须正确地设定消息头。</p>

<p>你可以这样设定 Cache-Control 消息头:</p>

<p>~~~~ ruby get &#39;/&#39; do  cache_control :public  “cache it!” end ~~~~</p>

<p>核心提示: 在前置过滤器中设定缓存.</p>

<p>~~~~ ruby before do  cache_control :public, :must_revalidate, :max_age
=&gt; 60 end ~~~~</p>

<p>如果你正在用 <code>expires</code> 辅助方法设定对应的消息头 <code>Cache-Control</code> 会自动设定：</p>

<p>~~~~ ruby before do  expires 500, :public, :must_revalidate end ~~~~</p>

<p>为了合适地使用缓存，你应该考虑使用 <code>etag</code> 和 <code>last_modified</code>方法。
推荐在执行繁重任务*之前*使用这些helpers，这样一来， 如果客户端在缓存中已经有相关内容，就会立即得到显示。</p>

<p>~~~~ ruby get &#39;/article/:id&#39; do  @article = Article.find <a
href="'id'">params</a>  last_modified @article.updated_at  etag
@article.sha1  erb :article end ~~~~</p>

<p>使用 <a
href="http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak
ETag</a> 也是有可能的:</p>

<p>~~~~ ruby etag @article.sha1, :weak ~~~~</p>

<p>这些辅助方法并不会为你做任何缓存，而是将必要的信息传送给你的缓存 如果你在寻找缓存的快速解决方案，试试 <a
href="https://github.com/rtomayko/rack-cache">rack-cache</a>:</p>

<p>~~~~ ruby require “rack/cache” require “sinatra”</p>

<p>use Rack::Cache</p>

<p>get &#39;/&#39; do  cache_control :public, :max_age =&gt; 36000  sleep 5 
“hello” end ~~~~</p>

<h3 id="label-E5-8F-91-E9-80-81-E6-96-87-E4-BB-B6">发送文件<span><a href="#label-E5-8F-91-E9-80-81-E6-96-87-E4-BB-B6">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>为了发送文件，你可以使用 <code>send_file</code> 辅助方法:</p>

<p>~~~~ ruby get &#39;/&#39; do  send_file &#39;foo.png&#39; end ~~~~</p>

<p>也可以带一些选项:</p>

<p>~~~~ ruby send_file &#39;foo.png&#39;, :type =&gt; :jpg ~~~~</p>

<p>可用的选项有:</p>
<dl>
    <dt>filename</dt>
    <dd>响应中的文件名，默认是真实文件的名字。</dd>

    <dt>last_modified</dt>
    <dd>Last-Modified 消息头的值，默认是文件的mtime（修改时间）。</dd>

    <dt>type</dt>
    <dd>使用的内容类型，如果没有会从文件扩展名猜测。</dd>

    <dt>disposition</dt>
    <dd>
        用于 Content-Disposition，可能的包括： <tt>nil</tt> (默认), <tt>:attachment</tt> 和
        <tt>:inline</tt>
    </dd>

    <dt>length</dt>
    <dd>Content-Length 的值，默认是文件的大小。</dd>
</dl>
<p>如果Rack处理器支持的话，Ruby进程也能使用除streaming以外的方法。 如果你使用这个辅助方法， Sinatra会自动处理range请求。</p>

<h3 id="label-E8-AE-BF-E9-97-AE-E8-AF-B7-E6-B1-82-E5-AF-B9-E8-B1-A1">访问请求对象<span><a href="#label-E8-AE-BF-E9-97-AE-E8-AF-B7-E6-B1-82-E5-AF-B9-E8-B1-A1">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>传入的请求对象可以在请求层（过滤器，路由，错误处理） 通过 <code>request</code> 方法被访问：</p>

<p>~~~~ ruby</p>

<h1 id="label-E5-9C-A8+http-3A-2F-2Fexample.com-2Fexample+-E4-B8-8A-E8-BF-90-E8-A1-8C-E7-9A-84-E5-BA-94-E7-94-A8">在 <a href="http://example.com/example">example.com/example</a> 上运行的应用<span><a href="#label-E5-9C-A8+http-3A-2F-2Fexample.com-2Fexample+-E4-B8-8A-E8-BF-90-E8-A1-8C-E7-9A-84-E5-BA-94-E7-94-A8">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>get &#39;/foo&#39; do  request.body # 被客户端设定的请求体（见下）  request.scheme #
“http”  request.script_name # “/example”  request.path_info # “/foo” 
request.port # 80  request.request_method # “GET”  request.query_string #
“”  request.content_length # request.body的长度  request.media_type #
request.body的媒体类型  request.host # “example.com”  request.get? # true
(其他动词也具有类似方法)  request.form_data? # false  <a
href=""SOME_HEADER"">request</a> # SOME_HEADER header的值  request.referrer #
客户端的referrer 或者 &#39;/&#39;  request.user_agent # user agent (被 :agent
条件使用)  request.cookies # 浏览器 cookies 哈希  request.xhr? # 这是否是ajax请求？ 
request.url # “<a
href="http://example.com/example/foo">example.com/example/foo</a>” 
request.path # “/example/foo”  request.ip # 客户端IP地址  request.secure? #
false（如果是ssl则为true）  request.forwarded? # true （如果是运行在反向代理之后）  request.env
# Rack中使用的未处理的env哈希 end ~~~~</p>

<p>一些选项，例如 <code>script_name</code> 或者 <code>path_info</code> 也是可写的：</p>

<p>~~~~ ruby before { request.path_info = “/” }</p>

<p>get “/” do  “all requests end up here” end ~~~~</p>

<p><code>request.body</code> 是一个IO或者StringIO对象：</p>

<p>~~~~ ruby post “/api” do  request.body.rewind # 如果已经有人读了它  data =
JSON.parse request.body.read  “Hello #{<a href="'name'">data</a>}!” end
~~~~</p>

<h3 id="label-E9-99-84-E4-BB-B6">附件<span><a href="#label-E9-99-84-E4-BB-B6">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>你可以使用 <code>attachment</code> 辅助方法来告诉浏览器响应 应当被写入磁盘而不是在浏览器中显示。</p>

<p>~~~~ ruby get &#39;/&#39; do  attachment  “store it!” end ~~~~</p>

<p>你也可以传递一个文件名:</p>

<p>~~~~ ruby get &#39;/&#39; do  attachment “info.txt”  “store it!” end ~~~~</p>

<h3 id="label-E6-9F-A5-E6-89-BE-E6-A8-A1-E6-9D-BF-E6-96-87-E4-BB-B6">查找模板文件<span><a href="#label-E6-9F-A5-E6-89-BE-E6-A8-A1-E6-9D-BF-E6-96-87-E4-BB-B6">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><code>find_template</code> 辅助方法被用于在填充时查找模板文件:</p>

<p>~~~~ ruby find_template settings.views, &#39;foo&#39;, <a
href=":haml">Tilt</a> do |file|  puts “could be #{file}” end ~~~~</p>

<p>这并不是很有用。但是在你需要重载这个方法 来实现你自己的查找机制的时候有用。 比如，如果你想支持多于一个视图目录:</p>

<p>~~~~ ruby set :views, [&#39;views&#39;, &#39;templates&#39;]</p>

<p>helpers do  def find_template(views, name, engine, &amp;block) 
Array(views).each { |v| super(v, name, engine, &amp;block) }  end end ~~~~</p>

<p>另一个例子是为不同的引擎使用不同的目录:</p>

<p>~~~~ ruby set :views, :sass =&gt; &#39;views/sass&#39;, :haml =&gt;
&#39;templates&#39;, :default =&gt; &#39;views&#39;</p>

<p>helpers do  def find_template(views, name, engine, &amp;block)  _, folder =
views.detect { |k,v| engine == <a href="k">Tilt</a> }  folder ||= <a
href=":default">views</a>  super(folder, name, engine, &amp;block)  end end
~~~~</p>

<p>你可以很容易地包装成一个扩展然后与他人分享！</p>

<p>请注意 <code>find_template</code> 并不会检查文件真的存在， 而是对任何可能的路径调用给入的代码块。这并不会带来性能问题，
因为 <code>render</code> 会在找到文件的时候马上使用 <code>break</code> 。
同样的，模板的路径（和内容）会在除development mode以外的场合 被缓存。你应该时刻提醒自己这一点， 如果你真的想写一个非常疯狂的方法。</p>

<h2 id="label-E9-85-8D-E7-BD-AE">配置<span><a href="#label-E9-85-8D-E7-BD-AE">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>运行一次，在启动的时候，在任何环境下：</p>

<p>~~~~ ruby configure do  # setting one option  set :option, &#39;value&#39;</p>

<p># setting multiple options  set :a =&gt; 1, :b =&gt; 2</p>

<p># same as <code>set :option, true</code>  enable :option</p>

<p># same as <code>set :option, false</code>  disable :option</p>

<p># you can also have dynamic settings with blocks  set(:css_dir) {
File.join(views, &#39;css&#39;) } end ~~~~</p>

<p>只当环境 (RACK_ENV environment 变量) 被设定为 <code>:production</code>的时候运行：</p>

<p>~~~~ ruby configure :production do  … end ~~~~</p>

<p>当环境被设定为 <code>:production</code> 或者 <code>:test</code>的时候运行：</p>

<p>~~~~ ruby configure :production, :test do  … end ~~~~</p>

<p>你可以使用 <code>settings</code> 获得这些配置:</p>

<p>~~~~ ruby configure do  set :foo, &#39;bar&#39; end</p>

<p>get &#39;/&#39; do  settings.foo? # =&gt; true  settings.foo # =&gt;
&#39;bar&#39;  … end ~~~~</p>

<h3 id="label-E5-8F-AF-E9-80-89-E7-9A-84-E8-AE-BE-E7-BD-AE">可选的设置<span><a href="#label-E5-8F-AF-E9-80-89-E7-9A-84-E8-AE-BE-E7-BD-AE">&para;</a> <a href="#top">&uarr;</a></span></h3>
<dl>
    <dt>absolute_redirects</dt>
    <dd>
        <p>
            如果被禁用，Sinatra会允许使用相对路径重定向， 但是，Sinatra就不再遵守
            RFC 2616标准 (HTTP 1.1), 该标准只允许绝对路径重定向。
        </p>

        <p>
            如果你的应用运行在一个未恰当设置的反向代理之后，
            你需要启用这个选项。注意 <tt>url</tt> 辅助方法 仍然会生成绝对 URL，除非你传入
            <tt>false</tt> 作为第二参数。
        </p>
        <p>
            默认禁用。
        </p>
    </dd>

    <dt>add_charset</dt>
    <dd>
        <p>
            设定 <tt>content_type</tt> 辅助方法会 自动加上字符集信息的多媒体类型。
        </p>

        <p>
            你应该添加而不是覆盖这个选项:
            <tt>settings.add_charset << "application/foobar"</tt>
        </p>
    </dd>

    <dt>app_file</dt>
    <dd>
        主应用文件，用来检测项目的根路径， views和public文件夹和内联模板。
    </dd>

    <dt>bind</dt>
    <dd>
        绑定的IP 地址 (默认: 0.0.0.0)。 仅对于内置的服务器有用。
    </dd>

    <dt>default_encoding</dt>
    <dd>
        默认编码 (默认为 <tt>"utf-8"</tt>)。
    </dd>

    <dt>dump_errors</dt>
    <dd>
        在log中显示错误。
    </dd>

    <dt>environment</dt>
    <dd>
        当前环境，默认是 <tt>ENV['RACK_ENV']</tt>， 或者 <tt>"development"</tt> 如果不可用。
    </dd>

    <dt>logging</dt>
    <dd>
        使用logger
    </dd>

    <dt>lock</dt>
    <dd>
        <p>
            对每一个请求放置一个锁， 只使用进程并发处理请求。
        </p>

        <p>
            如果你的应用不是线程安全则需启动。 默认禁用。
        </p>
    </dd>

    <dt>method_override</dt>
    <dd>
        使用 <tt>_method</tt> 魔法以允许在旧的浏览器中在 表单中使用 put/delete 方法
    </dd>

    <dt>port</dt>
    <dd>
        监听的端口号。只对内置服务器有用。
    </dd>

    <dt>prefixed_redirects</dt>
    <dd>
        是否添加 <tt>request.script_name</tt> 到
        重定向请求，如果没有设定绝对路径。那样的话 <tt>redirect '/foo'</tt> 会和
        <tt>redirect to('/foo')</tt>起相同作用。默认禁用。
    </dd>

    <dt>public_folder</dt>
    <dd>
        public文件夹的位置。
    </dd>

    <dt>reload_templates</dt>
    <dd>
        是否每个请求都重新载入模板。 在development mode和 Ruby 1.8.6
        中被企业（用来 消除一个Ruby内存泄漏的bug）。
    </dd>

    <dt>root</dt>
    <dd>
        项目的根目录。
    </dd>

    <dt>raise_errors</dt>
    <dd>
        抛出异常（应用会停下）。
    </dd>

    <dt>run</dt>
    <dd>
        如果启用，Sinatra会开启web服务器。 如果使用rackup或其他方式则不要启用。
    </dd>

    <dt>running</dt>
    <dd>
        内置的服务器在运行吗？ 不要修改这个设置！
    </dd>

    <dt>server</dt>
    <dd>
        服务器，或用于内置服务器的列表。 默认是 [‘thin’, ‘mongrel’, ‘webrick’],
        顺序表明了 优先级。
    </dd>

    <dt>sessions</dt>
    <dd>
        开启基于cookie的sesson。
    </dd>

    <dt>show_exceptions</dt>
    <dd>
        在浏览器中显示一个stack trace。
    </dd>

    <dt>static</dt>
    <dd>
        Sinatra是否处理静态文件。 当服务器能够处理则禁用。 禁用会增强性能。
        默认开启。
    </dd>

    <dt>views</dt>
    <dd>
        views 文件夹。
    </dd>
</dl>
<h2 id="label-E9-94-99-E8-AF-AF-E5-A4-84-E7-90-86">错误处理<span><a href="#label-E9-94-99-E8-AF-AF-E5-A4-84-E7-90-86">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>错误处理在与路由和前置过滤器相同的上下文中运行， 这意味着你可以使用许多好东西，比如 <code>haml</code>,
<code>erb</code>, <code>halt</code>，等等。</p>

<h3 id="label-E6-9C-AA-E6-89-BE-E5-88-B0">未找到<span><a href="#label-E6-9C-AA-E6-89-BE-E5-88-B0">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>当一个 <code>Sinatra::NotFound</code> 错误被抛出的时候，
或者响应状态码是404，<code>not_found</code> 处理器会被调用：</p>

<p>~~~~ ruby not_found do  &#39;This is nowhere to be found&#39; end ~~~~</p>

<h3 id="label-E9-94-99-E8-AF-AF">错误<span><a href="#label-E9-94-99-E8-AF-AF">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><code>error</code> 处理器，在任何路由代码块或者过滤器抛出异常的时候会被调用。
异常对象可以通过<code>sinatra.error</code> <a href="Rack.html">Rack</a> 变量获得：</p>

<p>~~~~ ruby error do  &#39;Sorry there was a nasty error - &#39; + <a
href="'sinatra.error'">env</a>.message end ~~~~</p>

<p>自定义错误：</p>

<p>~~~~ ruby error MyCustomError do  &#39;So what happened was…&#39; + <a
href="'sinatra.error'">env</a>.message end ~~~~</p>

<p>那么，当这个发生的时候：</p>

<p>~~~~ ruby get &#39;/&#39; do  raise MyCustomError, &#39;something bad&#39;
end ~~~~</p>

<p>你会得到：</p>

<pre>So what happened was... something bad</pre>

<p>另一种替代方法是，为一个状态码安装错误处理器：</p>

<p>~~~~ ruby error 403 do  &#39;Access forbidden&#39; end</p>

<p>get &#39;/secret&#39; do  403 end ~~~~</p>

<p>或者一个范围：</p>

<p>~~~~ ruby error 400..510 do  &#39;Boom&#39; end ~~~~</p>

<p>在运行在development环境下时，Sinatra会安装特殊的 <code>not_found</code> 和
<code>error</code> 处理器。</p>

<h2 id="label-Rack+-E4-B8-AD-E9-97-B4-E4-BB-B6"><a href="Rack.html">Rack</a> 中间件<span><a href="#label-Rack+-E4-B8-AD-E9-97-B4-E4-BB-B6">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="Sinatra.html">Sinatra</a> 依靠 <a
href="http://rack.github.io/">Rack</a>, 一个面向Ruby web框架的最小标准接口。
Rack的一个最有趣的面向应用开发者的能力是支持“中间件”——坐落在服务器和你的应用之间， 监视 并/或 操作HTTP请求/响应以
提供多样类型的常用功能。</p>

<p><a href="Sinatra.html">Sinatra</a> 让建立Rack中间件管道异常简单， 通过顶层的 <code>use</code>
方法：</p>

<p>~~~~ ruby require &#39;sinatra&#39; require &#39;my_custom_middleware&#39;</p>

<p>use Rack::Lint use MyCustomMiddleware</p>

<p>get &#39;/hello&#39; do  &#39;Hello World&#39; end ~~~~</p>

<p><code>use</code> 的语义和在 <a
href="http://rubydoc.info/github/rack/rack/master/Rack/Builder">Rack::Builder</a>
DSL(在rack文件中最频繁使用)中定义的完全一样。例如，<code>use</code> 方法接受 多个/可变 参数，包括代码块：</p>

<p>~~~~ ruby use Rack::Auth::Basic do |username, password|  username ==
&#39;admin&#39; &amp;&amp; password == &#39;secret&#39; end ~~~~</p>

<p>Rack中分布有多样的标准中间件，针对日志， 调试，URL路由，认证和session处理。 Sinatra会自动使用这里面的大部分组件，
所以你一般不需要显示地 <code>use</code> 他们。</p>

<h2 id="label-E6-B5-8B-E8-AF-95">测试<span><a href="#label-E6-B5-8B-E8-AF-95">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Sinatra的测试可以使用任何基于Rack的测试程序库或者框架来编写。 <a
href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a> 是推荐候选：</p>

<p>~~~~ ruby require &#39;my_sinatra_app&#39; require
&#39;minitest/autorun&#39; require &#39;rack/test&#39;</p>

<p>class MyAppTest &lt; Minitest::Test  include Rack::Test::Methods</p>

<p>def app  <a href="Sinatra/Application.html">Sinatra::Application</a>  end</p>

<p>def test_my_default  get &#39;/&#39;  assert_equal &#39;Hello World!&#39;,
last_response.body  end</p>

<p>def test_with_params  get &#39;/meet&#39;, :name =&gt; &#39;Frank&#39; 
assert_equal &#39;Hello Frank!&#39;, last_response.body  end</p>

<p>def test_with_rack_env  get &#39;/&#39;, {}, &#39;HTTP_USER_AGENT&#39;
=&gt; &#39;Songbird&#39;  assert_equal “You&#39;re using Songbird!”,
last_response.body  end end ~~~~</p>

<p>请注意: 内置的 Sinatra::Test 模块和 Sinatra::TestHarness 类 在 0.9.2 版本已废弃。</p>

<h2 id="label-Sinatra-3A-3ABase+-+-E4-B8-AD-E9-97-B4-E4-BB-B6-EF-BC-8C-E7-A8-8B-E5-BA-8F-E5-BA-93-E5-92-8C-E6-A8-A1-E5-9D-97-E5-8C-96-E5-BA-94-E7-94-A8">Sinatra::Base - 中间件，程序库和模块化应用<span><a href="#label-Sinatra-3A-3ABase+-+-E4-B8-AD-E9-97-B4-E4-BB-B6-EF-BC-8C-E7-A8-8B-E5-BA-8F-E5-BA-93-E5-92-8C-E6-A8-A1-E5-9D-97-E5-8C-96-E5-BA-94-E7-94-A8">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>把你的应用定义在顶层，对于微型应用这会工作得很好， 但是在构建可复用的组件时候会带来客观的不利， 比如构建Rack中间件，Rails
metal，带有服务器组件的简单程序库， 或者甚至是Sinatra扩展。顶层的DSL污染了Object命名空间， 并假定了一个微型应用风格的配置
(例如, 单一的应用文件， ./public 和 ./views 目录，日志，异常细节页面，等等）。 这时应该让 Sinatra::Base
走到台前了：</p>

<p>~~~~ ruby require &#39;sinatra/base&#39;</p>

<p>class MyApp &lt; Sinatra::Base  set :sessions, true  set :foo,
&#39;bar&#39;</p>

<p>get &#39;/&#39; do  &#39;Hello world!&#39;  end end ~~~~</p>

<p>Sinatra::Base子类可用的方法实际上就是通过顶层 DSL 可用的方法。 大部分顶层应用可以通过两个改变转换成Sinatra::Base组件：</p>
<ul><li>
<p>你的文件应当引入 <code>sinatra/base</code> 而不是 <code>sinatra</code>; 否则，所有的Sinatra的
DSL 方法将会被引进到 主命名空间。</p>
</li><li>
<p>把你的应用的路由，错误处理，过滤器和选项放在 一个Sinatra::Base的子类中。</p>
</li></ul>

<p><code>Sinatra::Base</code> 是一张白纸。大部分的选项默认是禁用的， 包含内置的服务器。参见 <a
href="http://sinatra.github.com/configuration.html">选项和配置</a>
查看可用选项的具体细节和他们的行为。</p>

<h3 id="label-E6-A8-A1-E5-9D-97-E5-8C-96+vs.+-E4-BC-A0-E7-BB-9F-E7-9A-84-E6-96-B9-E5-BC-8F">模块化 vs. 传统的方式<span><a href="#label-E6-A8-A1-E5-9D-97-E5-8C-96+vs.+-E4-BC-A0-E7-BB-9F-E7-9A-84-E6-96-B9-E5-BC-8F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>与通常的认识相反，传统的方式没有任何错误。 如果它适合你的应用，你不需要转换到模块化的应用。</p>

<p>和模块化方式相比只有两个缺点:</p>
<ul><li>
<p>你对每个Ruby进程只能定义一个Sinatra应用，如果你需要更多， 切换到模块化方式。</p>
</li><li>
<p>传统方式使用代理方法污染了 Object 。如果你打算 把你的应用封装进一个 library/gem，转换到模块化方式。</p>
</li></ul>

<p>没有任何原因阻止你混合模块化和传统方式。</p>

<p>如果从一种转换到另一种，你需要注意settings中的 一些微小的不同:</p>

<pre>Setting             Classic                 Modular

app_file            file loading sinatra    nil
run                 $0 == app_file          false
logging             true                    false
method_override     true                    false
inline_templates    true                    false</pre>

<h3 id="label-E8-BF-90-E8-A1-8C-E4-B8-80-E4-B8-AA-E6-A8-A1-E5-9D-97-E5-8C-96-E5-BA-94-E7-94-A8">运行一个模块化应用<span><a href="#label-E8-BF-90-E8-A1-8C-E4-B8-80-E4-B8-AA-E6-A8-A1-E5-9D-97-E5-8C-96-E5-BA-94-E7-94-A8">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>有两种方式运行一个模块化应用，使用 <code>run!</code>来运行:</p>

<p>~~~~ ruby</p>

<h1 id="label-my_app.rb">my_app.rb<span><a href="#label-my_app.rb">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;sinatra/base&#39;</p>

<p>class MyApp &lt; Sinatra::Base  # … app code here …</p>

<p># start the server if ruby file executed directly  run! if app_file == $0
end ~~~~</p>

<p>运行:</p>

<pre class="ruby"><span class="ruby-identifier">ruby</span> <span class="ruby-identifier">my_app</span>.<span class="ruby-identifier">rb</span>
</pre>

<p>或者使用一个 <code>config.ru</code>，允许你使用任何Rack处理器:</p>

<p>~~~~ ruby</p>

<h1 id="label-config.ru">config.ru<span><a href="#label-config.ru">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;./my_app&#39; run MyApp ~~~~</p>

<p>运行:</p>

<pre>rackup -p 4567</pre>

<h3 id="label-E4-BD-BF-E7-94-A8config.ru-E8-BF-90-E8-A1-8C-E4-BC-A0-E7-BB-9F-E6-96-B9-E5-BC-8F-E7-9A-84-E5-BA-94-E7-94-A8">使用config.ru运行传统方式的应用<span><a href="#label-E4-BD-BF-E7-94-A8config.ru-E8-BF-90-E8-A1-8C-E4-BC-A0-E7-BB-9F-E6-96-B9-E5-BC-8F-E7-9A-84-E5-BA-94-E7-94-A8">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>编写你的应用:</p>

<p>~~~~ ruby</p>

<h1 id="label-app.rb">app.rb<span><a href="#label-app.rb">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>require &#39;sinatra&#39;</p>

<p>get &#39;/&#39; do  &#39;Hello world!&#39; end ~~~~</p>

<p>加入相应的 <code>config.ru</code>:</p>

<p>~~~~ ruby require &#39;./app&#39; run <a
href="Sinatra/Application.html">Sinatra::Application</a> ~~~~</p>

<h3 id="label-E4-BB-80-E4-B9-88-E6-97-B6-E5-80-99-E7-94-A8+config.ru-3F">什么时候用 config.ru?<span><a href="#label-E4-BB-80-E4-B9-88-E6-97-B6-E5-80-99-E7-94-A8+config.ru-3F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>以下情况你可能需要使用 <code>config.ru</code>:</p>
<ul><li>
<p>你要使用不同的 <a href="Rack.html">Rack</a> 处理器部署 (Passenger, Unicorn, Heroku, …).</p>
</li><li>
<p>你想使用一个或者多个 <code>Sinatra::Base</code>的子类.</p>
</li><li>
<p>你只想把Sinatra当作中间件使用，而不是端点。</p>
</li></ul>

<p><strong>你并不需要切换到<code>config.ru</code>仅仅因为你切换到模块化方式， 你同样不需要切换到模块化方式，
仅仅因为要运行 <code>config.ru</code>.</strong></p>

<h3 id="label-E6-8A-8ASinatra-E5-BD-93-E6-88-90-E4-B8-AD-E9-97-B4-E4-BB-B6-E6-9D-A5-E4-BD-BF-E7-94-A8">把Sinatra当成中间件来使用<span><a href="#label-E6-8A-8ASinatra-E5-BD-93-E6-88-90-E4-B8-AD-E9-97-B4-E4-BB-B6-E6-9D-A5-E4-BD-BF-E7-94-A8">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>不仅Sinatra有能力使用其他的Rack中间件，任何Sinatra 应用程序都可以反过来自身被当作中间件，被加在任何Rack端点前面。
这个端点可以是任何Sinatra应用，或者任何基于Rack的应用程序 (Rails/Ramaze/Camping/…)。</p>

<p>~~~~ ruby require &#39;sinatra/base&#39;</p>

<p>class LoginScreen &lt; Sinatra::Base  enable :sessions</p>

<p>get(&#39;/login&#39;) { haml :login }</p>

<p>post(&#39;/login&#39;) do  if <a href="'name'">params</a> = &#39;admin&#39;
and <a href="'password'">params</a> = &#39;admin&#39;  <a
href="'user_name'">session</a> = <a href="'name'">params</a>  else 
redirect &#39;/login&#39;  end  end end</p>

<p>class MyApp &lt; Sinatra::Base  # 在前置过滤器前运行中间件  use LoginScreen</p>

<p>before do  unless <a href="'user_name'">session</a>  halt “Access denied,
please &lt;a href=&#39;/login&#39;&gt;login&lt;/a&gt;.”  end  end</p>

<p>get(&#39;/&#39;) { “Hello #{<a href="'user_name'">session</a>}.” } end ~~~~</p>

<h2 id="label-E5-8F-98-E9-87-8F-E5-9F-9F-E5-92-8C-E7-BB-91-E5-AE-9A">变量域和绑定<span><a href="#label-E5-8F-98-E9-87-8F-E5-9F-9F-E5-92-8C-E7-BB-91-E5-AE-9A">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>当前所在的变量域决定了哪些方法和变量是可用的。</p>

<h3 id="label-E5-BA-94-E7-94-A8-2F-E7-B1-BB+-E5-8F-98-E9-87-8F-E5-9F-9F">应用/类 变量域<span><a href="#label-E5-BA-94-E7-94-A8-2F-E7-B1-BB+-E5-8F-98-E9-87-8F-E5-9F-9F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>每个Sinatra应用相当与Sinatra::Base的一个子类。 如果你在使用顶层DSL(<code>require
&#39;sinatra&#39;</code>)，那么这个类就是 Sinatra::Application，或者这个类就是你显式创建的子类。
在类层面，你具有的方法类似于 `get` 或者 `before`，但是你不能访问 `request` 对象或者 `session`,
因为对于所有的请求， 只有单一的应用类。</p>

<p>通过 `set` 创建的选项是类层面的方法：</p>

<p>~~~~ ruby class MyApp &lt; Sinatra::Base  # 嘿，我在应用变量域！  set :foo, 42  foo #
=&gt; 42</p>

<p>get &#39;/foo&#39; do  # 嘿，我不再处于应用变量域了！  end end ~~~~</p>

<p>在下列情况下你将拥有应用变量域的绑定：</p>
<ul><li>
<p>在应用类中</p>
</li><li>
<p>在扩展中定义的方法</p>
</li><li>
<p>传递给 `helpers` 的代码块</p>
</li><li>
<p>用作`set`值的过程/代码块</p>
</li></ul>

<p>你可以访问变量域对象（就是应用类）就像这样：</p>
<ul><li>
<p>通过传递给代码块的对象 (<code>configure { |c| ... }</code>)</p>
</li><li>
<p>在请求变量域中使用`settings`</p>
</li></ul>

<h3 id="label-E8-AF-B7-E6-B1-82-2F-E5-AE-9E-E4-BE-8B+-E5-8F-98-E9-87-8F-E5-9F-9F">请求/实例 变量域<span><a href="#label-E8-AF-B7-E6-B1-82-2F-E5-AE-9E-E4-BE-8B+-E5-8F-98-E9-87-8F-E5-9F-9F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>对于每个进入的请求，一个新的应用类的实例会被创建 所有的处理器代码块在该变量域被运行。在这个变量域中， 你可以访问 `request` 和
`session` 对象，或者调用填充方法比如 `erb` 或者 `haml`。你可以在请求变量域当中通过`settings`辅助方法
访问应用变量域：</p>

<p>~~~~ ruby class MyApp &lt; Sinatra::Base  # 嘿，我在应用变量域!  get
&#39;/define_route/:name&#39; do  # 针对 &#39;/define_route/:name&#39; 的请求变量域
@value = 42</p>

<pre class="ruby"><span class="ruby-identifier">settings</span>.<span class="ruby-identifier">get</span>(<span class="ruby-node">&quot;/#{params[&#39;name&#39;]}&quot;</span>) <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># 针对 &quot;/#{params[&#39;name&#39;]}&quot; 的请求变量域</span>
  <span class="ruby-ivar">@value</span> <span class="ruby-comment"># =&gt; nil (并不是相同的请求)</span>
<span class="ruby-keyword">end</span>

<span class="ruby-string">&quot;Route defined!&quot;</span>
</pre>

<p>end end ~~~~</p>

<p>在以下情况将获得请求变量域：</p>
<ul><li>
<p>get/head/post/put/delete 代码块</p>
</li><li>
<p>前置/后置 过滤器</p>
</li><li>
<p>辅助方法</p>
</li><li>
<p>模板/视图</p>
</li></ul>

<h3 id="label-E4-BB-A3-E7-90-86-E5-8F-98-E9-87-8F-E5-9F-9F">代理变量域<span><a href="#label-E4-BB-A3-E7-90-86-E5-8F-98-E9-87-8F-E5-9F-9F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>代理变量域只是把方法转送到类变量域。可是， 他并非表现得100%类似于类变量域, 因为你并不能获得类的绑定:
只有显式地标记为供代理使用的方法才是可用的， 而且你不能和类变量域共享变量/状态。(解释：你有了一个不同的 `self`)。
你可以显式地增加方法代理，通过调用 <code>Sinatra::Delegator.delegate :method_name</code>。</p>

<p>在以下情况将获得代理变量域：</p>
<ul><li>
<p>顶层的绑定，如果你做过 <code>require &quot;sinatra&quot;</code></p>
</li><li>
<p>在扩展了 `Sinatra::Delegator` mixin的对象</p>
</li></ul>

<p>自己在这里看一下代码: <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128">Sinatra::Delegator
mixin</a> 已经 <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28">被包含进了主命名空间</a>。</p>

<h2 id="label-E5-91-BD-E4-BB-A4-E8-A1-8C">命令行<span><a href="#label-E5-91-BD-E4-BB-A4-E8-A1-8C">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="Sinatra.html">Sinatra</a> 应用可以被直接运行：</p>

<pre>ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]</pre>

<p>选项是：</p>

<pre class="ruby"><span class="ruby-operator">-</span><span class="ruby-identifier">h</span> <span class="ruby-comment"># help</span>
<span class="ruby-operator">-</span><span class="ruby-identifier">p</span> <span class="ruby-comment"># 设定端口 (默认是 4567)</span>
<span class="ruby-operator">-</span><span class="ruby-identifier">o</span> <span class="ruby-comment"># 设定主机名 (默认是 0.0.0.0)</span>
<span class="ruby-operator">-</span><span class="ruby-identifier">e</span> <span class="ruby-comment"># 设定环境 (默认是 development)</span>
<span class="ruby-operator">-</span><span class="ruby-identifier">s</span> <span class="ruby-comment"># 限定 rack 服务器/处理器 (默认是 thin)</span>
<span class="ruby-operator">-</span><span class="ruby-identifier">x</span> <span class="ruby-comment"># 打开互斥锁 (默认是 off)</span>
</pre>

<h2 id="label-E5-BF-85-E8-A6-81-E6-9D-A1-E4-BB-B6">必要条件<span><a href="#label-E5-BF-85-E8-A6-81-E6-9D-A1-E4-BB-B6">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>推荐在 Ruby 1.8.7, 1.9.2, JRuby 或者 Rubinius 上安装Sinatra。</p>

<p>下面的Ruby版本是官方支持的:</p>
<dl>
    <dt>Ruby 1.8.6</dt>
    <dd>
        不推荐在1.8.6上安装Sinatra， 但是直到Sinatra
        1.3.0发布才会放弃对它的支持。 RDoc 和
        CoffeScript模板不被这个Ruby版本支持。
        1.8.6在它的Hash实现中包含一个内存泄漏问题，
        该问题会被1.1.1版本之前的Sinatra引发。
        当前版本使用性能下降的代价排除了这个问题。你需要把Rack降级到1.1.x，
        因为Rack \>= 1.2不再支持1.8.6。
    </dd>

    <dt>Ruby 1.8.7</dt>
    <dd>
        1.8.7 被完全支持，但是，如果没有特别原因， 我们推荐你升级到 1.9.2
        或者切换到 JRuby 或者 Rubinius.
    </dd>

    <dt>Ruby 1.9.2</dt>
    <dd>
        1.9.2 被支持而且推荐。注意 Radius 和 Markaby 模板并不和1.9兼容。不要使用
        1.9.2p0, 它被已知会产生 segmentation faults.
    </dd>

    <dt>Rubinius</dt>
    <dd>
        Rubinius 被官方支持 (Rubinius \>= 1.2.2)， 除了Textile模板。
    </dd>

    <dt>JRuby</dt>
    <dd>
        JRuby 被官方支持 (JRuby \>= 1.5.6)。 目前未知和第三方模板库有关的问题，
        但是，如果你选择了JRuby，请查看一下JRuby rack 处理器， 因为 Thin web
        服务器还没有在JRuby上获得支持。
    </dd>
</dl>
<p>我们也会时刻关注新的Ruby版本。</p>

<p>下面的 Ruby 实现没有被官方支持， 但是已知可以运行 Sinatra:</p>
<ul><li>
<p>JRuby 和 Rubinius 老版本</p>
</li><li>
<p>MacRuby</p>
</li><li>
<p>Maglev</p>
</li><li>
<p>IronRuby</p>
</li><li>
<p>Ruby 1.9.0 and 1.9.1</p>
</li></ul>

<p>不被官方支持的意思是，如果在不被支持的平台上有运行错误， 我们假定不是我们的问题，而是平台的问题。</p>

<p>Sinatra应该会运行在任何支持上述Ruby实现的操作系统。</p>

<h2 id="label-E7-B4-A7-E8-BF-BD-E5-89-8D-E6-B2-BF">紧追前沿<span><a href="#label-E7-B4-A7-E8-BF-BD-E5-89-8D-E6-B2-BF">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>如果你喜欢使用 <a href="Sinatra.html">Sinatra</a> 的最新鲜的代码，请放心的使用 master
分支来运行你的程序，它会非常的稳定。</p>

<pre>cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb</pre>

<p>我们也会不定期的发布预发布gems，所以你也可以运行</p>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-identifier">install</span> <span class="ruby-identifier">sinatra</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-identifier">pre</span>
</pre>

<p>来获得最新的特性。</p>

<h3 id="label-E9-80-9A-E8-BF-87Bundler">通过Bundler<span><a href="#label-E9-80-9A-E8-BF-87Bundler">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>如果你想使用最新的Sinatra运行你的应用，通过 <a href="http://gembundler.com/">Bundler</a>
是推荐的方式。</p>

<p>首先，安装bundler，如果你还没有安装:</p>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-identifier">install</span> <span class="ruby-identifier">bundler</span>
</pre>

<p>然后，在你的项目目录下，创建一个 <code>Gemfile</code>:</p>

<p>~~~~ ruby source :rubygems gem &#39;sinatra&#39;, :git =&gt;
“git://github.com/sinatra/sinatra.git”</p>

<h1 id="label-E5-85-B6-E4-BB-96-E7-9A-84-E4-BE-9D-E8-B5-96-E5-85-B3-E7-B3-BB">其他的依赖关系<span><a href="#label-E5-85-B6-E4-BB-96-E7-9A-84-E4-BE-9D-E8-B5-96-E5-85-B3-E7-B3-BB">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>gem &#39;haml&#39; # 举例，如果你想用haml gem &#39;activerecord&#39;, &#39;~&gt;
3.0&#39; # 也许你还需要 ActiveRecord 3.x ~~~~</p>

<p>请注意在这里你需要列出你的应用的所有依赖关系。 Sinatra的直接依赖关系 (Rack and Tilt) 将会， 自动被Bundler获取和添加。</p>

<p>现在你可以像这样运行你的应用:</p>

<pre class="ruby"><span class="ruby-identifier">bundle</span> <span class="ruby-identifier">exec</span> <span class="ruby-identifier">ruby</span> <span class="ruby-identifier">myapp</span>.<span class="ruby-identifier">rb</span>
</pre>

<h3 id="label-E4-BD-BF-E7-94-A8-E8-87-AA-E5-B7-B1-E7-9A-84">使用自己的<span><a href="#label-E4-BD-BF-E7-94-A8-E8-87-AA-E5-B7-B1-E7-9A-84">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>创建一个本地克隆并通过 <code>sinatra/lib</code> 目录运行你的应用， 通过 <code>$LOAD_PATH</code>:</p>

<pre>cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb</pre>

<p>为了在未来更新 <a href="Sinatra.html">Sinatra</a> 源代码:</p>

<pre class="ruby"><span class="ruby-identifier">cd</span> <span class="ruby-identifier">myapp</span><span class="ruby-operator">/</span><span class="ruby-identifier">sinatra</span>
<span class="ruby-identifier">git</span> <span class="ruby-identifier">pull</span>
</pre>

<h3 id="label-E5-85-A8-E5-B1-80-E5-AE-89-E8-A3-85">全局安装<span><a href="#label-E5-85-A8-E5-B1-80-E5-AE-89-E8-A3-85">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>你可以自行编译 gem :</p>

<pre>git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install</pre>

<p>如果你以root身份安装 gems，最后一步应该是</p>

<pre class="ruby"><span class="ruby-identifier">sudo</span> <span class="ruby-identifier">rake</span> <span class="ruby-identifier">install</span>
</pre>

<h2 id="label-E6-9B-B4-E5-A4-9A">更多<span><a href="#label-E6-9B-B4-E5-A4-9A">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><a href="http://www.sinatrarb.com/">项目主页（英文）</a> - 更多的文档， 新闻，和其他资源的链接。</p>
</li><li>
<p><a href="http://www.sinatrarb.com/contributing">贡献</a> - 找到了一个bug？
需要帮助？有了一个 patch?</p>
</li><li>
<p><a href="http://github.com/sinatra/sinatra/issues">问题追踪</a></p>
</li><li>
<p><a href="http://twitter.com/sinatra">Twitter</a></p>
</li><li>
<p><a href="http://groups.google.com/group/sinatrarb/topics">邮件列表</a></p>
</li><li>
<p><a href="irc://chat.freenode.net/#sinatra"> #sinatra</a> on <a
href="http://freenode.net">freenode.net</a></p>
</li><li>
<p><a href="https://github.com/sinatra/sinatra-book/">Sinatra宝典</a> Cookbook教程</p>
</li><li>
<p><a href="http://recipes.sinatrarb.com/">Sinatra使用技巧</a> 网友贡献的实用技巧</p>
</li><li>
<p><a
href="http://rubydoc.info/github/sinatra/sinatra">最新版本}[http://rubydoc.info/gems/sinatra]API文档；{http://rubydoc.info}[http://rubydoc.info]的{当前HEAD</a></p>
</li><li>
<p><a href="http://travis-ci.org/sinatra/sinatra">CI服务器</a></p>
</li></ul>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

