var search_data = {"index":{"searchIndex":["slop","arrayoption","booloption","booleanoption","error","intoption","integeroption","missingargument","notimplementederror","nulloption","option","options","parser","result","stringoption","unknownoption","[]()","add_option()","args()","arguments()","call()","call()","call()","call()","call()","call()","call()","default_value()","default_value()","default_value()","default_value()","delimiter()","each()","ensure_call()","expects_argument?()","expects_argument?()","expects_argument?()","finish()","flag()","get()","help?()","key()","longest_flag_length()","longest_option()","matching_option()","method_missing()","method_missing()","new()","new()","new()","new()","null?()","null?()","on()","option()","option_defined?()","parse()","parse()","parse()","process()","reset()","reset()","respond_to_missing?()","respond_to_missing?()","separator()","string_to_option()","string_to_option_class()","suppress_errors?()","suppress_errors?()","to_a()","to_h()","to_hash()","to_s()","to_s()","to_s()","try_process()","unused_options()","unused_options()","used_options()","used_options()","value()"],"longSearchIndex":["slop","slop::arrayoption","slop::booloption","slop::booleanoption","slop::error","slop::intoption","slop::integeroption","slop::missingargument","slop::notimplementederror","slop::nulloption","slop::option","slop::options","slop::parser","slop::result","slop::stringoption","slop::unknownoption","slop::result#[]()","slop::options#add_option()","slop::result#args()","slop::result#arguments()","slop::arrayoption#call()","slop::booloption#call()","slop::booloption#call()","slop::integeroption#call()","slop::integeroption#call()","slop::option#call()","slop::stringoption#call()","slop::arrayoption#default_value()","slop::booloption#default_value()","slop::booloption#default_value()","slop::option#default_value()","slop::arrayoption#delimiter()","slop::options#each()","slop::option#ensure_call()","slop::booloption#expects_argument?()","slop::booloption#expects_argument?()","slop::option#expects_argument?()","slop::option#finish()","slop::option#flag()","slop::result#get()","slop::option#help?()","slop::option#key()","slop::options#longest_flag_length()","slop::options#longest_option()","slop::parser#matching_option()","slop::options#method_missing()","slop::result#method_missing()","slop::option::new()","slop::options::new()","slop::parser::new()","slop::result::new()","slop::nulloption#null?()","slop::option#null?()","slop::options#on()","slop::result#option()","slop::option_defined?()","slop::parse()","slop::options#parse()","slop::parser#parse()","slop::parser#process()","slop::option#reset()","slop::parser#reset()","slop::options#respond_to_missing?()","slop::result#respond_to_missing?()","slop::options#separator()","slop::string_to_option()","slop::string_to_option_class()","slop::option#suppress_errors?()","slop::parser#suppress_errors?()","slop::options#to_a()","slop::result#to_h()","slop::result#to_hash()","slop::option#to_s()","slop::options#to_s()","slop::result#to_s()","slop::parser#try_process()","slop::parser#unused_options()","slop::result#unused_options()","slop::parser#used_options()","slop::result#used_options()","slop::option#value()"],"info":[["Slop","","Slop.html","",""],["Slop::ArrayOption","","Slop/ArrayOption.html","",""],["Slop::BoolOption","","Slop/BoolOption.html","",""],["Slop::BooleanOption","","Slop/BooleanOption.html","",""],["Slop::Error","","Slop/Error.html","","<p>Base error class.\n"],["Slop::IntOption","","Slop/IntOption.html","",""],["Slop::IntegerOption","","Slop/IntegerOption.html","",""],["Slop::MissingArgument","","Slop/MissingArgument.html","","<p>Raised when an option that expects an argument is executed without one.\nSuppress with the `suppress_errors` …\n"],["Slop::NotImplementedError","","Slop/NotImplementedError.html","","<p>Raised when calling `call` on Slop::Option (this method must be overriden\nin subclasses)\n"],["Slop::NullOption","","Slop/NullOption.html","","<p>an option that discards the return value\n"],["Slop::Option","","Slop/Option.html","",""],["Slop::Options","","Slop/Options.html","",""],["Slop::Parser","","Slop/Parser.html","",""],["Slop::Result","","Slop/Result.html","","<p>This class encapsulates a Parser and Options pair. The idea is that the\nOptions class shouldn&#39;t have …\n"],["Slop::StringOption","","Slop/StringOption.html","",""],["Slop::UnknownOption","","Slop/UnknownOption.html","","<p>Raised when an unknown option is parsed. Suppress with the\n`suppress_errors` config option.\n"],["[]","Slop::Result","Slop/Result.html#method-i-5B-5D","(flag)","<p>Returns an options value, nil if the option does not exist.\n"],["add_option","Slop::Options","Slop/Options.html#method-i-add_option","(option)",""],["args","Slop::Result","Slop/Result.html#method-i-args","()",""],["arguments","Slop::Result","Slop/Result.html#method-i-arguments","()","<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">opts</span> = <span class=\"ruby-constant\">Slop</span>.<span class=\"ruby-identifier\">parse</span> <span class=\"ruby-keyword\">do</span> <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">o</span><span class=\"ruby-operator\">|</span>\n  <span class=\"ruby-identifier\">o</span>.<span class=\"ruby-identifier\">string</span> <span class=\"ruby-string\">&#39;--host&#39;</span>\n  <span class=\"ruby-identifier\">o</span>.<span class=\"ruby-identifier\">int</span> <span class=\"ruby-string\">&#39;-p&#39;</span>\n<span class=\"ruby-keyword\">end</span>\n\n<span class=\"ruby-comment\"># ruby run.rb connect --host 123 ...</span>\n</pre>\n"],["call","Slop::ArrayOption","Slop/ArrayOption.html#method-i-call","(value)",""],["call","Slop::BoolOption","Slop/BoolOption.html#method-i-call","(_value)",""],["call","Slop::BoolOption","Slop/BoolOption.html#method-i-call","(_value)",""],["call","Slop::IntegerOption","Slop/IntegerOption.html#method-i-call","(value)",""],["call","Slop::IntegerOption","Slop/IntegerOption.html#method-i-call","(value)",""],["call","Slop::Option","Slop/Option.html#method-i-call","(_value)","<p>This method is called immediately when an option is found. Override it in\nsub-classes.\n"],["call","Slop::StringOption","Slop/StringOption.html#method-i-call","(value)",""],["default_value","Slop::ArrayOption","Slop/ArrayOption.html#method-i-default_value","()",""],["default_value","Slop::BoolOption","Slop/BoolOption.html#method-i-default_value","()",""],["default_value","Slop::BoolOption","Slop/BoolOption.html#method-i-default_value","()",""],["default_value","Slop::Option","Slop/Option.html#method-i-default_value","()","<p>Returns the default value for this option (default is nil).\n"],["delimiter","Slop::ArrayOption","Slop/ArrayOption.html#method-i-delimiter","()",""],["each","Slop::Options","Slop/Options.html#method-i-each","(&block)","<p>Implements the Enumerable interface.\n"],["ensure_call","Slop::Option","Slop/Option.html#method-i-ensure_call","(value)","<p>Since `call()` can be used/overriden in subclasses, this method is used to\ndo general tasks like increment …\n"],["expects_argument?","Slop::BoolOption","Slop/BoolOption.html#method-i-expects_argument-3F","()",""],["expects_argument?","Slop::BoolOption","Slop/BoolOption.html#method-i-expects_argument-3F","()",""],["expects_argument?","Slop::Option","Slop/Option.html#method-i-expects_argument-3F","()","<p>Override this if this option type does not expect an argument (i.e a\nboolean option type).\n"],["finish","Slop::Option","Slop/Option.html#method-i-finish","(_result)","<p>By default this method does nothing. It&#39;s called when all options have\nbeen parsed and allows you …\n"],["flag","Slop::Option","Slop/Option.html#method-i-flag","()","<p>Returns all flags joined by a comma. Used by the help string.\n"],["get","Slop::Result","Slop/Result.html#method-i-get","(flag)",""],["help?","Slop::Option","Slop/Option.html#method-i-help-3F","()","<p>Returns true if this option should be displayed in help text.\n"],["key","Slop::Option","Slop/Option.html#method-i-key","()","<p>Returns the last key as a symbol. Used in Options.to_hash.\n"],["longest_flag_length","Slop::Options","Slop/Options.html#method-i-longest_flag_length","()",""],["longest_option","Slop::Options","Slop/Options.html#method-i-longest_option","()",""],["matching_option","Slop::Parser","Slop/Parser.html#method-i-matching_option","(flag)",""],["method_missing","Slop::Options","Slop/Options.html#method-i-method_missing","(name, *args, **config, &block)","<p>Handle custom option types. Will fall back to raising an exception if an\noption is not defined.\n"],["method_missing","Slop::Result","Slop/Result.html#method-i-method_missing","(name, *args, &block)",""],["new","Slop::Option","Slop/Option.html#method-c-new","(flags, desc, **config, &block)",""],["new","Slop::Options","Slop/Options.html#method-c-new","(**config)",""],["new","Slop::Parser","Slop/Parser.html#method-c-new","(options, **config)",""],["new","Slop::Result","Slop/Result.html#method-c-new","(parser)",""],["null?","Slop::NullOption","Slop/NullOption.html#method-i-null-3F","()",""],["null?","Slop::Option","Slop/Option.html#method-i-null-3F","()","<p>Override this if you want to ignore the return value for an option (i.e so\nResult#to_hash does not include …\n"],["on","Slop::Options","Slop/Options.html#method-i-on","(*flags, **config, &block)","<p>Add a new option. This method is an alias for adding a NullOption (i.e an\noption with an ignored return …\n"],["option","Slop::Result","Slop/Result.html#method-i-option","(flag)","<p>Returns an Option if it exists. Ignores any prefixed hyphens.\n"],["option_defined?","Slop","Slop.html#method-c-option_defined-3F","(name)","<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Slop</span>.<span class=\"ruby-identifier\">option_defined?</span>(:<span class=\"ruby-identifier\">string</span>) <span class=\"ruby-comment\">#=&gt; true</span>\n<span class=\"ruby-constant\">Slop</span>.<span class=\"ruby-identifier\">option_defined?</span>(:<span class=\"ruby-identifier\">omg</span>)    <span class=\"ruby-comment\">#=&gt; false</span>\n</pre>\n<p>Returns true if …\n"],["parse","Slop","Slop.html#method-c-parse","(items = ARGV, **config, &block)","<p>Parse an array of options (defaults to ARGV). Accepts an optional hash of\nconfiguration options and block. …\n"],["parse","Slop::Options","Slop/Options.html#method-i-parse","(strings)","<p>Sugar to avoid `options.parser.parse(x)`.\n"],["parse","Slop::Parser","Slop/Parser.html#method-i-parse","(strings)","<p>Traverse `strings` and process options one by one. Anything after `–` is\nignored. If a flag includes …\n"],["process","Slop::Parser","Slop/Parser.html#method-i-process","(option, arg)","<p>We&#39;ve found an option, process and return it\n"],["reset","Slop::Option","Slop/Option.html#method-i-reset","()","<p>Reset the option count and value. Used when calling .reset on the Parser.\n"],["reset","Slop::Parser","Slop/Parser.html#method-i-reset","()","<p>Reset the parser, useful to use the same instance to parse a second time\nwithout duplicating state.\n"],["respond_to_missing?","Slop::Options","Slop/Options.html#method-i-respond_to_missing-3F","(name, include_private = false)",""],["respond_to_missing?","Slop::Result","Slop/Result.html#method-i-respond_to_missing-3F","(name, include_private = false)",""],["separator","Slop::Options","Slop/Options.html#method-i-separator","(string)","<p>Add a separator between options. Used when displaying the help text.\n"],["string_to_option","Slop","Slop.html#method-c-string_to_option","(s)","<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Slop</span>.<span class=\"ruby-identifier\">string_to_option</span>(<span class=\"ruby-string\">&quot;string&quot;</span>)     <span class=\"ruby-comment\">#=&gt; &quot;StringOption&quot;</span>\n<span class=\"ruby-constant\">Slop</span>.<span class=\"ruby-identifier\">string_to_option</span>(<span class=\"ruby-string\">&quot;some_thing&quot;</span>) <span class=\"ruby-comment\">#=&gt; ...</span>\n</pre>\n"],["string_to_option_class","Slop","Slop.html#method-c-string_to_option_class","(s)","<p>Example:\n\n<pre>Slop.string_to_option_class(&quot;string&quot;) #=&gt; Slop::StringOption\nSlop.string_to_option_class(&quot;foo&quot;) ...</pre>\n"],["suppress_errors?","Slop::Option","Slop/Option.html#method-i-suppress_errors-3F","()","<p>Returns true if we should ignore errors that cause exceptions to be raised.\n"],["suppress_errors?","Slop::Parser","Slop/Parser.html#method-i-suppress_errors-3F","()",""],["to_a","Slop::Options","Slop/Options.html#method-i-to_a","()","<p>Return a copy of our options Array.\n"],["to_h","Slop::Result","Slop/Result.html#method-i-to_h","()",""],["to_hash","Slop::Result","Slop/Result.html#method-i-to_hash","()","<p>Returns a hash with option key =&gt; value.\n"],["to_s","Slop::Option","Slop/Option.html#method-i-to_s","(offset: 0)","<p>Returns the help text for this option (flags and description).\n"],["to_s","Slop::Options","Slop/Options.html#method-i-to_s","(prefix: \" \" * 4)","<p>Returns the help text for this options. Used by Result#to_s.\n"],["to_s","Slop::Result","Slop/Result.html#method-i-to_s","(**opts)",""],["try_process","Slop::Parser","Slop/Parser.html#method-i-try_process","(flag, arg)","<p>Try and find an option to process\n"],["unused_options","Slop::Parser","Slop/Parser.html#method-i-unused_options","()","<p>Returns an Array of Option instances that were not used.\n"],["unused_options","Slop::Result","Slop/Result.html#method-i-unused_options","()","<p>Returns an Array of Option instances that were not used.\n"],["used_options","Slop::Parser","Slop/Parser.html#method-i-used_options","()","<p>Returns an Array of Option instances that were used.\n"],["used_options","Slop::Result","Slop/Result.html#method-i-used_options","()","<p>Returns an Array of Option instances that were used.\n"],["value","Slop::Option","Slop/Option.html#method-i-value","()","<p>Returns the value for this option. Falls back to the default (or nil).\n"]]}}